//
// Copyright Â© 2017-2019 Arm Limited.
// SPDX-License-Identifier: Apache-2.0
//
// This header file reflects architecture version 1.4.13

// THIS FILE IS AUTOMATICALLY GENERATED -- DO NOT EDIT


#pragma once

#ifdef __KERNEL__
    #include <linux/types.h>
#else
    #include <stdint.h>
#endif

#ifdef __cplusplus
    #include <cassert>
#endif

#if !defined(__cplusplus) || __cplusplus < 201402L
#define CONSTEXPR
#else
#define CONSTEXPR constexpr
#endif

#define NPU_ARCH_VERSION_MAJOR 1
#define NPU_ARCH_VERSION_MINOR 4
#define NPU_ARCH_VERSION_PATCH 13
#define NPU_ARCH_BASENAME "SCYLLA"

// Register offsets

//
// Register subpage CE
//
#define CE_CE_ENABLES 0x0000
#define CE_CE_STATUS 0x0004
#define CE_CE_SETIRQ 0x0008
#define CE_CE_INST 0x000C
#define CE_CE_ID 0x0100
#define CE_CE_ERR_CAUSE 0x0200
#define CE_CE_ERR_ADDRESS 0x0204
#define CE_PLE_CONTROL_0 0x0400
#define CE_PLE_CONTROL_1 0x0404
#define CE_PLE_STATUS 0x0408
#define CE_PLE_SETIRQ 0x040C
#define CE_PLE_UDMA_LOAD_PARAMETERS 0x0414
#define CE_PLE_UDMA_LOAD_COMMAND 0x0418
#define CE_PLE_UDMA_STORE_PARAMETERS 0x041C
#define CE_PLE_UDMA_STORE_COMMAND 0x0420
#define CE_PLE_COUNTERS 0x0424
#define CE_PLE_SCRATCH0 0x1000
#define CE_PLE_SCRATCH1 0x1004
#define CE_PLE_SCRATCH2 0x1008
#define CE_PLE_SCRATCH3 0x100C
#define CE_PLE_SCRATCH4 0x1010
#define CE_PLE_SCRATCH5 0x1014
#define CE_PLE_SCRATCH6 0x1018
#define CE_PLE_SCRATCH7 0x101C
#define CE_PLE_DEBUG_CONTROL 0xD000
#define CE_REGISTERS_SIZE 0xD004

//
// Register subpage CE_BLOCK
//
#define CE_BLOCK_OFM_BLOCK_CONFIG 0x0000
#define CE_BLOCK_OFM_BLOCK_XY 0x0004
#define CE_BLOCK_SUBKERNEL_OFFSET 0x0008
#define CE_BLOCK_REGISTERS_SIZE 0x000C

//
// Register subpage CE_STRIPE
//
#define CE_STRIPE_CE_CONTROL 0x0000
#define CE_STRIPE_WIDE_KERNEL_CONTROL 0x0004
#define CE_STRIPE_WIDE_KERNEL_OFFSET 0x0008
#define CE_STRIPE_IFM_ZERO_POINT 0x000C
#define CE_STRIPE_IFM_DEFAULT_SLOT_SIZE 0x0010
#define CE_STRIPE_IFM_SLOT_STRIDE 0x0014
#define CE_STRIPE_IFM_ROW_STRIDE 0x0018
#define CE_STRIPE_IFM_CONFIG1 0x0020
#define CE_STRIPE_IFM_TOP_SLOTS 0x0024
#define CE_STRIPE_IFM_MID_SLOTS 0x0028
#define CE_STRIPE_IFM_BOTTOM_SLOTS 0x002C
#define CE_STRIPE_IFM_SLOT_PAD_CONFIG 0x0030
#define CE_STRIPE_DEPTHWISE_CONTROL 0x0034
#define CE_STRIPE_IFM_CONFIG2_IG0 0x0040
#define CE_STRIPE_IFM_SLOT_BASE_ADDRESS_IG0 0x0044
#define CE_STRIPE_IFM_PAD0_IG0 0x0050
#define CE_STRIPE_IFM_PAD1_IG0 0x0054
#define CE_STRIPE_IFM_PAD2_IG0 0x0058
#define CE_STRIPE_IFM_PAD3_IG0 0x005C
#define CE_STRIPE_IFM_PAD4_IG0 0x0060
#define CE_STRIPE_IFM_PAD5_IG0 0x0064
#define CE_STRIPE_IFM_PAD6_IG0 0x0068
#define CE_STRIPE_IFM_PAD7_IG0 0x006C
#define CE_STRIPE_IFM_PAD8_IG0 0x0070
#define CE_STRIPE_IFM_PAD9_IG0 0x0074
#define CE_STRIPE_IFM_PAD10_IG0 0x0078
#define CE_STRIPE_IFM_PAD11_IG0 0x007C
#define CE_STRIPE_IFM_PAD12_IG0 0x0080
#define CE_STRIPE_IFM_PAD13_IG0 0x0084
#define CE_STRIPE_IFM_PAD14_IG0 0x0088
#define CE_STRIPE_IFM_PAD15_IG0 0x008C
#define CE_STRIPE_ACTIVATION_CONFIG 0x0100
#define CE_STRIPE_STRIPE_BLOCK_CONFIG 0x0104
#define CE_STRIPE_OFM_STRIPE_SIZE 0x0108
#define CE_STRIPE_OFM_CONFIG 0x010C
#define CE_STRIPE_VP_CONTROL 0x0110
#define CE_STRIPE_FILTER 0x0114
#define CE_STRIPE_MUL_ENABLE_OG0 0x0120
#define CE_STRIPE_WEIGHT_BASE_ADDR_OG0 0x0124
#define CE_STRIPE_IFM_CONFIG2_IG1 0x1040
#define CE_STRIPE_IFM_SLOT_BASE_ADDRESS_IG1 0x1044
#define CE_STRIPE_IFM_PAD0_IG1 0x1050
#define CE_STRIPE_IFM_PAD1_IG1 0x1054
#define CE_STRIPE_IFM_PAD2_IG1 0x1058
#define CE_STRIPE_IFM_PAD3_IG1 0x105C
#define CE_STRIPE_IFM_PAD4_IG1 0x1060
#define CE_STRIPE_IFM_PAD5_IG1 0x1064
#define CE_STRIPE_IFM_PAD6_IG1 0x1068
#define CE_STRIPE_IFM_PAD7_IG1 0x106C
#define CE_STRIPE_IFM_PAD8_IG1 0x1070
#define CE_STRIPE_IFM_PAD9_IG1 0x1074
#define CE_STRIPE_IFM_PAD10_IG1 0x1078
#define CE_STRIPE_IFM_PAD11_IG1 0x107C
#define CE_STRIPE_IFM_PAD12_IG1 0x1080
#define CE_STRIPE_IFM_PAD13_IG1 0x1084
#define CE_STRIPE_IFM_PAD14_IG1 0x1088
#define CE_STRIPE_IFM_PAD15_IG1 0x108C
#define CE_STRIPE_MUL_ENABLE_OG1 0x1120
#define CE_STRIPE_WEIGHT_BASE_ADDR_OG1 0x1124
#define CE_STRIPE_IFM_CONFIG2_IG2 0x2040
#define CE_STRIPE_IFM_SLOT_BASE_ADDRESS_IG2 0x2044
#define CE_STRIPE_IFM_PAD0_IG2 0x2050
#define CE_STRIPE_IFM_PAD1_IG2 0x2054
#define CE_STRIPE_IFM_PAD2_IG2 0x2058
#define CE_STRIPE_IFM_PAD3_IG2 0x205C
#define CE_STRIPE_IFM_PAD4_IG2 0x2060
#define CE_STRIPE_IFM_PAD5_IG2 0x2064
#define CE_STRIPE_IFM_PAD6_IG2 0x2068
#define CE_STRIPE_IFM_PAD7_IG2 0x206C
#define CE_STRIPE_IFM_PAD8_IG2 0x2070
#define CE_STRIPE_IFM_PAD9_IG2 0x2074
#define CE_STRIPE_IFM_PAD10_IG2 0x2078
#define CE_STRIPE_IFM_PAD11_IG2 0x207C
#define CE_STRIPE_IFM_PAD12_IG2 0x2080
#define CE_STRIPE_IFM_PAD13_IG2 0x2084
#define CE_STRIPE_IFM_PAD14_IG2 0x2088
#define CE_STRIPE_IFM_PAD15_IG2 0x208C
#define CE_STRIPE_MUL_ENABLE_OG2 0x2120
#define CE_STRIPE_WEIGHT_BASE_ADDR_OG2 0x2124
#define CE_STRIPE_IFM_CONFIG2_IG3 0x3040
#define CE_STRIPE_IFM_SLOT_BASE_ADDRESS_IG3 0x3044
#define CE_STRIPE_IFM_PAD0_IG3 0x3050
#define CE_STRIPE_IFM_PAD1_IG3 0x3054
#define CE_STRIPE_IFM_PAD2_IG3 0x3058
#define CE_STRIPE_IFM_PAD3_IG3 0x305C
#define CE_STRIPE_IFM_PAD4_IG3 0x3060
#define CE_STRIPE_IFM_PAD5_IG3 0x3064
#define CE_STRIPE_IFM_PAD6_IG3 0x3068
#define CE_STRIPE_IFM_PAD7_IG3 0x306C
#define CE_STRIPE_IFM_PAD8_IG3 0x3070
#define CE_STRIPE_IFM_PAD9_IG3 0x3074
#define CE_STRIPE_IFM_PAD10_IG3 0x3078
#define CE_STRIPE_IFM_PAD11_IG3 0x307C
#define CE_STRIPE_IFM_PAD12_IG3 0x3080
#define CE_STRIPE_IFM_PAD13_IG3 0x3084
#define CE_STRIPE_IFM_PAD14_IG3 0x3088
#define CE_STRIPE_IFM_PAD15_IG3 0x308C
#define CE_STRIPE_MUL_ENABLE_OG3 0x3120
#define CE_STRIPE_WEIGHT_BASE_ADDR_OG3 0x3124
#define CE_STRIPE_MCE_DEBUG_CONTROL 0xD000
#define CE_STRIPE_REGISTERS_SIZE 0xD004

//
// Register subpage DL1
//
#define DL1_EXT_ACCESS_CONTROL 0x0000
#define DL1_DELEGATION 0x0004
#define DL1_SECCTLR 0x0010
#define DL1_SECMCUCTLR 0x0014
#define DL1_SYSCTLR0 0x0018
#define DL1_SYSCTLR1 0x001C
#define DL1_PWRCTLR 0x0020
#define DL1_AUXCTLR 0x0024
#define DL1_SETIRQ_EXT 0x0030
#define DL1_CLRIRQ_EXT 0x0034
#define DL1_SETIRQ_INT 0x0040
#define DL1_DFC_SLV_ORD 0x0080
#define DL1_DFC_SLV_OWR 0x0084
#define DL1_DFC_MST_ORD 0x0090
#define DL1_DFC_MST_OWR 0x0094
#define DL1_IRQ_STATUS 0x00A0
#define DL1_INT_STATUS 0x00A4
#define DL1_EXT_STATUS 0x00A8
#define DL1_GP0 0x1000
#define DL1_GP1 0x1004
#define DL1_GP2 0x1008
#define DL1_GP3 0x100C
#define DL1_GP4 0x1010
#define DL1_GP5 0x1014
#define DL1_GP6 0x1018
#define DL1_GP7 0x101C
#define DL1_DELEGATION_STREAM_SECURITY 0x2000
#define DL1_DELEGATION_NSAID 0x2004
#define DL1_DELEGATION_MMUSID 0x2008
#define DL1_DELEGATION_MMUSSID 0x200C
#define DL1_DELEGATION_MMUSSIDV 0x2010
#define DL1_DELEGATION_ATTR_CONTROL 0x2014
#define DL1_DELEGATION_MEMATTR 0x2018
#define DL1_DELEGATION_ADDRESS_EXTEND 0x201C
#define DL1_STREAM0_STREAM_SECURITY 0x3000
#define DL1_STREAM0_NSAID 0x3004
#define DL1_STREAM0_MMUSID 0x3008
#define DL1_STREAM0_MMUSSID 0x300C
#define DL1_STREAM0_ATTR_CONTROL 0x3010
#define DL1_STREAM0_MEMATTR 0x3014
#define DL1_STREAM0_ADDRESS_EXTEND 0x3018
#define DL1_STREAM1_STREAM_SECURITY 0x4000
#define DL1_STREAM1_NSAID 0x4004
#define DL1_STREAM1_MMUSID 0x4008
#define DL1_STREAM1_MMUSSID 0x400C
#define DL1_STREAM1_ATTR_CONTROL 0x4010
#define DL1_STREAM1_MEMATTR 0x4014
#define DL1_STREAM1_ADDRESS_EXTEND 0x4018
#define DL1_STREAM2_STREAM_SECURITY 0x5000
#define DL1_STREAM2_NSAID 0x5004
#define DL1_STREAM2_MMUSID 0x5008
#define DL1_STREAM2_MMUSSID 0x500C
#define DL1_STREAM2_ATTR_CONTROL 0x5010
#define DL1_STREAM2_MEMATTR 0x5014
#define DL1_STREAM2_ADDRESS_EXTEND 0x5018
#define DL1_STREAM3_STREAM_SECURITY 0x6000
#define DL1_STREAM3_NSAID 0x6004
#define DL1_STREAM3_MMUSID 0x6008
#define DL1_STREAM3_MMUSSID 0x600C
#define DL1_STREAM3_ATTR_CONTROL 0x6010
#define DL1_STREAM3_MEMATTR 0x6014
#define DL1_STREAM4_STREAM_SECURITY 0x7000
#define DL1_STREAM4_NSAID 0x7004
#define DL1_STREAM4_MMUSID 0x7008
#define DL1_STREAM4_MMUSSID 0x700C
#define DL1_STREAM4_ATTR_CONTROL 0x7010
#define DL1_STREAM4_MEMATTR 0x7014
#define DL1_STREAM5_STREAM_SECURITY 0x8000
#define DL1_STREAM5_NSAID 0x8004
#define DL1_STREAM5_MMUSID 0x8008
#define DL1_STREAM5_MMUSSID 0x800C
#define DL1_STREAM5_ATTR_CONTROL 0x8010
#define DL1_STREAM5_MEMATTR 0x8014
#define DL1_STREAM6_STREAM_SECURITY 0x9000
#define DL1_STREAM6_NSAID 0x9004
#define DL1_STREAM6_MMUSID 0x9008
#define DL1_STREAM6_MMUSSID 0x900C
#define DL1_STREAM6_ATTR_CONTROL 0x9010
#define DL1_STREAM6_MEMATTR 0x9014
#define DL1_STREAM7_STREAM_SECURITY 0xA000
#define DL1_STREAM7_NSAID 0xA004
#define DL1_STREAM7_MMUSID 0xA008
#define DL1_STREAM7_MMUSSID 0xA00C
#define DL1_STREAM7_ATTR_CONTROL 0xA010
#define DL1_STREAM7_MEMATTR 0xA014
#define DL1_STREAM8_STREAM_SECURITY 0xB000
#define DL1_STREAM8_NSAID 0xB004
#define DL1_STREAM8_MMUSID 0xB008
#define DL1_STREAM8_MMUSSID 0xB00C
#define DL1_STREAM8_ATTR_CONTROL 0xB010
#define DL1_STREAM8_MEMATTR 0xB014
#define DL1_NPU_ID 0xF000
#define DL1_UNIT_COUNT 0xF004
#define DL1_MCE_FEATURES 0xF008
#define DL1_DFC_FEATURES 0xF00C
#define DL1_PLE_FEATURES 0xF010
#define DL1_WD_FEATURES 0xF014
#define DL1_VECTOR_ENGINE_FEATURES 0xF018
#define DL1_ECOID 0xF100
#define DL1_STREAMID_WIDTH 0xF104
#define DL1_REGISTERS_SIZE 0xF108

//
// Register subpage DL2
//
#define DL2_EXT_ACCESS_CONTROL 0x0000
#define DL2_DELEGATION 0x0004
#define DL2_SECCTLR 0x0010
#define DL2_SECMCUCTLR 0x0014
#define DL2_SYSCTLR0 0x0018
#define DL2_SYSCTLR1 0x001C
#define DL2_PWRCTLR 0x0020
#define DL2_AUXCTLR 0x0024
#define DL2_SETIRQ_EXT 0x0030
#define DL2_CLRIRQ_EXT 0x0034
#define DL2_SETIRQ_INT 0x0040
#define DL2_DFC_SLV_ORD 0x0080
#define DL2_DFC_SLV_OWR 0x0084
#define DL2_DFC_MST_ORD 0x0090
#define DL2_DFC_MST_OWR 0x0094
#define DL2_IRQ_STATUS 0x00A0
#define DL2_INT_STATUS 0x00A4
#define DL2_EXT_STATUS 0x00A8
#define DL2_GP0 0x1000
#define DL2_GP1 0x1004
#define DL2_GP2 0x1008
#define DL2_GP3 0x100C
#define DL2_GP4 0x1010
#define DL2_GP5 0x1014
#define DL2_GP6 0x1018
#define DL2_GP7 0x101C
#define DL2_DELEGATION_STREAM_SECURITY 0x2000
#define DL2_DELEGATION_NSAID 0x2004
#define DL2_DELEGATION_MMUSID 0x2008
#define DL2_DELEGATION_MMUSSID 0x200C
#define DL2_DELEGATION_MMUSSIDV 0x2010
#define DL2_DELEGATION_ATTR_CONTROL 0x2014
#define DL2_DELEGATION_MEMATTR 0x2018
#define DL2_DELEGATION_ADDRESS_EXTEND 0x201C
#define DL2_STREAM0_STREAM_SECURITY 0x3000
#define DL2_STREAM0_NSAID 0x3004
#define DL2_STREAM0_MMUSID 0x3008
#define DL2_STREAM0_MMUSSID 0x300C
#define DL2_STREAM0_ATTR_CONTROL 0x3010
#define DL2_STREAM0_MEMATTR 0x3014
#define DL2_STREAM0_ADDRESS_EXTEND 0x3018
#define DL2_STREAM1_STREAM_SECURITY 0x4000
#define DL2_STREAM1_NSAID 0x4004
#define DL2_STREAM1_MMUSID 0x4008
#define DL2_STREAM1_MMUSSID 0x400C
#define DL2_STREAM1_ATTR_CONTROL 0x4010
#define DL2_STREAM1_MEMATTR 0x4014
#define DL2_STREAM1_ADDRESS_EXTEND 0x4018
#define DL2_STREAM2_STREAM_SECURITY 0x5000
#define DL2_STREAM2_NSAID 0x5004
#define DL2_STREAM2_MMUSID 0x5008
#define DL2_STREAM2_MMUSSID 0x500C
#define DL2_STREAM2_ATTR_CONTROL 0x5010
#define DL2_STREAM2_MEMATTR 0x5014
#define DL2_STREAM2_ADDRESS_EXTEND 0x5018
#define DL2_STREAM3_STREAM_SECURITY 0x6000
#define DL2_STREAM3_NSAID 0x6004
#define DL2_STREAM3_MMUSID 0x6008
#define DL2_STREAM3_MMUSSID 0x600C
#define DL2_STREAM3_ATTR_CONTROL 0x6010
#define DL2_STREAM3_MEMATTR 0x6014
#define DL2_STREAM4_STREAM_SECURITY 0x7000
#define DL2_STREAM4_NSAID 0x7004
#define DL2_STREAM4_MMUSID 0x7008
#define DL2_STREAM4_MMUSSID 0x700C
#define DL2_STREAM4_ATTR_CONTROL 0x7010
#define DL2_STREAM4_MEMATTR 0x7014
#define DL2_STREAM5_STREAM_SECURITY 0x8000
#define DL2_STREAM5_NSAID 0x8004
#define DL2_STREAM5_MMUSID 0x8008
#define DL2_STREAM5_MMUSSID 0x800C
#define DL2_STREAM5_ATTR_CONTROL 0x8010
#define DL2_STREAM5_MEMATTR 0x8014
#define DL2_STREAM6_STREAM_SECURITY 0x9000
#define DL2_STREAM6_NSAID 0x9004
#define DL2_STREAM6_MMUSID 0x9008
#define DL2_STREAM6_MMUSSID 0x900C
#define DL2_STREAM6_ATTR_CONTROL 0x9010
#define DL2_STREAM6_MEMATTR 0x9014
#define DL2_STREAM7_STREAM_SECURITY 0xA000
#define DL2_STREAM7_NSAID 0xA004
#define DL2_STREAM7_MMUSID 0xA008
#define DL2_STREAM7_MMUSSID 0xA00C
#define DL2_STREAM7_ATTR_CONTROL 0xA010
#define DL2_STREAM7_MEMATTR 0xA014
#define DL2_STREAM8_STREAM_SECURITY 0xB000
#define DL2_STREAM8_NSAID 0xB004
#define DL2_STREAM8_MMUSID 0xB008
#define DL2_STREAM8_MMUSSID 0xB00C
#define DL2_STREAM8_ATTR_CONTROL 0xB010
#define DL2_STREAM8_MEMATTR 0xB014
#define DL2_NPU_ID 0xF000
#define DL2_UNIT_COUNT 0xF004
#define DL2_MCE_FEATURES 0xF008
#define DL2_DFC_FEATURES 0xF00C
#define DL2_PLE_FEATURES 0xF010
#define DL2_WD_FEATURES 0xF014
#define DL2_VECTOR_ENGINE_FEATURES 0xF018
#define DL2_ECOID 0xF100
#define DL2_STREAMID_WIDTH 0xF104
#define DL2_REGISTERS_SIZE 0xF108

//
// Register subpage DL3
//
#define DL3_EXT_ACCESS_CONTROL 0x0000
#define DL3_DELEGATION 0x0004
#define DL3_SECCTLR 0x0010
#define DL3_SECMCUCTLR 0x0014
#define DL3_SYSCTLR0 0x0018
#define DL3_SYSCTLR1 0x001C
#define DL3_PWRCTLR 0x0020
#define DL3_AUXCTLR 0x0024
#define DL3_SETIRQ_EXT 0x0030
#define DL3_CLRIRQ_EXT 0x0034
#define DL3_SETIRQ_INT 0x0040
#define DL3_DFC_SLV_ORD 0x0080
#define DL3_DFC_SLV_OWR 0x0084
#define DL3_DFC_MST_ORD 0x0090
#define DL3_DFC_MST_OWR 0x0094
#define DL3_IRQ_STATUS 0x00A0
#define DL3_INT_STATUS 0x00A4
#define DL3_EXT_STATUS 0x00A8
#define DL3_GP0 0x1000
#define DL3_GP1 0x1004
#define DL3_GP2 0x1008
#define DL3_GP3 0x100C
#define DL3_GP4 0x1010
#define DL3_GP5 0x1014
#define DL3_GP6 0x1018
#define DL3_GP7 0x101C
#define DL3_DELEGATION_STREAM_SECURITY 0x2000
#define DL3_DELEGATION_NSAID 0x2004
#define DL3_DELEGATION_MMUSID 0x2008
#define DL3_DELEGATION_MMUSSID 0x200C
#define DL3_DELEGATION_MMUSSIDV 0x2010
#define DL3_DELEGATION_ATTR_CONTROL 0x2014
#define DL3_DELEGATION_MEMATTR 0x2018
#define DL3_DELEGATION_ADDRESS_EXTEND 0x201C
#define DL3_STREAM0_STREAM_SECURITY 0x3000
#define DL3_STREAM0_NSAID 0x3004
#define DL3_STREAM0_MMUSID 0x3008
#define DL3_STREAM0_MMUSSID 0x300C
#define DL3_STREAM0_ATTR_CONTROL 0x3010
#define DL3_STREAM0_MEMATTR 0x3014
#define DL3_STREAM0_ADDRESS_EXTEND 0x3018
#define DL3_STREAM1_STREAM_SECURITY 0x4000
#define DL3_STREAM1_NSAID 0x4004
#define DL3_STREAM1_MMUSID 0x4008
#define DL3_STREAM1_MMUSSID 0x400C
#define DL3_STREAM1_ATTR_CONTROL 0x4010
#define DL3_STREAM1_MEMATTR 0x4014
#define DL3_STREAM1_ADDRESS_EXTEND 0x4018
#define DL3_STREAM2_STREAM_SECURITY 0x5000
#define DL3_STREAM2_NSAID 0x5004
#define DL3_STREAM2_MMUSID 0x5008
#define DL3_STREAM2_MMUSSID 0x500C
#define DL3_STREAM2_ATTR_CONTROL 0x5010
#define DL3_STREAM2_MEMATTR 0x5014
#define DL3_STREAM2_ADDRESS_EXTEND 0x5018
#define DL3_STREAM3_STREAM_SECURITY 0x6000
#define DL3_STREAM3_NSAID 0x6004
#define DL3_STREAM3_MMUSID 0x6008
#define DL3_STREAM3_MMUSSID 0x600C
#define DL3_STREAM3_ATTR_CONTROL 0x6010
#define DL3_STREAM3_MEMATTR 0x6014
#define DL3_STREAM4_STREAM_SECURITY 0x7000
#define DL3_STREAM4_NSAID 0x7004
#define DL3_STREAM4_MMUSID 0x7008
#define DL3_STREAM4_MMUSSID 0x700C
#define DL3_STREAM4_ATTR_CONTROL 0x7010
#define DL3_STREAM4_MEMATTR 0x7014
#define DL3_STREAM5_STREAM_SECURITY 0x8000
#define DL3_STREAM5_NSAID 0x8004
#define DL3_STREAM5_MMUSID 0x8008
#define DL3_STREAM5_MMUSSID 0x800C
#define DL3_STREAM5_ATTR_CONTROL 0x8010
#define DL3_STREAM5_MEMATTR 0x8014
#define DL3_STREAM6_STREAM_SECURITY 0x9000
#define DL3_STREAM6_NSAID 0x9004
#define DL3_STREAM6_MMUSID 0x9008
#define DL3_STREAM6_MMUSSID 0x900C
#define DL3_STREAM6_ATTR_CONTROL 0x9010
#define DL3_STREAM6_MEMATTR 0x9014
#define DL3_STREAM7_STREAM_SECURITY 0xA000
#define DL3_STREAM7_NSAID 0xA004
#define DL3_STREAM7_MMUSID 0xA008
#define DL3_STREAM7_MMUSSID 0xA00C
#define DL3_STREAM7_ATTR_CONTROL 0xA010
#define DL3_STREAM7_MEMATTR 0xA014
#define DL3_STREAM8_STREAM_SECURITY 0xB000
#define DL3_STREAM8_NSAID 0xB004
#define DL3_STREAM8_MMUSID 0xB008
#define DL3_STREAM8_MMUSSID 0xB00C
#define DL3_STREAM8_ATTR_CONTROL 0xB010
#define DL3_STREAM8_MEMATTR 0xB014
#define DL3_NPU_ID 0xF000
#define DL3_UNIT_COUNT 0xF004
#define DL3_MCE_FEATURES 0xF008
#define DL3_DFC_FEATURES 0xF00C
#define DL3_PLE_FEATURES 0xF010
#define DL3_WD_FEATURES 0xF014
#define DL3_VECTOR_ENGINE_FEATURES 0xF018
#define DL3_ECOID 0xF100
#define DL3_STREAMID_WIDTH 0xF104
#define DL3_REGISTERS_SIZE 0xF108

//
// Register subpage DMA
//
#define DMA_DRAM_ADDR_L 0x0000
#define DMA_DRAM_ADDR_H 0x0004
#define DMA_DMA_STATUS 0x0008
#define DMA_SRAM_ADDR 0x000C
#define DMA_DMA_EMCS 0x0010
#define DMA_DMA_CHANNELS 0x0014
#define DMA_DMA_RD_CMD 0x0018
#define DMA_DMA_WR_CMD 0x001C
#define DMA_DMA_STRIDE0 0x0020
#define DMA_DMA_STRIDE1 0x0024
#define DMA_DMA_STRIDE2 0x0028
#define DMA_DMA_STRIDE3 0x002C
#define DMA_DMA_SRAM_STRIDE 0x0030
#define DMA_DMA_TOTAL_BYTES 0x0034
#define DMA_DMA_COMP_CONFIG0 0x0038
#define DMA_STASH_ADDRESS_L 0x0040
#define DMA_STASH_ADDRESS_H 0x0044
#define DMA_REGISTERS_SIZE 0x0048

//
// Register subpage GLOBAL
//
#define GLOBAL_STRIPE_BANK_CONFIG 0x0000
#define GLOBAL_STRIPE_BANK_CONTROL 0x0004
#define GLOBAL_BLOCK_BANK_CONFIG 0x0008
#define GLOBAL_BLOCK_BANK_CONTROL 0x000C
#define GLOBAL_PLE_MCEIF_CONFIG 0x0010
#define GLOBAL_TOP_ERR_CAUSE 0x0200
#define GLOBAL_TOP_ERR_ADDRESS 0x0204
#define GLOBAL_REGISTERS_SIZE 0x0208

//
// Register subpage PMU
//
#define PMU_PMCR 0x0000
#define PMU_PMCNTENSET 0x0004
#define PMU_PMCNTENCLR 0x0008
#define PMU_PMOVSSET 0x000C
#define PMU_PMOVSCLR 0x0010
#define PMU_PMINTENSET 0x0014
#define PMU_PMINTENCLR 0x0018
#define PMU_PMCCNTR_LO 0x0020
#define PMU_PMCCNTR_HI 0x0024
#define PMU_PMEVCNTR0 0x0080
#define PMU_PMEVCNTR1 0x0084
#define PMU_PMEVCNTR2 0x0088
#define PMU_PMEVCNTR3 0x008C
#define PMU_PMEVCNTR4 0x0090
#define PMU_PMEVCNTR5 0x0094
#define PMU_PMEVTYPER0 0x0100
#define PMU_PMEVTYPER1 0x0104
#define PMU_PMEVTYPER2 0x0108
#define PMU_PMEVTYPER3 0x010C
#define PMU_PMEVTYPER4 0x0110
#define PMU_PMEVTYPER5 0x0114
#define PMU_REGISTERS_SIZE 0x0118

//
// Register subpage SEC
//
#define SEC_EXT_ACCESS_CONTROL 0x0000
#define SEC_DELEGATION 0x0004
#define SEC_SECCTLR 0x0010
#define SEC_SECMCUCTLR 0x0014
#define SEC_SYSCTLR0 0x0018
#define SEC_SYSCTLR1 0x001C
#define SEC_PWRCTLR 0x0020
#define SEC_AUXCTLR 0x0024
#define SEC_SETIRQ_EXT 0x0030
#define SEC_CLRIRQ_EXT 0x0034
#define SEC_SETIRQ_INT 0x0040
#define SEC_DFC_SLV_ORD 0x0080
#define SEC_DFC_SLV_OWR 0x0084
#define SEC_DFC_MST_ORD 0x0090
#define SEC_DFC_MST_OWR 0x0094
#define SEC_IRQ_STATUS 0x00A0
#define SEC_INT_STATUS 0x00A4
#define SEC_EXT_STATUS 0x00A8
#define SEC_GP0 0x1000
#define SEC_GP1 0x1004
#define SEC_GP2 0x1008
#define SEC_GP3 0x100C
#define SEC_GP4 0x1010
#define SEC_GP5 0x1014
#define SEC_GP6 0x1018
#define SEC_GP7 0x101C
#define SEC_DELEGATION_STREAM_SECURITY 0x2000
#define SEC_DELEGATION_NSAID 0x2004
#define SEC_DELEGATION_MMUSID 0x2008
#define SEC_DELEGATION_MMUSSID 0x200C
#define SEC_DELEGATION_MMUSSIDV 0x2010
#define SEC_DELEGATION_ATTR_CONTROL 0x2014
#define SEC_DELEGATION_MEMATTR 0x2018
#define SEC_DELEGATION_ADDRESS_EXTEND 0x201C
#define SEC_STREAM0_STREAM_SECURITY 0x3000
#define SEC_STREAM0_NSAID 0x3004
#define SEC_STREAM0_MMUSID 0x3008
#define SEC_STREAM0_MMUSSID 0x300C
#define SEC_STREAM0_ATTR_CONTROL 0x3010
#define SEC_STREAM0_MEMATTR 0x3014
#define SEC_STREAM0_ADDRESS_EXTEND 0x3018
#define SEC_STREAM1_STREAM_SECURITY 0x4000
#define SEC_STREAM1_NSAID 0x4004
#define SEC_STREAM1_MMUSID 0x4008
#define SEC_STREAM1_MMUSSID 0x400C
#define SEC_STREAM1_ATTR_CONTROL 0x4010
#define SEC_STREAM1_MEMATTR 0x4014
#define SEC_STREAM1_ADDRESS_EXTEND 0x4018
#define SEC_STREAM2_STREAM_SECURITY 0x5000
#define SEC_STREAM2_NSAID 0x5004
#define SEC_STREAM2_MMUSID 0x5008
#define SEC_STREAM2_MMUSSID 0x500C
#define SEC_STREAM2_ATTR_CONTROL 0x5010
#define SEC_STREAM2_MEMATTR 0x5014
#define SEC_STREAM2_ADDRESS_EXTEND 0x5018
#define SEC_STREAM3_STREAM_SECURITY 0x6000
#define SEC_STREAM3_NSAID 0x6004
#define SEC_STREAM3_MMUSID 0x6008
#define SEC_STREAM3_MMUSSID 0x600C
#define SEC_STREAM3_ATTR_CONTROL 0x6010
#define SEC_STREAM3_MEMATTR 0x6014
#define SEC_STREAM4_STREAM_SECURITY 0x7000
#define SEC_STREAM4_NSAID 0x7004
#define SEC_STREAM4_MMUSID 0x7008
#define SEC_STREAM4_MMUSSID 0x700C
#define SEC_STREAM4_ATTR_CONTROL 0x7010
#define SEC_STREAM4_MEMATTR 0x7014
#define SEC_STREAM5_STREAM_SECURITY 0x8000
#define SEC_STREAM5_NSAID 0x8004
#define SEC_STREAM5_MMUSID 0x8008
#define SEC_STREAM5_MMUSSID 0x800C
#define SEC_STREAM5_ATTR_CONTROL 0x8010
#define SEC_STREAM5_MEMATTR 0x8014
#define SEC_STREAM6_STREAM_SECURITY 0x9000
#define SEC_STREAM6_NSAID 0x9004
#define SEC_STREAM6_MMUSID 0x9008
#define SEC_STREAM6_MMUSSID 0x900C
#define SEC_STREAM6_ATTR_CONTROL 0x9010
#define SEC_STREAM6_MEMATTR 0x9014
#define SEC_STREAM7_STREAM_SECURITY 0xA000
#define SEC_STREAM7_NSAID 0xA004
#define SEC_STREAM7_MMUSID 0xA008
#define SEC_STREAM7_MMUSSID 0xA00C
#define SEC_STREAM7_ATTR_CONTROL 0xA010
#define SEC_STREAM7_MEMATTR 0xA014
#define SEC_STREAM8_STREAM_SECURITY 0xB000
#define SEC_STREAM8_NSAID 0xB004
#define SEC_STREAM8_MMUSID 0xB008
#define SEC_STREAM8_MMUSSID 0xB00C
#define SEC_STREAM8_ATTR_CONTROL 0xB010
#define SEC_STREAM8_MEMATTR 0xB014
#define SEC_NPU_ID 0xF000
#define SEC_UNIT_COUNT 0xF004
#define SEC_MCE_FEATURES 0xF008
#define SEC_DFC_FEATURES 0xF00C
#define SEC_PLE_FEATURES 0xF010
#define SEC_WD_FEATURES 0xF014
#define SEC_VECTOR_ENGINE_FEATURES 0xF018
#define SEC_ECOID 0xF100
#define SEC_STREAMID_WIDTH 0xF104
#define SEC_REGISTERS_SIZE 0xF108

//
// Register subpage TSU
//
#define TSU_STRIPE_BANK_STATUS 0x0008
#define TSU_BLOCK_BANK_STATUS 0x0018
#define TSU_TSU_CONTROL 0x001C
#define TSU_TSU_EVENT 0x0020
#define TSU_TSU_EVENT_MSK 0x0024
#define TSU_TSU_DEBUG_COUNTERS_ENGINE0 0x1000
#define TSU_TSU_DEBUG_COUNTERS_ENGINE1 0x1004
#define TSU_TSU_DEBUG_COUNTERS_ENGINE2 0x1008
#define TSU_TSU_DEBUG_COUNTERS_ENGINE3 0x100C
#define TSU_TSU_DEBUG_COUNTERS_ENGINE4 0x1010
#define TSU_TSU_DEBUG_COUNTERS_ENGINE5 0x1014
#define TSU_TSU_DEBUG_COUNTERS_ENGINE6 0x1018
#define TSU_TSU_DEBUG_COUNTERS_ENGINE7 0x101C
#define TSU_REGISTERS_SIZE 0x1020


#ifdef __cplusplus

// Enum types

enum class bank_status_t
{
    IDLE = 0,
    PENDING = 1,
    ACTIVE = 2,
    RESERVED0 = 3,
};

enum class batch_size_t
{
    BATCH_1 = 0,
    BATCH_2 = 1,
    BATCH_4 = 3,
    BATCH_8 = 7,
    BATCH_16 = 15,
    BATCH_32 = 31,
    BATCH_64 = 63,
};

enum class block_sequence_t
{
    MIDDLE = 0,
    FIRST = 1,
    LAST = 2,
    FIRST_AND_LAST = 3,
};

enum class delegation_t
{
    BLOCKED = 0,
    DELEGATED = 1,
};

enum class dma_format_read_t
{
    NHWC = 0,
    NCHW = 1,
    NHWCB = 2,
    RESERVED0 = 3,
    WEIGHTS = 4,
    BROADCAST = 5,
    FCAF_DEEP = 6,
    FCAF_WIDE = 7,
};

enum class dma_format_write_t
{
    NHWC = 0,
    NCHW = 1,
    NHWCB = 2,
    NHWCB_WEIGHT_STREAMING = 3,
    RESERVED0 = 4,
    RESERVED1 = 5,
    FCAF_DEEP = 6,
    FCAF_WIDE = 7,
};

enum class dma_stream_type_t
{
    STREAM_4 = 0,
    STREAM_5 = 1,
    STREAM_6 = 2,
    STREAM_7 = 3,
    STREAM_8 = 4,
};

enum class event_create_t
{
    IGNORE = 0,
    CREATE = 1,
};

enum class event_mask_t
{
    MASKED = 0,
    ENABLED = 1,
};

enum class event_t
{
    UNTRIGGERED = 0,
    TRIGGERED = 1,
};

enum class filter_mode_t
{
    DEPTHWISE_SEPARABLE = 0,
    RESERVED0 = 1,
    RESERVED1 = 2,
    FILTER_NXM = 3,
    VECTOR_PRODUCT = 4,
    RESERVED2 = 5,
    RESERVED3 = 6,
    RESERVED4 = 7,
};

enum class force_block_bank_t
{
    NONE = 0,
    FORCE_BANK0 = 1,
    FORCE_BANK1 = 2,
    FORCE_BANK2 = 3,
    FORCE_BANK3 = 4,
};

enum class force_stripe_bank_t
{
    NONE = 0,
    FORCE_BANK0 = 1,
    FORCE_BANK1 = 2,
};

enum class horiz_reinterleave_enable_t
{
    DISABLE = 0,
    ENABLE = 1,
};

enum class mac_ramp_t
{
    NO_RAMP = 0,
    EIGHT_CYCLE_RAMP = 1,
    SIXTEEN_CYCLE_RAMP = 2,
    THIRTY_TWO_CYCLE_RAMP = 3,
};

enum class mce_extend_mode_t
{
    ZERO_EXTEND = 0,
    SIGN_EXTEND = 1,
};

enum class mceif_shuffle_pattern_t
{
    FLIPPED_N = 0,
    X_THEN_Y = 1,
    Y_THEN_X = 2,
    RESERVED0 = 3,
    RESERVED1 = 4,
    RESERVED2 = 5,
    RESERVED3 = 6,
    RESERVED4 = 7,
    RESERVED5 = 8,
    RESERVED6 = 9,
    RESERVED7 = 10,
    RESERVED8 = 11,
    RESERVED9 = 12,
    RESERVED10 = 13,
    RESERVED11 = 14,
    RESERVED12 = 15,
};

enum class memory_attributes_t
{
    NORMAL_OUTSHARE_NONCACHE_NONBUFF = 0,
    DEVICE_NONSHARE_NOALLOCATE = 1,
    WRBACK_OUTSHARE_NOALLOCATE = 2,
    WRBACK_NONSHARE_NOALLOCATE = 3,
    WRBACK_OUTSHARE_RDALLOCATE = 6,
    WRBACK_OUTSHARE_WRALLOCATE = 10,
    WRBACK_OUTSHARE_RWALLOCATE = 14,
};

enum class npu_version_status_t
{
    BETA = 0,
    EAC = 1,
    REL = 2,
};

enum class output_ofm_data_type_t
{
    UINT8 = 0,
    INT8 = 1,
    INT16 = 2,
    RESERVED0 = 3,
};

enum class ple_event_status_t
{
    UNTRIGGERED = 0,
    TRIGGERED = 1,
};

enum class pm_engine_event_type_t
{
    CYCLE = 0x011,
    CHAIN = 0x01E,
    MCE_ACTIVE = 0x100,
    MCE_MAC0_ANY_MUL_ACTIVE_OG0 = 0x101,
    MCE_MAC0_ALL_MUL_ACTIVE_OG0 = 0x102,
    MCE_MAC0_ANY_MUL_ACTIVE_OG1 = 0x111,
    MCE_MAC0_ALL_MUL_ACTIVE_OG1 = 0x112,
    MCE_MAC0_ANY_MUL_ACTIVE_OG2 = 0x121,
    MCE_MAC0_ALL_MUL_ACTIVE_OG2 = 0x122,
    MCE_MAC0_ANY_MUL_ACTIVE_OG3 = 0x131,
    MCE_MAC0_ALL_MUL_ACTIVE_OG3 = 0x132,
    PLE_ACTIVE = 0x180,
};

enum class pm_top_event_type_t
{
    CYCLE = 0x011,
    CHAIN = 0x01E,
    BUS_ACCESS_RD_TRANSFERS = 0x080,
    BUS_RD_COMPLETE_TRANSFERS = 0x081,
    BUS_READ_BEATS = 0x082,
    BUS_READ_TXFR_STALL_CYCLES = 0x083,
    BUS_READ_REORDER_CYCLES = 0x084,
    BUS_ACCESS_WR_TRANSFERS = 0x088,
    BUS_WR_COMPLETE_TRANSFERS = 0x089,
    BUS_WRITE_BEATS = 0x08A,
    BUS_WRITE_TXFR_STALL_CYCLES = 0x08B,
    BUS_WRITE_STALL_CYCLES = 0x08C,
    BUS_ERROR_COUNT = 0x08F,
    NCU_MCU_ICACHE_MISS = 0x090,
    NCU_MCU_DCACHE_MISS = 0x091,
    NCU_MCU_BUS_READ_BEATS = 0x092,
    NCU_MCU_BUS_WRITE_BEATS = 0x093,
    BUS_READ_STREAM_LATENCY_ANY = 0x0A0,
    BUS_READ_STREAM_LATENCY_128 = 0x0A1,
    BUS_READ_STREAM_LATENCY_256 = 0x0A2,
    BUS_READ_STREAM_LATENCY_512 = 0x0A3,
    BUS_READ_STREAM_LATENCY_1024 = 0x0A4,
    BUS_READ_STREAM_LATENCY_2048 = 0x0A5,
    BUS_READ_STREAM_LATENCY_4096 = 0x0A6,
    BUS_READ_STREAM_LATENCY_8192 = 0x0A7,
    BUS_WRITE_STREAM_LATENCY_ANY = 0x0A8,
    BUS_WRITE_STREAM_LATENCY_128 = 0x0A9,
    BUS_WRITE_STREAM_LATENCY_256 = 0x0AA,
    BUS_WRITE_STREAM_LATENCY_512 = 0x0AB,
    BUS_WRITE_STREAM_LATENCY_1024 = 0x0AC,
    BUS_WRITE_STREAM_LATENCY_2048 = 0x0AD,
    BUS_WRITE_STREAM_LATENCY_4096 = 0x0AE,
    BUS_WRITE_STREAM_LATENCY_8192 = 0x0AF,
    RAMP_CYCLE_COUNT = 0x0C0,
};

enum class signed_ifm_mode_t
{
    DISABLE = 0,
    ENABLE = 1,
};

enum class soft_reset_t
{
    NO_RESET_REQUEST = 0,
    DRAIN_DFC_ALLOW_AXI = 1,
    RESERVED = 2,
    DRAIN_DFC_BLOCK_AXI = 3,
};

enum class stream_type_t
{
    STREAM_0 = 0,
    STREAM_1 = 1,
    STREAM_2 = 2,
    STREAM_3 = 3,
    STREAM_4 = 4,
    STREAM_5 = 5,
    STREAM_6 = 6,
    STREAM_7 = 7,
    STREAM_8 = 8,
};

enum class streamid_delegation_t
{
    ID_NOT_DELEGATED = 0,
    ID_BOTTOM_3BITS_DELEGATED = 1,
    ID_BOTTOM_8BITS_DELEGATED = 2,
    ID_FULLY_DELEGATED = 3,
};

enum class subkernel_filter_size_t
{
    FILTER_3X3 = 0,
    FILTER_1X3 = 1,
    FILTER_3X1 = 2,
};

enum class substreamid_delegation_t
{
    ID_NOT_DELEGATED = 0,
    ID_BOTTOM_3BITS_DELEGATED = 1,
    ID_BOTTOM_8BITS_DELEGATED = 2,
    ID_FULLY_DELEGATED = 3,
};

enum class udma_emc_choice_t
{
    EMC_0 = 0,
    EMC_1 = 1,
    EMC_2 = 2,
    EMC_3 = 3,
};

enum class udma_ple_choice_t
{
    MCU_MEM = 0,
    INPUT_0 = 1,
    INPUT_1 = 2,
    INPUT_2 = 3,
    INPUT_3 = 4,
    OUTPUT = 9,
};

enum class vert_reinterleave_enable_t
{
    DISABLE = 0,
    ENABLE = 1,
};

enum class wdiv_t
{
    WDIV0 = 0,
    WDIV1 = 1,
    WDIV2 = 2,
    WDIV3 = 3,
    WDIV4 = 4,
    WDIV5 = 5,
    RESERVED0 = 6,
    UNCOMPRESSED = 7,
};

enum class wide_mul_mode_t
{
    WEIGHT_8_IFM_8 = 0,
    WEIGHT_8_IFM_16 = 1,
    WEIGHT_16_IFM_8 = 2,
    WEIGHT_16_IFM_16 = 3,
};

enum class wide_mul_pass_t
{
    WEIGHT_LO_IFM_LO = 0,
    WEIGHT_LO_IFM_HI = 1,
    WEIGHT_HI_IFM_LO = 2,
    WEIGHT_HI_IFM_HI = 3,
};

enum class wide_subkernel_status_t
{
    FIRST = 0,
    MIDDLE = 1,
    LAST = 2,
};

enum class wit_broadcast_mode_t
{
    ALL = 0,
    LOCAL = 1,
};

enum class wit_resampling_mode_t
{
    NONE = 0,
    NEAREST_NEIGHBOR = 1,
    TRANSPOSE = 2,
    BILINEAR = 3,
};

enum class wit_upscale_odd_height_enable_t
{
    DISABLE = 0,
    ENABLE = 1,
};

enum class wit_upscale_odd_width_enable_t
{
    DISABLE = 0,
    ENABLE = 1,
};

enum class zdiv_t
{
    ZDIV0 = 0,
    ZDIV1 = 1,
    ZDIV2 = 2,
    ZDIV3 = 3,
    RESERVED0 = 4,
    RESERVED1 = 5,
    RESERVED2 = 6,
    RLE_DISABLED = 7,
};


#endif

//
// ce_enables_r - Enable units in the CE
//
struct ce_enables_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t ce_enable : 1; // Enable compute engine
            uint32_t mce_enable : 1; // Enable MCE
            uint32_t mac_enable : 8; // Enable per MAC unit in the CE
            uint32_t reserved0 : 22;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ce_enables_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_ce_enable() const { uint32_t value = static_cast<uint32_t>(bits.ce_enable); return value;}
    CONSTEXPR void set_ce_enable(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ce_enable = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mce_enable() const { uint32_t value = static_cast<uint32_t>(bits.mce_enable); return value;}
    CONSTEXPR void set_mce_enable(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mce_enable = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mac_enable() const { uint32_t value = static_cast<uint32_t>(bits.mac_enable); return value;}
    CONSTEXPR void set_mac_enable(uint32_t value) { assert(static_cast<uint32_t>(value) < 256u); bits.mac_enable = static_cast<uint32_t>(value); }
#endif
};


//
// ce_status_r - CE Status
//
struct ce_status_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t buffer_freed : 1; // MCEIF buffer has been freed
            uint32_t block_done : 1; // PLE has completed processing of a block
            uint32_t stripe_done : 1; // PLE has completed processing of a stripe
            uint32_t layer_done : 1; // PLE has completed processing of a layer
            uint32_t reserved0 : 16;
            uint32_t mcu_txev : 1; // The PLE executed a send event instruction
            uint32_t reserved1 : 1;
            uint32_t udma_done : 1; // The uDMA transaction is done
            uint32_t clear_done : 1; // Memory clear complete, triggered from CE_INST
            uint32_t pmu_overflow : 1; // The PMU has signaled that a counter overflow has occurred
            uint32_t reserved2 : 7;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ce_status_r(uint32_t init=0) : word(init) {}
    CONSTEXPR event_t get_buffer_freed() const { event_t value = static_cast<event_t>(bits.buffer_freed); return value;}
    CONSTEXPR void set_buffer_freed(event_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.buffer_freed = static_cast<uint32_t>(value); }
    CONSTEXPR event_t get_block_done() const { event_t value = static_cast<event_t>(bits.block_done); return value;}
    CONSTEXPR void set_block_done(event_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.block_done = static_cast<uint32_t>(value); }
    CONSTEXPR event_t get_stripe_done() const { event_t value = static_cast<event_t>(bits.stripe_done); return value;}
    CONSTEXPR void set_stripe_done(event_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.stripe_done = static_cast<uint32_t>(value); }
    CONSTEXPR event_t get_layer_done() const { event_t value = static_cast<event_t>(bits.layer_done); return value;}
    CONSTEXPR void set_layer_done(event_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.layer_done = static_cast<uint32_t>(value); }
    CONSTEXPR event_t get_mcu_txev() const { event_t value = static_cast<event_t>(bits.mcu_txev); return value;}
    CONSTEXPR void set_mcu_txev(event_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mcu_txev = static_cast<uint32_t>(value); }
    CONSTEXPR event_t get_udma_done() const { event_t value = static_cast<event_t>(bits.udma_done); return value;}
    CONSTEXPR void set_udma_done(event_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.udma_done = static_cast<uint32_t>(value); }
    CONSTEXPR event_t get_clear_done() const { event_t value = static_cast<event_t>(bits.clear_done); return value;}
    CONSTEXPR void set_clear_done(event_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.clear_done = static_cast<uint32_t>(value); }
    CONSTEXPR event_t get_pmu_overflow() const { event_t value = static_cast<event_t>(bits.pmu_overflow); return value;}
    CONSTEXPR void set_pmu_overflow(event_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.pmu_overflow = static_cast<uint32_t>(value); }
#endif
};


//
// ce_setirq_r - CE setirq register
//
struct ce_setirq_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t buffer_freed : 1; // Free a MCEIF buffer
            uint32_t block_done : 1; // Create a block done event
            uint32_t stripe_done : 1; // Create a stripe done event
            uint32_t layer_done : 1; // Create a layer done event
            uint32_t reserved0 : 28;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ce_setirq_r(uint32_t init=0) : word(init) {}
    CONSTEXPR event_create_t get_buffer_freed() const { event_create_t value = static_cast<event_create_t>(bits.buffer_freed); return value;}
    CONSTEXPR void set_buffer_freed(event_create_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.buffer_freed = static_cast<uint32_t>(value); }
    CONSTEXPR event_create_t get_block_done() const { event_create_t value = static_cast<event_create_t>(bits.block_done); return value;}
    CONSTEXPR void set_block_done(event_create_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.block_done = static_cast<uint32_t>(value); }
    CONSTEXPR event_create_t get_stripe_done() const { event_create_t value = static_cast<event_create_t>(bits.stripe_done); return value;}
    CONSTEXPR void set_stripe_done(event_create_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.stripe_done = static_cast<uint32_t>(value); }
    CONSTEXPR event_create_t get_layer_done() const { event_create_t value = static_cast<event_create_t>(bits.layer_done); return value;}
    CONSTEXPR void set_layer_done(event_create_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.layer_done = static_cast<uint32_t>(value); }
#endif
};


//
// ce_inst_r - Instructions for CE top level components
//
struct ce_inst_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t sram_clear : 1; // Clear all engine SRAMs
            uint32_t reserved0 : 31;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ce_inst_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_sram_clear() const { uint32_t value = static_cast<uint32_t>(bits.sram_clear); return value;}
    CONSTEXPR void set_sram_clear(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.sram_clear = static_cast<uint32_t>(value); }
#endif
};


//
// ce_id_r - CE id register for PLE software use
//
struct ce_id_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t id : 8; // ID of current CE
            uint32_t reserved0 : 24;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ce_id_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_id() const { uint32_t value = static_cast<uint32_t>(bits.id); return value;}
    CONSTEXPR void set_id(uint32_t value) { assert(static_cast<uint32_t>(value) < 256u); bits.id = static_cast<uint32_t>(value); }
#endif
};


//
// ce_err_cause_r - Engine level error cause
//
struct ce_err_cause_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t engine_ram_correctable_err : 1; // Engine RAM correctable error
            uint32_t engine_ram_uncorrectable_err : 1; // Engine RAM uncorrectable error
            uint32_t reserved0 : 2;
            uint32_t mcu_lockup_err : 1; // MCU lockup error
            uint32_t mcu_instr_err : 1; // MCU instr error
            uint32_t mcu_data_read_err : 1; // MCU data read error
            uint32_t mcu_data_write_err : 1; // MCU data write error
            uint32_t udma_load_err : 1; // UDMA load error
            uint32_t udma_store_err : 1; // UDMA store error
            uint32_t reserved1 : 2;
            uint32_t mcu_illegal_coproc_err : 1; // MCU Illegal coprocessor  error
            uint32_t udma_collision_err : 1; // UDMA collision error
            uint32_t rf_rd_collision_err : 1; // Register file read collision error
            uint32_t rf_wr_collision_err : 1; // Register file write collision error
            uint32_t ve_div_0_err : 1; // Vector engine divide by 0 error
            uint32_t ple_lane_err : 1; // Coprocessor instruction not legal with current value of PLE lane select register
            uint32_t reserved2 : 14;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ce_err_cause_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_engine_ram_correctable_err() const { uint32_t value = static_cast<uint32_t>(bits.engine_ram_correctable_err); return value;}
    CONSTEXPR void set_engine_ram_correctable_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.engine_ram_correctable_err = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_engine_ram_uncorrectable_err() const { uint32_t value = static_cast<uint32_t>(bits.engine_ram_uncorrectable_err); return value;}
    CONSTEXPR void set_engine_ram_uncorrectable_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.engine_ram_uncorrectable_err = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mcu_lockup_err() const { uint32_t value = static_cast<uint32_t>(bits.mcu_lockup_err); return value;}
    CONSTEXPR void set_mcu_lockup_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mcu_lockup_err = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mcu_instr_err() const { uint32_t value = static_cast<uint32_t>(bits.mcu_instr_err); return value;}
    CONSTEXPR void set_mcu_instr_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mcu_instr_err = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mcu_data_read_err() const { uint32_t value = static_cast<uint32_t>(bits.mcu_data_read_err); return value;}
    CONSTEXPR void set_mcu_data_read_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mcu_data_read_err = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mcu_data_write_err() const { uint32_t value = static_cast<uint32_t>(bits.mcu_data_write_err); return value;}
    CONSTEXPR void set_mcu_data_write_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mcu_data_write_err = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_udma_load_err() const { uint32_t value = static_cast<uint32_t>(bits.udma_load_err); return value;}
    CONSTEXPR void set_udma_load_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.udma_load_err = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_udma_store_err() const { uint32_t value = static_cast<uint32_t>(bits.udma_store_err); return value;}
    CONSTEXPR void set_udma_store_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.udma_store_err = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mcu_illegal_coproc_err() const { uint32_t value = static_cast<uint32_t>(bits.mcu_illegal_coproc_err); return value;}
    CONSTEXPR void set_mcu_illegal_coproc_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mcu_illegal_coproc_err = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_udma_collision_err() const { uint32_t value = static_cast<uint32_t>(bits.udma_collision_err); return value;}
    CONSTEXPR void set_udma_collision_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.udma_collision_err = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_rf_rd_collision_err() const { uint32_t value = static_cast<uint32_t>(bits.rf_rd_collision_err); return value;}
    CONSTEXPR void set_rf_rd_collision_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.rf_rd_collision_err = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_rf_wr_collision_err() const { uint32_t value = static_cast<uint32_t>(bits.rf_wr_collision_err); return value;}
    CONSTEXPR void set_rf_wr_collision_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.rf_wr_collision_err = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ve_div_0_err() const { uint32_t value = static_cast<uint32_t>(bits.ve_div_0_err); return value;}
    CONSTEXPR void set_ve_div_0_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ve_div_0_err = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ple_lane_err() const { uint32_t value = static_cast<uint32_t>(bits.ple_lane_err); return value;}
    CONSTEXPR void set_ple_lane_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ple_lane_err = static_cast<uint32_t>(value); }
#endif
};


//
// ce_err_address_r - Engine level error address
//
struct ce_err_address_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t address : 12; // Error address; granularity dependent on indicated RAM
            uint32_t bank : 3; // Error bank
            uint32_t reserved0 : 1;
            uint32_t dfc_emc0 : 1; // DFC EMC0 RAM error
            uint32_t dfc_emc1 : 1; // DFC EMC1 RAM error
            uint32_t dfc_emc2 : 1; // DFC EMC2 RAM error
            uint32_t dfc_emc3 : 1; // DFC EMC3 RAM error
            uint32_t mce_ofm0 : 1; // MCE OFM0 RAM error
            uint32_t mce_ofm1 : 1; // MCE OFM1 RAM error
            uint32_t mce_ofm2 : 1; // MCE OFM2 RAM error
            uint32_t mce_ofm3 : 1; // MCE OFM3 RAM error
            uint32_t ple_input0 : 1; // PLE input0 RAM error
            uint32_t ple_input1 : 1; // PLE input1 RAM error
            uint32_t ple_input2 : 1; // PLE input2 RAM error
            uint32_t ple_input3 : 1; // PLE input3 RAM error
            uint32_t ple_output : 1; // PLE output RAM error
            uint32_t ple_mcu : 1; // PLE MCU RAM error
            uint32_t err_multi : 1; // Multiple errors seen
            uint32_t err_uncorrected : 1; // Uncorrected error seen
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ce_err_address_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_address() const { uint32_t value = static_cast<uint32_t>(bits.address); return value;}
    CONSTEXPR void set_address(uint32_t value) { assert(static_cast<uint32_t>(value) < 4096u); bits.address = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_bank() const { uint32_t value = static_cast<uint32_t>(bits.bank); return value;}
    CONSTEXPR void set_bank(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.bank = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_dfc_emc0() const { uint32_t value = static_cast<uint32_t>(bits.dfc_emc0); return value;}
    CONSTEXPR void set_dfc_emc0(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.dfc_emc0 = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_dfc_emc1() const { uint32_t value = static_cast<uint32_t>(bits.dfc_emc1); return value;}
    CONSTEXPR void set_dfc_emc1(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.dfc_emc1 = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_dfc_emc2() const { uint32_t value = static_cast<uint32_t>(bits.dfc_emc2); return value;}
    CONSTEXPR void set_dfc_emc2(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.dfc_emc2 = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_dfc_emc3() const { uint32_t value = static_cast<uint32_t>(bits.dfc_emc3); return value;}
    CONSTEXPR void set_dfc_emc3(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.dfc_emc3 = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mce_ofm0() const { uint32_t value = static_cast<uint32_t>(bits.mce_ofm0); return value;}
    CONSTEXPR void set_mce_ofm0(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mce_ofm0 = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mce_ofm1() const { uint32_t value = static_cast<uint32_t>(bits.mce_ofm1); return value;}
    CONSTEXPR void set_mce_ofm1(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mce_ofm1 = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mce_ofm2() const { uint32_t value = static_cast<uint32_t>(bits.mce_ofm2); return value;}
    CONSTEXPR void set_mce_ofm2(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mce_ofm2 = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mce_ofm3() const { uint32_t value = static_cast<uint32_t>(bits.mce_ofm3); return value;}
    CONSTEXPR void set_mce_ofm3(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mce_ofm3 = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ple_input0() const { uint32_t value = static_cast<uint32_t>(bits.ple_input0); return value;}
    CONSTEXPR void set_ple_input0(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ple_input0 = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ple_input1() const { uint32_t value = static_cast<uint32_t>(bits.ple_input1); return value;}
    CONSTEXPR void set_ple_input1(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ple_input1 = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ple_input2() const { uint32_t value = static_cast<uint32_t>(bits.ple_input2); return value;}
    CONSTEXPR void set_ple_input2(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ple_input2 = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ple_input3() const { uint32_t value = static_cast<uint32_t>(bits.ple_input3); return value;}
    CONSTEXPR void set_ple_input3(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ple_input3 = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ple_output() const { uint32_t value = static_cast<uint32_t>(bits.ple_output); return value;}
    CONSTEXPR void set_ple_output(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ple_output = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ple_mcu() const { uint32_t value = static_cast<uint32_t>(bits.ple_mcu); return value;}
    CONSTEXPR void set_ple_mcu(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ple_mcu = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_err_multi() const { uint32_t value = static_cast<uint32_t>(bits.err_multi); return value;}
    CONSTEXPR void set_err_multi(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.err_multi = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_err_uncorrected() const { uint32_t value = static_cast<uint32_t>(bits.err_uncorrected); return value;}
    CONSTEXPR void set_err_uncorrected(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.err_uncorrected = static_cast<uint32_t>(value); }
#endif
};


//
// ple_control_0_r - PLE controls
//
struct ple_control_0_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t cpuwait : 1; // MCU CPUWAIT input
            uint32_t lockup : 1; // MCU LOCKUP output
            uint32_t halted : 1; // MCU HALTED output
            uint32_t rstreq : 1; // MCU SYSRESETREQ output
            uint32_t sleeping : 1; // MCU SLEEPING output
            uint32_t reserved0 : 27;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ple_control_0_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_cpuwait() const { uint32_t value = static_cast<uint32_t>(bits.cpuwait); return value;}
    CONSTEXPR void set_cpuwait(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.cpuwait = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_lockup() const { uint32_t value = static_cast<uint32_t>(bits.lockup); return value;}
    CONSTEXPR void set_lockup(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.lockup = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_halted() const { uint32_t value = static_cast<uint32_t>(bits.halted); return value;}
    CONSTEXPR void set_halted(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.halted = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_rstreq() const { uint32_t value = static_cast<uint32_t>(bits.rstreq); return value;}
    CONSTEXPR void set_rstreq(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.rstreq = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_sleeping() const { uint32_t value = static_cast<uint32_t>(bits.sleeping); return value;}
    CONSTEXPR void set_sleeping(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.sleeping = static_cast<uint32_t>(value); }
#endif
};


//
// ple_control_1_r - PLE controls
//
struct ple_control_1_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t reserved0 : 4;
            uint32_t mcu_setevent : 1; // Mask for setirq event
            uint32_t mcu_setirq : 1; // Mask for setirq interrupt
            uint32_t mcu_gpevent : 1; // Mask for GP register event
            uint32_t reserved1 : 1;
            uint32_t mceif_event : 1; // Mask for MCEIF signal event
            uint32_t mceif_irq : 1; // Mask for MCEIF signal interrupt
            uint32_t reserved2 : 6;
            uint32_t txev_ncu : 1; // Mask for TXEV signals
            uint32_t reserved3 : 3;
            uint32_t rxev_event : 1; // Mask for TXEV events
            uint32_t rxev_irq : 1; // Mask for TXEV generated interrupt
            uint32_t udma_event : 1; // Mask for UDMA events
            uint32_t udma_irq : 1; // Mask for UDMA interrupts
            uint32_t pmu_event : 1; // Mask for PMU overflow events
            uint32_t pmu_irq : 1; // Mask for PMU overflow interrupts
            uint32_t reserved4 : 1;
            uint32_t pmu_ncu : 1; // Mask for PMU counter overflow
            uint32_t reserved5 : 4;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ple_control_1_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mcu_setevent() const { uint32_t value = static_cast<uint32_t>(bits.mcu_setevent); return value;}
    CONSTEXPR void set_mcu_setevent(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mcu_setevent = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mcu_setirq() const { uint32_t value = static_cast<uint32_t>(bits.mcu_setirq); return value;}
    CONSTEXPR void set_mcu_setirq(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mcu_setirq = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mcu_gpevent() const { uint32_t value = static_cast<uint32_t>(bits.mcu_gpevent); return value;}
    CONSTEXPR void set_mcu_gpevent(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mcu_gpevent = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mceif_event() const { uint32_t value = static_cast<uint32_t>(bits.mceif_event); return value;}
    CONSTEXPR void set_mceif_event(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mceif_event = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mceif_irq() const { uint32_t value = static_cast<uint32_t>(bits.mceif_irq); return value;}
    CONSTEXPR void set_mceif_irq(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mceif_irq = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_txev_ncu() const { uint32_t value = static_cast<uint32_t>(bits.txev_ncu); return value;}
    CONSTEXPR void set_txev_ncu(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.txev_ncu = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_rxev_event() const { uint32_t value = static_cast<uint32_t>(bits.rxev_event); return value;}
    CONSTEXPR void set_rxev_event(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.rxev_event = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_rxev_irq() const { uint32_t value = static_cast<uint32_t>(bits.rxev_irq); return value;}
    CONSTEXPR void set_rxev_irq(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.rxev_irq = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_udma_event() const { uint32_t value = static_cast<uint32_t>(bits.udma_event); return value;}
    CONSTEXPR void set_udma_event(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.udma_event = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_udma_irq() const { uint32_t value = static_cast<uint32_t>(bits.udma_irq); return value;}
    CONSTEXPR void set_udma_irq(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.udma_irq = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_pmu_event() const { uint32_t value = static_cast<uint32_t>(bits.pmu_event); return value;}
    CONSTEXPR void set_pmu_event(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.pmu_event = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_pmu_irq() const { uint32_t value = static_cast<uint32_t>(bits.pmu_irq); return value;}
    CONSTEXPR void set_pmu_irq(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.pmu_irq = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_pmu_ncu() const { uint32_t value = static_cast<uint32_t>(bits.pmu_ncu); return value;}
    CONSTEXPR void set_pmu_ncu(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.pmu_ncu = static_cast<uint32_t>(value); }
#endif
};


//
// ple_status_r - PLE status register
//
struct ple_status_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t reserved0 : 4;
            uint32_t setirq_event : 1; // Event caused by PLE_SETIRQ.event
            uint32_t setirq_interrupt : 1; // Interrupt caused by PLE_SETIRQ.interrupt
            uint32_t gp_event : 1; // Event caused by write to PLE_SCRATCH registers
            uint32_t reserved1 : 1;
            uint32_t mceif_block_done : 1; // MCEIF block done event
            uint32_t reserved2 : 11;
            uint32_t rxev_event : 1; // Event received from NCU MCU sent event
            uint32_t rxev_irq : 1; // Interrupt received from NCU MCU sent interrupt
            uint32_t udma_load_done : 1; // UDMA load done event
            uint32_t udma_store_done : 1; // UDMA store done event
            uint32_t pmu_event : 1; // Event caused by PMU overflow
            uint32_t pmu_overflow : 1; // Interrupt caused by PMU overflow
            uint32_t reserved3 : 6;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ple_status_r(uint32_t init=0) : word(init) {}
    CONSTEXPR ple_event_status_t get_setirq_event() const { ple_event_status_t value = static_cast<ple_event_status_t>(bits.setirq_event); return value;}
    CONSTEXPR void set_setirq_event(ple_event_status_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.setirq_event = static_cast<uint32_t>(value); }
    CONSTEXPR ple_event_status_t get_setirq_interrupt() const { ple_event_status_t value = static_cast<ple_event_status_t>(bits.setirq_interrupt); return value;}
    CONSTEXPR void set_setirq_interrupt(ple_event_status_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.setirq_interrupt = static_cast<uint32_t>(value); }
    CONSTEXPR ple_event_status_t get_gp_event() const { ple_event_status_t value = static_cast<ple_event_status_t>(bits.gp_event); return value;}
    CONSTEXPR void set_gp_event(ple_event_status_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.gp_event = static_cast<uint32_t>(value); }
    CONSTEXPR ple_event_status_t get_mceif_block_done() const { ple_event_status_t value = static_cast<ple_event_status_t>(bits.mceif_block_done); return value;}
    CONSTEXPR void set_mceif_block_done(ple_event_status_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mceif_block_done = static_cast<uint32_t>(value); }
    CONSTEXPR ple_event_status_t get_rxev_event() const { ple_event_status_t value = static_cast<ple_event_status_t>(bits.rxev_event); return value;}
    CONSTEXPR void set_rxev_event(ple_event_status_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.rxev_event = static_cast<uint32_t>(value); }
    CONSTEXPR ple_event_status_t get_rxev_irq() const { ple_event_status_t value = static_cast<ple_event_status_t>(bits.rxev_irq); return value;}
    CONSTEXPR void set_rxev_irq(ple_event_status_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.rxev_irq = static_cast<uint32_t>(value); }
    CONSTEXPR ple_event_status_t get_udma_load_done() const { ple_event_status_t value = static_cast<ple_event_status_t>(bits.udma_load_done); return value;}
    CONSTEXPR void set_udma_load_done(ple_event_status_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.udma_load_done = static_cast<uint32_t>(value); }
    CONSTEXPR ple_event_status_t get_udma_store_done() const { ple_event_status_t value = static_cast<ple_event_status_t>(bits.udma_store_done); return value;}
    CONSTEXPR void set_udma_store_done(ple_event_status_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.udma_store_done = static_cast<uint32_t>(value); }
    CONSTEXPR ple_event_status_t get_pmu_event() const { ple_event_status_t value = static_cast<ple_event_status_t>(bits.pmu_event); return value;}
    CONSTEXPR void set_pmu_event(ple_event_status_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.pmu_event = static_cast<uint32_t>(value); }
    CONSTEXPR ple_event_status_t get_pmu_overflow() const { ple_event_status_t value = static_cast<ple_event_status_t>(bits.pmu_overflow); return value;}
    CONSTEXPR void set_pmu_overflow(ple_event_status_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.pmu_overflow = static_cast<uint32_t>(value); }
#endif
};


//
// ple_setirq_r - Raise PLE interrupts or events
//
struct ple_setirq_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t reserved0 : 4;
            uint32_t event : 1; // PLE raise event
            uint32_t interrupt : 1; // PLE raise irq
            uint32_t reserved1 : 1;
            uint32_t nmi : 1; // PLE raise NMI
            uint32_t reserved2 : 24;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ple_setirq_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_event() const { uint32_t value = static_cast<uint32_t>(bits.event); return value;}
    CONSTEXPR void set_event(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.event = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_interrupt() const { uint32_t value = static_cast<uint32_t>(bits.interrupt); return value;}
    CONSTEXPR void set_interrupt(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.interrupt = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_nmi() const { uint32_t value = static_cast<uint32_t>(bits.nmi); return value;}
    CONSTEXPR void set_nmi(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.nmi = static_cast<uint32_t>(value); }
#endif
};


//
// ple_udma_load_parameters_r - micro-DMA load instruction parameters
//
struct ple_udma_load_parameters_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t length : 8; // Number of 128-bit transfers-1
            uint32_t emc : 3; // EMC involved in transfer
            uint32_t reserved0 : 1;
            uint32_t ple : 4; // PLE memory involved in transfer
            uint32_t reserved1 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ple_udma_load_parameters_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_length() const { uint32_t value = static_cast<uint32_t>(bits.length); return (value + 1);}
    CONSTEXPR void set_length(uint32_t value) { assert(static_cast<uint32_t>((value - 1)) < 256u); bits.length = static_cast<uint32_t>((value - 1)); }
    CONSTEXPR udma_emc_choice_t get_emc() const { udma_emc_choice_t value = static_cast<udma_emc_choice_t>(bits.emc); return value;}
    CONSTEXPR void set_emc(udma_emc_choice_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.emc = static_cast<uint32_t>(value); }
    CONSTEXPR udma_ple_choice_t get_ple() const { udma_ple_choice_t value = static_cast<udma_ple_choice_t>(bits.ple); return value;}
    CONSTEXPR void set_ple(udma_ple_choice_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.ple = static_cast<uint32_t>(value); }
#endif
};


//
// ple_udma_load_command_r - micro-DMA load instruction command
//
struct ple_udma_load_command_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t emc_addr : 15; // 128-bit granularity EMC address
            uint32_t reserved0 : 1;
            uint32_t ple_addr : 9; // 128-bit granularity PLE address
            uint32_t reserved1 : 7;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ple_udma_load_command_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_emc_addr() const { uint32_t value = static_cast<uint32_t>(bits.emc_addr); return (value << 4);}
    CONSTEXPR void set_emc_addr(uint32_t value) { assert(static_cast<uint32_t>((value >> 4)) < 32768u); bits.emc_addr = static_cast<uint32_t>((value >> 4)); }
    CONSTEXPR uint32_t get_ple_addr() const { uint32_t value = static_cast<uint32_t>(bits.ple_addr); return (value << 4);}
    CONSTEXPR void set_ple_addr(uint32_t value) { assert(static_cast<uint32_t>((value >> 4)) < 512u); bits.ple_addr = static_cast<uint32_t>((value >> 4)); }
#endif
};


//
// ple_udma_store_parameters_r - micro-DMA store instruction paramaters
//
struct ple_udma_store_parameters_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t length : 8; // Number of 128-bit transfers-1
            uint32_t emc : 3; // EMC involved in transfer
            uint32_t reserved0 : 1;
            uint32_t ple : 4; // PLE memory involved in transfer
            uint32_t reserved1 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ple_udma_store_parameters_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_length() const { uint32_t value = static_cast<uint32_t>(bits.length); return (value + 1);}
    CONSTEXPR void set_length(uint32_t value) { assert(static_cast<uint32_t>((value - 1)) < 256u); bits.length = static_cast<uint32_t>((value - 1)); }
    CONSTEXPR udma_emc_choice_t get_emc() const { udma_emc_choice_t value = static_cast<udma_emc_choice_t>(bits.emc); return value;}
    CONSTEXPR void set_emc(udma_emc_choice_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.emc = static_cast<uint32_t>(value); }
    CONSTEXPR udma_ple_choice_t get_ple() const { udma_ple_choice_t value = static_cast<udma_ple_choice_t>(bits.ple); return value;}
    CONSTEXPR void set_ple(udma_ple_choice_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.ple = static_cast<uint32_t>(value); }
#endif
};


//
// ple_udma_store_command_r - micro-DMA store instruction command
//
struct ple_udma_store_command_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t emc_addr : 15; // 128-bit granularity EMC address
            uint32_t reserved0 : 1;
            uint32_t ple_addr : 9; // 128-bit granularity PLE address
            uint32_t reserved1 : 7;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ple_udma_store_command_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_emc_addr() const { uint32_t value = static_cast<uint32_t>(bits.emc_addr); return (value << 4);}
    CONSTEXPR void set_emc_addr(uint32_t value) { assert(static_cast<uint32_t>((value >> 4)) < 32768u); bits.emc_addr = static_cast<uint32_t>((value >> 4)); }
    CONSTEXPR uint32_t get_ple_addr() const { uint32_t value = static_cast<uint32_t>(bits.ple_addr); return (value << 4);}
    CONSTEXPR void set_ple_addr(uint32_t value) { assert(static_cast<uint32_t>((value >> 4)) < 512u); bits.ple_addr = static_cast<uint32_t>((value >> 4)); }
#endif
};


//
// ple_counters_r - PLE internal counters for input data tracking
//
struct ple_counters_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t ple_block_done_count : 8; // Count of the block-done signaled by MCE to PLE.
            uint32_t reserved0 : 24;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ple_counters_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_ple_block_done_count() const { uint32_t value = static_cast<uint32_t>(bits.ple_block_done_count); return value;}
    CONSTEXPR void set_ple_block_done_count(uint32_t value) { assert(static_cast<uint32_t>(value) < 256u); bits.ple_block_done_count = static_cast<uint32_t>(value); }
#endif
};


//
// ple_scratch0_r - Scratch register for software use
//
struct ple_scratch0_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t ple_scratch : 32; // Scratch register for PLE_MCU software to use
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ple_scratch0_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_ple_scratch() const { uint32_t value = static_cast<uint32_t>(bits.ple_scratch); return value;}
    CONSTEXPR void set_ple_scratch(uint32_t value) { bits.ple_scratch = static_cast<uint32_t>(value); }
#endif
};


//
// ple_scratch1_r - Scratch register for software use
//
struct ple_scratch1_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t ple_scratch : 32; // Scratch register for PLE_MCU software to use
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ple_scratch1_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_ple_scratch() const { uint32_t value = static_cast<uint32_t>(bits.ple_scratch); return value;}
    CONSTEXPR void set_ple_scratch(uint32_t value) { bits.ple_scratch = static_cast<uint32_t>(value); }
#endif
};


//
// ple_scratch2_r - Scratch register for software use
//
struct ple_scratch2_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t ple_scratch : 32; // Scratch register for PLE_MCU software to use
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ple_scratch2_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_ple_scratch() const { uint32_t value = static_cast<uint32_t>(bits.ple_scratch); return value;}
    CONSTEXPR void set_ple_scratch(uint32_t value) { bits.ple_scratch = static_cast<uint32_t>(value); }
#endif
};


//
// ple_scratch3_r - Scratch register for software use
//
struct ple_scratch3_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t ple_scratch : 32; // Scratch register for PLE_MCU software to use
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ple_scratch3_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_ple_scratch() const { uint32_t value = static_cast<uint32_t>(bits.ple_scratch); return value;}
    CONSTEXPR void set_ple_scratch(uint32_t value) { bits.ple_scratch = static_cast<uint32_t>(value); }
#endif
};


//
// ple_scratch4_r - Scratch register for software use
//
struct ple_scratch4_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t ple_scratch : 32; // Scratch register for PLE_MCU software to use
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ple_scratch4_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_ple_scratch() const { uint32_t value = static_cast<uint32_t>(bits.ple_scratch); return value;}
    CONSTEXPR void set_ple_scratch(uint32_t value) { bits.ple_scratch = static_cast<uint32_t>(value); }
#endif
};


//
// ple_scratch5_r - Scratch register for software use
//
struct ple_scratch5_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t ple_scratch : 32; // Scratch register for PLE_MCU software to use
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ple_scratch5_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_ple_scratch() const { uint32_t value = static_cast<uint32_t>(bits.ple_scratch); return value;}
    CONSTEXPR void set_ple_scratch(uint32_t value) { bits.ple_scratch = static_cast<uint32_t>(value); }
#endif
};


//
// ple_scratch6_r - Scratch register for software use
//
struct ple_scratch6_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t ple_scratch : 32; // Scratch register for PLE_MCU software to use
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ple_scratch6_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_ple_scratch() const { uint32_t value = static_cast<uint32_t>(bits.ple_scratch); return value;}
    CONSTEXPR void set_ple_scratch(uint32_t value) { bits.ple_scratch = static_cast<uint32_t>(value); }
#endif
};


//
// ple_scratch7_r - Scratch register for software use
//
struct ple_scratch7_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t ple_scratch : 32; // Scratch register for PLE_MCU software to use
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ple_scratch7_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_ple_scratch() const { uint32_t value = static_cast<uint32_t>(bits.ple_scratch); return value;}
    CONSTEXPR void set_ple_scratch(uint32_t value) { bits.ple_scratch = static_cast<uint32_t>(value); }
#endif
};


//
// ple_debug_control_r - Debug control configuration
//
struct ple_debug_control_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t event_suppress : 1; // PMU event suppression
            uint32_t reserved0 : 31;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ple_debug_control_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_event_suppress() const { uint32_t value = static_cast<uint32_t>(bits.event_suppress); return value;}
    CONSTEXPR void set_event_suppress(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.event_suppress = static_cast<uint32_t>(value); }
#endif
};


//
// ofm_block_config_r - OFM block configuration
//
struct ofm_block_config_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t num_active_ofms : 6; // Number of OFMs that are active in current pass through the stripe
            uint32_t mac_acc_out_dis : 1; // Disable sending accumulator values to PLE
            uint32_t wide_mul_pass : 2; // TSU sequencing pass for wider MAC operation
            uint32_t reserved0 : 2;
            uint32_t subkernel_size : 2; // Subkernel size for wide kernel mode
            uint32_t ifm_extend_mode : 1; // Value extend mode for IFMs
            uint32_t reserved1 : 2;
            uint32_t ofm_block_width : 6; // OFM block width in elements
            uint32_t ofm_block_height : 6; // OFM block height in elements
            uint32_t block_sequence : 2; // Indicates if this is the first or last block in a stripe
            uint32_t end_of_ofm : 1; // Indicates this is the last block of an OFM
            uint32_t mac_acc_clr_disable : 1; // Disable clearing of the MAC unit accumulators
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ofm_block_config_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_num_active_ofms() const { uint32_t value = static_cast<uint32_t>(bits.num_active_ofms); return value;}
    CONSTEXPR void set_num_active_ofms(uint32_t value) { assert(static_cast<uint32_t>(value) < 64u); bits.num_active_ofms = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mac_acc_out_dis() const { uint32_t value = static_cast<uint32_t>(bits.mac_acc_out_dis); return value;}
    CONSTEXPR void set_mac_acc_out_dis(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mac_acc_out_dis = static_cast<uint32_t>(value); }
    CONSTEXPR wide_mul_pass_t get_wide_mul_pass() const { wide_mul_pass_t value = static_cast<wide_mul_pass_t>(bits.wide_mul_pass); return value;}
    CONSTEXPR void set_wide_mul_pass(wide_mul_pass_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.wide_mul_pass = static_cast<uint32_t>(value); }
    CONSTEXPR subkernel_filter_size_t get_subkernel_size() const { subkernel_filter_size_t value = static_cast<subkernel_filter_size_t>(bits.subkernel_size); return value;}
    CONSTEXPR void set_subkernel_size(subkernel_filter_size_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.subkernel_size = static_cast<uint32_t>(value); }
    CONSTEXPR mce_extend_mode_t get_ifm_extend_mode() const { mce_extend_mode_t value = static_cast<mce_extend_mode_t>(bits.ifm_extend_mode); return value;}
    CONSTEXPR void set_ifm_extend_mode(mce_extend_mode_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ifm_extend_mode = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ofm_block_width() const { uint32_t value = static_cast<uint32_t>(bits.ofm_block_width); return value;}
    CONSTEXPR void set_ofm_block_width(uint32_t value) { assert(static_cast<uint32_t>(value) < 64u); bits.ofm_block_width = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ofm_block_height() const { uint32_t value = static_cast<uint32_t>(bits.ofm_block_height); return value;}
    CONSTEXPR void set_ofm_block_height(uint32_t value) { assert(static_cast<uint32_t>(value) < 64u); bits.ofm_block_height = static_cast<uint32_t>(value); }
    CONSTEXPR block_sequence_t get_block_sequence() const { block_sequence_t value = static_cast<block_sequence_t>(bits.block_sequence); return value;}
    CONSTEXPR void set_block_sequence(block_sequence_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.block_sequence = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_end_of_ofm() const { uint32_t value = static_cast<uint32_t>(bits.end_of_ofm); return value;}
    CONSTEXPR void set_end_of_ofm(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.end_of_ofm = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mac_acc_clr_disable() const { uint32_t value = static_cast<uint32_t>(bits.mac_acc_clr_disable); return value;}
    CONSTEXPR void set_mac_acc_clr_disable(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mac_acc_clr_disable = static_cast<uint32_t>(value); }
#endif
};


//
// ofm_block_xy_r - Co-ordinates in OFM of the current block's upper left corner element
//
struct ofm_block_xy_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t ofm_block_x : 16; // X co-ordinate of the current OFM block's upper left element
            uint32_t ofm_block_y : 16; // Y co-ordinate of the current OFM block's upper left element
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ofm_block_xy_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_ofm_block_x() const { uint32_t value = static_cast<uint32_t>(bits.ofm_block_x); return value;}
    CONSTEXPR void set_ofm_block_x(uint32_t value) { assert(static_cast<uint32_t>(value) < 65536u); bits.ofm_block_x = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ofm_block_y() const { uint32_t value = static_cast<uint32_t>(bits.ofm_block_y); return value;}
    CONSTEXPR void set_ofm_block_y(uint32_t value) { assert(static_cast<uint32_t>(value) < 65536u); bits.ofm_block_y = static_cast<uint32_t>(value); }
#endif
};


//
// subkernel_offset_r - Offsets for subkernel when doing decomposition
//
struct subkernel_offset_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t subkernel_offset_w : 8; // W offset of current subkernel
            uint32_t subkernel_offset_w_sign : 1; // Sign bit for W offset of current subkernel
            uint32_t subkernel_offset_h : 8; // H offset of current subkernel
            uint32_t subkernel_offset_h_sign : 1; // Sign bit for H offset of current subkernel
            uint32_t subkernel_status : 2; // Subkernel status for the current block
            uint32_t reserved0 : 12;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR subkernel_offset_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_subkernel_offset_w() const { uint32_t value = static_cast<uint32_t>(bits.subkernel_offset_w); return value;}
    CONSTEXPR void set_subkernel_offset_w(uint32_t value) { assert(static_cast<uint32_t>(value) < 256u); bits.subkernel_offset_w = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_subkernel_offset_w_sign() const { uint32_t value = static_cast<uint32_t>(bits.subkernel_offset_w_sign); return value;}
    CONSTEXPR void set_subkernel_offset_w_sign(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.subkernel_offset_w_sign = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_subkernel_offset_h() const { uint32_t value = static_cast<uint32_t>(bits.subkernel_offset_h); return value;}
    CONSTEXPR void set_subkernel_offset_h(uint32_t value) { assert(static_cast<uint32_t>(value) < 256u); bits.subkernel_offset_h = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_subkernel_offset_h_sign() const { uint32_t value = static_cast<uint32_t>(bits.subkernel_offset_h_sign); return value;}
    CONSTEXPR void set_subkernel_offset_h_sign(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.subkernel_offset_h_sign = static_cast<uint32_t>(value); }
    CONSTEXPR wide_subkernel_status_t get_subkernel_status() const { wide_subkernel_status_t value = static_cast<wide_subkernel_status_t>(bits.subkernel_status); return value;}
    CONSTEXPR void set_subkernel_status(wide_subkernel_status_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.subkernel_status = static_cast<uint32_t>(value); }
#endif
};


//
// ce_control_r - CE controls
//
struct ce_control_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t ifm_pad_n_active : 4; // Number of padding controls in use minus 1
            uint32_t wide_mul_mode : 2; // TSU sequencing mode for wider MAC operation
            uint32_t resampling_mode : 2; // Indicates which upscaling mode is used when combining deinterleaved feature maps or when performing deconvolution
            uint32_t horiz_reinterleave_enable : 1; // Enable horizontal reinterleaving
            uint32_t vert_reinterleave_enable : 1; // Enable vertical reinterleaving
            uint32_t upsample_2x_odd_width_enable : 1; // Enable upscaling to odd widths
            uint32_t upsample_2x_odd_height_enable : 1; // Enable upscaling to odd heights
            uint32_t reserved0 : 1;
            uint32_t wit_broadcast_mode : 2; // Indicates which MACs WIT sends IFM data to
            uint32_t signed_ifm_mode : 1; // Enable signed operation for IFM data
            uint32_t winograd_enable : 1; // Enable winograd transform
            uint32_t relu_enable : 1; // Enable ReLU processing
            uint32_t ofm_bypass_enable : 1; // Enable accumulator bypassing of OFM processing
            uint32_t mac_acc_clr_disable : 1; // Disable clearing of the MAC accumulators at the beginning of this stripe
            uint32_t mac_acc_out_dis : 1; // Disable sending accumulator values to PLE
            uint32_t output_ofm_data_type : 2; // Output OFM data type
            uint32_t reserved1 : 9;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ce_control_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_ifm_pad_n_active() const { uint32_t value = static_cast<uint32_t>(bits.ifm_pad_n_active); return (value + 1);}
    CONSTEXPR void set_ifm_pad_n_active(uint32_t value) { assert(static_cast<uint32_t>((value - 1)) < 16u); bits.ifm_pad_n_active = static_cast<uint32_t>((value - 1)); }
    CONSTEXPR wide_mul_mode_t get_wide_mul_mode() const { wide_mul_mode_t value = static_cast<wide_mul_mode_t>(bits.wide_mul_mode); return value;}
    CONSTEXPR void set_wide_mul_mode(wide_mul_mode_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.wide_mul_mode = static_cast<uint32_t>(value); }
    CONSTEXPR wit_resampling_mode_t get_resampling_mode() const { wit_resampling_mode_t value = static_cast<wit_resampling_mode_t>(bits.resampling_mode); return value;}
    CONSTEXPR void set_resampling_mode(wit_resampling_mode_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.resampling_mode = static_cast<uint32_t>(value); }
    CONSTEXPR horiz_reinterleave_enable_t get_horiz_reinterleave_enable() const { horiz_reinterleave_enable_t value = static_cast<horiz_reinterleave_enable_t>(bits.horiz_reinterleave_enable); return value;}
    CONSTEXPR void set_horiz_reinterleave_enable(horiz_reinterleave_enable_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.horiz_reinterleave_enable = static_cast<uint32_t>(value); }
    CONSTEXPR vert_reinterleave_enable_t get_vert_reinterleave_enable() const { vert_reinterleave_enable_t value = static_cast<vert_reinterleave_enable_t>(bits.vert_reinterleave_enable); return value;}
    CONSTEXPR void set_vert_reinterleave_enable(vert_reinterleave_enable_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.vert_reinterleave_enable = static_cast<uint32_t>(value); }
    CONSTEXPR wit_upscale_odd_width_enable_t get_upsample_2x_odd_width_enable() const { wit_upscale_odd_width_enable_t value = static_cast<wit_upscale_odd_width_enable_t>(bits.upsample_2x_odd_width_enable); return value;}
    CONSTEXPR void set_upsample_2x_odd_width_enable(wit_upscale_odd_width_enable_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.upsample_2x_odd_width_enable = static_cast<uint32_t>(value); }
    CONSTEXPR wit_upscale_odd_height_enable_t get_upsample_2x_odd_height_enable() const { wit_upscale_odd_height_enable_t value = static_cast<wit_upscale_odd_height_enable_t>(bits.upsample_2x_odd_height_enable); return value;}
    CONSTEXPR void set_upsample_2x_odd_height_enable(wit_upscale_odd_height_enable_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.upsample_2x_odd_height_enable = static_cast<uint32_t>(value); }
    CONSTEXPR wit_broadcast_mode_t get_wit_broadcast_mode() const { wit_broadcast_mode_t value = static_cast<wit_broadcast_mode_t>(bits.wit_broadcast_mode); return value;}
    CONSTEXPR void set_wit_broadcast_mode(wit_broadcast_mode_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.wit_broadcast_mode = static_cast<uint32_t>(value); }
    CONSTEXPR signed_ifm_mode_t get_signed_ifm_mode() const { signed_ifm_mode_t value = static_cast<signed_ifm_mode_t>(bits.signed_ifm_mode); return value;}
    CONSTEXPR void set_signed_ifm_mode(signed_ifm_mode_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.signed_ifm_mode = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_winograd_enable() const { uint32_t value = static_cast<uint32_t>(bits.winograd_enable); return value;}
    CONSTEXPR void set_winograd_enable(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.winograd_enable = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_relu_enable() const { uint32_t value = static_cast<uint32_t>(bits.relu_enable); return value;}
    CONSTEXPR void set_relu_enable(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.relu_enable = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ofm_bypass_enable() const { uint32_t value = static_cast<uint32_t>(bits.ofm_bypass_enable); return value;}
    CONSTEXPR void set_ofm_bypass_enable(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ofm_bypass_enable = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mac_acc_clr_disable() const { uint32_t value = static_cast<uint32_t>(bits.mac_acc_clr_disable); return value;}
    CONSTEXPR void set_mac_acc_clr_disable(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mac_acc_clr_disable = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mac_acc_out_dis() const { uint32_t value = static_cast<uint32_t>(bits.mac_acc_out_dis); return value;}
    CONSTEXPR void set_mac_acc_out_dis(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mac_acc_out_dis = static_cast<uint32_t>(value); }
    CONSTEXPR output_ofm_data_type_t get_output_ofm_data_type() const { output_ofm_data_type_t value = static_cast<output_ofm_data_type_t>(bits.output_ofm_data_type); return value;}
    CONSTEXPR void set_output_ofm_data_type(output_ofm_data_type_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.output_ofm_data_type = static_cast<uint32_t>(value); }
#endif
};


//
// wide_kernel_control_r - Wide kernel controls
//
struct wide_kernel_control_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t wide_kernel_enable : 1; // Wide kernel enable
            uint32_t wide_filter_width : 8; // Wide kernel width
            uint32_t wide_filter_height : 8; // Wide kernel height
            uint32_t reserved0 : 15;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR wide_kernel_control_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_wide_kernel_enable() const { uint32_t value = static_cast<uint32_t>(bits.wide_kernel_enable); return value;}
    CONSTEXPR void set_wide_kernel_enable(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.wide_kernel_enable = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_wide_filter_width() const { uint32_t value = static_cast<uint32_t>(bits.wide_filter_width); return (value + 1);}
    CONSTEXPR void set_wide_filter_width(uint32_t value) { assert(static_cast<uint32_t>((value - 1)) < 256u); bits.wide_filter_width = static_cast<uint32_t>((value - 1)); }
    CONSTEXPR uint32_t get_wide_filter_height() const { uint32_t value = static_cast<uint32_t>(bits.wide_filter_height); return (value + 1);}
    CONSTEXPR void set_wide_filter_height(uint32_t value) { assert(static_cast<uint32_t>((value - 1)) < 256u); bits.wide_filter_height = static_cast<uint32_t>((value - 1)); }
#endif
};


//
// wide_kernel_offset_r - Wide kernel offsets
//
struct wide_kernel_offset_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t wide_filter_offset_w : 8; // Filter offset width
            uint32_t wide_filter_offset_h : 8; // Filter offset height
            uint32_t wide_delta_width : 8; // Wide delta width
            uint32_t wide_delta_height : 8; // Wide delta height
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR wide_kernel_offset_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_wide_filter_offset_w() const { uint32_t value = static_cast<uint32_t>(bits.wide_filter_offset_w); return value;}
    CONSTEXPR void set_wide_filter_offset_w(uint32_t value) { assert(static_cast<uint32_t>(value) < 256u); bits.wide_filter_offset_w = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_wide_filter_offset_h() const { uint32_t value = static_cast<uint32_t>(bits.wide_filter_offset_h); return value;}
    CONSTEXPR void set_wide_filter_offset_h(uint32_t value) { assert(static_cast<uint32_t>(value) < 256u); bits.wide_filter_offset_h = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_wide_delta_width() const { uint32_t value = static_cast<uint32_t>(bits.wide_delta_width); return value;}
    CONSTEXPR void set_wide_delta_width(uint32_t value) { assert(static_cast<uint32_t>(value) < 256u); bits.wide_delta_width = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_wide_delta_height() const { uint32_t value = static_cast<uint32_t>(bits.wide_delta_height); return value;}
    CONSTEXPR void set_wide_delta_height(uint32_t value) { assert(static_cast<uint32_t>(value) < 256u); bits.wide_delta_height = static_cast<uint32_t>(value); }
#endif
};


//
// ifm_zero_point_r - IFM data zero point
//
struct ifm_zero_point_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t zero_point : 8; // Value to be subtracted from IFM data to produce signed value centered around zero
            uint32_t reserved0 : 24;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_zero_point_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_zero_point() const { uint32_t value = static_cast<uint32_t>(bits.zero_point); return value;}
    CONSTEXPR void set_zero_point(uint32_t value) { assert(static_cast<uint32_t>(value) < 256u); bits.zero_point = static_cast<uint32_t>(value); }
#endif
};


//
// ifm_default_slot_size_r - IFM circular buffer slot size
//
struct ifm_default_slot_size_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t ifm_default_slot_width : 16; // Width (in elements) of the default slot in the SRAM circular buffer for IFM data
            uint32_t ifm_default_slot_height : 16; // Height (in elements) of the default slot in the SRAM circular buffer for IFM data
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_default_slot_size_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_ifm_default_slot_width() const { uint32_t value = static_cast<uint32_t>(bits.ifm_default_slot_width); return value;}
    CONSTEXPR void set_ifm_default_slot_width(uint32_t value) { assert(static_cast<uint32_t>(value) < 65536u); bits.ifm_default_slot_width = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ifm_default_slot_height() const { uint32_t value = static_cast<uint32_t>(bits.ifm_default_slot_height); return value;}
    CONSTEXPR void set_ifm_default_slot_height(uint32_t value) { assert(static_cast<uint32_t>(value) < 65536u); bits.ifm_default_slot_height = static_cast<uint32_t>(value); }
#endif
};


//
// ifm_slot_stride_r - IFM circular buffer slot stride
//
struct ifm_slot_stride_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t ifm_default_slot_stride : 15; // Number of 128-bit words used by a default size slot in the SRAM circular buffer for IFM data
            uint32_t reserved0 : 1;
            uint32_t ifm_boundary_slot_stride : 15; // Number of 128-bit words used by a boundary slot in the SRAM circular buffer for IFM data
            uint32_t reserved1 : 1;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_slot_stride_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_ifm_default_slot_stride() const { uint32_t value = static_cast<uint32_t>(bits.ifm_default_slot_stride); return (value << 4);}
    CONSTEXPR void set_ifm_default_slot_stride(uint32_t value) { assert(static_cast<uint32_t>((value >> 4)) < 32768u); bits.ifm_default_slot_stride = static_cast<uint32_t>((value >> 4)); }
    CONSTEXPR uint32_t get_ifm_boundary_slot_stride() const { uint32_t value = static_cast<uint32_t>(bits.ifm_boundary_slot_stride); return (value << 4);}
    CONSTEXPR void set_ifm_boundary_slot_stride(uint32_t value) { assert(static_cast<uint32_t>((value >> 4)) < 32768u); bits.ifm_boundary_slot_stride = static_cast<uint32_t>((value >> 4)); }
#endif
};


//
// ifm_row_stride_r - IFM row stride values
//
struct ifm_row_stride_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t ifm_default_row_stride : 15; // Row stride for a default size stripe
            uint32_t reserved0 : 1;
            uint32_t ifm_residual_row_stride : 15; // Row stride for a residual size stripe
            uint32_t reserved1 : 1;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_row_stride_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_ifm_default_row_stride() const { uint32_t value = static_cast<uint32_t>(bits.ifm_default_row_stride); return (value << 4);}
    CONSTEXPR void set_ifm_default_row_stride(uint32_t value) { assert(static_cast<uint32_t>((value >> 4)) < 32768u); bits.ifm_default_row_stride = static_cast<uint32_t>((value >> 4)); }
    CONSTEXPR uint32_t get_ifm_residual_row_stride() const { uint32_t value = static_cast<uint32_t>(bits.ifm_residual_row_stride); return (value << 4);}
    CONSTEXPR void set_ifm_residual_row_stride(uint32_t value) { assert(static_cast<uint32_t>((value >> 4)) < 32768u); bits.ifm_residual_row_stride = static_cast<uint32_t>((value >> 4)); }
#endif
};


//
// ifm_config1_r - IFM configuration
//
struct ifm_config1_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t ifm_group_stride : 15; // The stride with which the SRAM address jumps when moving from one 8x8 to the next 8x8 in the X direction in an IFM processed by the current CE (128-bit granularity)
            uint32_t reserved0 : 1;
            uint32_t num_ifm_global : 16; // Number of IFM in current stripe being processed by all CEs
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_config1_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_ifm_group_stride() const { uint32_t value = static_cast<uint32_t>(bits.ifm_group_stride); return (value << 4);}
    CONSTEXPR void set_ifm_group_stride(uint32_t value) { assert(static_cast<uint32_t>((value >> 4)) < 32768u); bits.ifm_group_stride = static_cast<uint32_t>((value >> 4)); }
    CONSTEXPR uint32_t get_num_ifm_global() const { uint32_t value = static_cast<uint32_t>(bits.num_ifm_global); return value;}
    CONSTEXPR void set_num_ifm_global(uint32_t value) { assert(static_cast<uint32_t>(value) < 65536u); bits.num_ifm_global = static_cast<uint32_t>(value); }
#endif
};


//
// ifm_top_slots_r - IFM top slots mapping
//
struct ifm_top_slots_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t top_left_slot : 4; // ID of the top-left neighboring slot
            uint32_t top_left_residual : 1; // The top-left neighboring slot holds data for a residual stripe
            uint32_t reserved0 : 3;
            uint32_t top_center_slot : 4; // ID of the top-center neighboring slot
            uint32_t top_center_residual : 1; // The top-center neighboring slot holds data for a residual stripe
            uint32_t reserved1 : 3;
            uint32_t top_right_slot : 4; // ID of the top-right neighboring slot
            uint32_t top_right_residual : 1; // The top-right neighboring slot holds data for a residual stripe
            uint32_t reserved2 : 11;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_top_slots_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_top_left_slot() const { uint32_t value = static_cast<uint32_t>(bits.top_left_slot); return value;}
    CONSTEXPR void set_top_left_slot(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.top_left_slot = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_top_left_residual() const { uint32_t value = static_cast<uint32_t>(bits.top_left_residual); return value;}
    CONSTEXPR void set_top_left_residual(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.top_left_residual = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_top_center_slot() const { uint32_t value = static_cast<uint32_t>(bits.top_center_slot); return value;}
    CONSTEXPR void set_top_center_slot(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.top_center_slot = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_top_center_residual() const { uint32_t value = static_cast<uint32_t>(bits.top_center_residual); return value;}
    CONSTEXPR void set_top_center_residual(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.top_center_residual = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_top_right_slot() const { uint32_t value = static_cast<uint32_t>(bits.top_right_slot); return value;}
    CONSTEXPR void set_top_right_slot(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.top_right_slot = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_top_right_residual() const { uint32_t value = static_cast<uint32_t>(bits.top_right_residual); return value;}
    CONSTEXPR void set_top_right_residual(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.top_right_residual = static_cast<uint32_t>(value); }
#endif
};


//
// ifm_mid_slots_r - IFM top slots mapping
//
struct ifm_mid_slots_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mid_left_slot : 4; // ID of the mid-left neighboring slot
            uint32_t mid_left_residual : 1; // The mid-left neighboring slot holds data for a residual stripe
            uint32_t reserved0 : 3;
            uint32_t mid_center_slot : 4; // ID of the mid-center neighboring slot
            uint32_t mid_center_residual : 1; // The mid-center neighboring slot holds data for a residual stripe
            uint32_t reserved1 : 3;
            uint32_t mid_right_slot : 4; // ID of the mid-right neighboring slot
            uint32_t mid_right_residual : 1; // The mid-right neighboring slot holds data for a residual stripe
            uint32_t reserved2 : 11;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_mid_slots_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mid_left_slot() const { uint32_t value = static_cast<uint32_t>(bits.mid_left_slot); return value;}
    CONSTEXPR void set_mid_left_slot(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.mid_left_slot = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mid_left_residual() const { uint32_t value = static_cast<uint32_t>(bits.mid_left_residual); return value;}
    CONSTEXPR void set_mid_left_residual(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mid_left_residual = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mid_center_slot() const { uint32_t value = static_cast<uint32_t>(bits.mid_center_slot); return value;}
    CONSTEXPR void set_mid_center_slot(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.mid_center_slot = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mid_center_residual() const { uint32_t value = static_cast<uint32_t>(bits.mid_center_residual); return value;}
    CONSTEXPR void set_mid_center_residual(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mid_center_residual = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mid_right_slot() const { uint32_t value = static_cast<uint32_t>(bits.mid_right_slot); return value;}
    CONSTEXPR void set_mid_right_slot(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.mid_right_slot = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mid_right_residual() const { uint32_t value = static_cast<uint32_t>(bits.mid_right_residual); return value;}
    CONSTEXPR void set_mid_right_residual(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mid_right_residual = static_cast<uint32_t>(value); }
#endif
};


//
// ifm_bottom_slots_r - IFM top slots mapping
//
struct ifm_bottom_slots_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t bottom_left_slot : 4; // ID of the bottom-left neighboring slot
            uint32_t bottom_left_residual : 1; // The bottom-left neighboring slot holds data for a residual stripe
            uint32_t reserved0 : 3;
            uint32_t bottom_center_slot : 4; // ID of the bottom-center neighboring slot
            uint32_t bottom_center_residual : 1; // The bottom-center neighboring slot holds data for a residual stripe
            uint32_t reserved1 : 3;
            uint32_t bottom_right_slot : 4; // ID of the bottom-right neighboring slot
            uint32_t bottom_right_residual : 1; // The bottom-right neighboring slot holds data for a residual stripe
            uint32_t reserved2 : 11;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_bottom_slots_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_bottom_left_slot() const { uint32_t value = static_cast<uint32_t>(bits.bottom_left_slot); return value;}
    CONSTEXPR void set_bottom_left_slot(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.bottom_left_slot = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_bottom_left_residual() const { uint32_t value = static_cast<uint32_t>(bits.bottom_left_residual); return value;}
    CONSTEXPR void set_bottom_left_residual(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.bottom_left_residual = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_bottom_center_slot() const { uint32_t value = static_cast<uint32_t>(bits.bottom_center_slot); return value;}
    CONSTEXPR void set_bottom_center_slot(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.bottom_center_slot = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_bottom_center_residual() const { uint32_t value = static_cast<uint32_t>(bits.bottom_center_residual); return value;}
    CONSTEXPR void set_bottom_center_residual(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.bottom_center_residual = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_bottom_right_slot() const { uint32_t value = static_cast<uint32_t>(bits.bottom_right_slot); return value;}
    CONSTEXPR void set_bottom_right_slot(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.bottom_right_slot = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_bottom_right_residual() const { uint32_t value = static_cast<uint32_t>(bits.bottom_right_residual); return value;}
    CONSTEXPR void set_bottom_right_residual(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.bottom_right_residual = static_cast<uint32_t>(value); }
#endif
};


//
// ifm_slot_pad_config_r - IFM slot padding configuration
//
struct ifm_slot_pad_config_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t left_data : 1; // Left pad with data from neighboring stripe
            uint32_t right_data : 1; // Right pad with data from neighboring stripe
            uint32_t top_data : 1; // Top pad with data from neighboring stripe
            uint32_t bottom_data : 1; // Bottom pad with data from neighboring stripe
            uint32_t reserved0 : 28;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_slot_pad_config_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_left_data() const { uint32_t value = static_cast<uint32_t>(bits.left_data); return value;}
    CONSTEXPR void set_left_data(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.left_data = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_right_data() const { uint32_t value = static_cast<uint32_t>(bits.right_data); return value;}
    CONSTEXPR void set_right_data(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.right_data = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_top_data() const { uint32_t value = static_cast<uint32_t>(bits.top_data); return value;}
    CONSTEXPR void set_top_data(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.top_data = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_bottom_data() const { uint32_t value = static_cast<uint32_t>(bits.bottom_data); return value;}
    CONSTEXPR void set_bottom_data(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.bottom_data = static_cast<uint32_t>(value); }
#endif
};


//
// depthwise_control_r - Controls for depthwise separable convolutions
//
struct depthwise_control_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t num_ifms_per_ofm : 8; // Number of IFMs to produce an OFM (or group of OFMs if CHANNEL_MULTIPLEIR >1) in the NxM stage
            uint32_t reserved0 : 24;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR depthwise_control_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_num_ifms_per_ofm() const { uint32_t value = static_cast<uint32_t>(bits.num_ifms_per_ofm); return value;}
    CONSTEXPR void set_num_ifms_per_ofm(uint32_t value) { assert(static_cast<uint32_t>(value) < 256u); bits.num_ifms_per_ofm = static_cast<uint32_t>(value); }
#endif
};


//
// ifm_config2_ig0_r - IFM configuration continued
//
struct ifm_config2_ig0_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t num_ifm_local : 16; // Number of IFM in current stripe being processed by current CE
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_config2_ig0_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_num_ifm_local() const { uint32_t value = static_cast<uint32_t>(bits.num_ifm_local); return value;}
    CONSTEXPR void set_num_ifm_local(uint32_t value) { assert(static_cast<uint32_t>(value) < 65536u); bits.num_ifm_local = static_cast<uint32_t>(value); }
#endif
};


//
// ifm_slot_base_address_ig0_r - IFM circular buffer base address
//
struct ifm_slot_base_address_ig0_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t ifm_slot_base_addr : 15; // Base address of the SRAM circular buffer containing the IFM elements. When operating in 16-bit IFM mode, this field contains only the lower bytes of the IFM elements.
            uint32_t reserved0 : 1;
            uint32_t ifm_slot_base_addr_hi : 15; // Base address of the SRAM circular buffer containing the higher bytes of the IFM elements when operating in 16-bit IFM mode.
            uint32_t reserved1 : 1;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_slot_base_address_ig0_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_ifm_slot_base_addr() const { uint32_t value = static_cast<uint32_t>(bits.ifm_slot_base_addr); return (value << 4);}
    CONSTEXPR void set_ifm_slot_base_addr(uint32_t value) { assert(static_cast<uint32_t>((value >> 4)) < 32768u); bits.ifm_slot_base_addr = static_cast<uint32_t>((value >> 4)); }
    CONSTEXPR uint32_t get_ifm_slot_base_addr_hi() const { uint32_t value = static_cast<uint32_t>(bits.ifm_slot_base_addr_hi); return (value << 4);}
    CONSTEXPR void set_ifm_slot_base_addr_hi(uint32_t value) { assert(static_cast<uint32_t>((value >> 4)) < 32768u); bits.ifm_slot_base_addr_hi = static_cast<uint32_t>((value >> 4)); }
#endif
};


//
// ifm_pad0_ig0_r - IFM padding control
//
struct ifm_pad0_ig0_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t left_pad : 3; // Number of elements to pad on the left
            uint32_t top_pad : 3; // Number of elements to pad on the top
            int32_t ifm_stripe_width_delta : 5; // Delta between OFM rightmost element and IFM rightmost element (signed)
            int32_t ifm_stripe_height_delta : 5; // Delta between OFM bottommost element and IFM bottommost element (signed)
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_pad0_ig0_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_left_pad() const { uint32_t value = static_cast<uint32_t>(bits.left_pad); return value;}
    CONSTEXPR void set_left_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.left_pad = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_top_pad() const { uint32_t value = static_cast<uint32_t>(bits.top_pad); return value;}
    CONSTEXPR void set_top_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.top_pad = static_cast<uint32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_width_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_width_delta); return value;}
    CONSTEXPR void set_ifm_stripe_width_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_width_delta = static_cast<int32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_height_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_height_delta); return value;}
    CONSTEXPR void set_ifm_stripe_height_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_height_delta = static_cast<int32_t>(value); }
#endif
};


//
// ifm_pad1_ig0_r - IFM padding control
//
struct ifm_pad1_ig0_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t left_pad : 3; // Number of elements to pad on the left
            uint32_t top_pad : 3; // Number of elements to pad on the top
            int32_t ifm_stripe_width_delta : 5; // Delta between OFM rightmost element and IFM rightmost element (signed)
            int32_t ifm_stripe_height_delta : 5; // Delta between OFM bottommost element and IFM bottommost element (signed)
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_pad1_ig0_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_left_pad() const { uint32_t value = static_cast<uint32_t>(bits.left_pad); return value;}
    CONSTEXPR void set_left_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.left_pad = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_top_pad() const { uint32_t value = static_cast<uint32_t>(bits.top_pad); return value;}
    CONSTEXPR void set_top_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.top_pad = static_cast<uint32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_width_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_width_delta); return value;}
    CONSTEXPR void set_ifm_stripe_width_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_width_delta = static_cast<int32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_height_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_height_delta); return value;}
    CONSTEXPR void set_ifm_stripe_height_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_height_delta = static_cast<int32_t>(value); }
#endif
};


//
// ifm_pad2_ig0_r - IFM padding control
//
struct ifm_pad2_ig0_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t left_pad : 3; // Number of elements to pad on the left
            uint32_t top_pad : 3; // Number of elements to pad on the top
            int32_t ifm_stripe_width_delta : 5; // Delta between OFM rightmost element and IFM rightmost element (signed)
            int32_t ifm_stripe_height_delta : 5; // Delta between OFM bottommost element and IFM bottommost element (signed)
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_pad2_ig0_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_left_pad() const { uint32_t value = static_cast<uint32_t>(bits.left_pad); return value;}
    CONSTEXPR void set_left_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.left_pad = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_top_pad() const { uint32_t value = static_cast<uint32_t>(bits.top_pad); return value;}
    CONSTEXPR void set_top_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.top_pad = static_cast<uint32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_width_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_width_delta); return value;}
    CONSTEXPR void set_ifm_stripe_width_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_width_delta = static_cast<int32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_height_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_height_delta); return value;}
    CONSTEXPR void set_ifm_stripe_height_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_height_delta = static_cast<int32_t>(value); }
#endif
};


//
// ifm_pad3_ig0_r - IFM padding control
//
struct ifm_pad3_ig0_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t left_pad : 3; // Number of elements to pad on the left
            uint32_t top_pad : 3; // Number of elements to pad on the top
            int32_t ifm_stripe_width_delta : 5; // Delta between OFM rightmost element and IFM rightmost element (signed)
            int32_t ifm_stripe_height_delta : 5; // Delta between OFM bottommost element and IFM bottommost element (signed)
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_pad3_ig0_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_left_pad() const { uint32_t value = static_cast<uint32_t>(bits.left_pad); return value;}
    CONSTEXPR void set_left_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.left_pad = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_top_pad() const { uint32_t value = static_cast<uint32_t>(bits.top_pad); return value;}
    CONSTEXPR void set_top_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.top_pad = static_cast<uint32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_width_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_width_delta); return value;}
    CONSTEXPR void set_ifm_stripe_width_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_width_delta = static_cast<int32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_height_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_height_delta); return value;}
    CONSTEXPR void set_ifm_stripe_height_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_height_delta = static_cast<int32_t>(value); }
#endif
};


//
// ifm_pad4_ig0_r - IFM padding control
//
struct ifm_pad4_ig0_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t left_pad : 3; // Number of elements to pad on the left
            uint32_t top_pad : 3; // Number of elements to pad on the top
            int32_t ifm_stripe_width_delta : 5; // Delta between OFM rightmost element and IFM rightmost element (signed)
            int32_t ifm_stripe_height_delta : 5; // Delta between OFM bottommost element and IFM bottommost element (signed)
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_pad4_ig0_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_left_pad() const { uint32_t value = static_cast<uint32_t>(bits.left_pad); return value;}
    CONSTEXPR void set_left_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.left_pad = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_top_pad() const { uint32_t value = static_cast<uint32_t>(bits.top_pad); return value;}
    CONSTEXPR void set_top_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.top_pad = static_cast<uint32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_width_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_width_delta); return value;}
    CONSTEXPR void set_ifm_stripe_width_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_width_delta = static_cast<int32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_height_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_height_delta); return value;}
    CONSTEXPR void set_ifm_stripe_height_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_height_delta = static_cast<int32_t>(value); }
#endif
};


//
// ifm_pad5_ig0_r - IFM padding control
//
struct ifm_pad5_ig0_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t left_pad : 3; // Number of elements to pad on the left
            uint32_t top_pad : 3; // Number of elements to pad on the top
            int32_t ifm_stripe_width_delta : 5; // Delta between OFM rightmost element and IFM rightmost element (signed)
            int32_t ifm_stripe_height_delta : 5; // Delta between OFM bottommost element and IFM bottommost element (signed)
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_pad5_ig0_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_left_pad() const { uint32_t value = static_cast<uint32_t>(bits.left_pad); return value;}
    CONSTEXPR void set_left_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.left_pad = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_top_pad() const { uint32_t value = static_cast<uint32_t>(bits.top_pad); return value;}
    CONSTEXPR void set_top_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.top_pad = static_cast<uint32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_width_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_width_delta); return value;}
    CONSTEXPR void set_ifm_stripe_width_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_width_delta = static_cast<int32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_height_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_height_delta); return value;}
    CONSTEXPR void set_ifm_stripe_height_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_height_delta = static_cast<int32_t>(value); }
#endif
};


//
// ifm_pad6_ig0_r - IFM padding control
//
struct ifm_pad6_ig0_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t left_pad : 3; // Number of elements to pad on the left
            uint32_t top_pad : 3; // Number of elements to pad on the top
            int32_t ifm_stripe_width_delta : 5; // Delta between OFM rightmost element and IFM rightmost element (signed)
            int32_t ifm_stripe_height_delta : 5; // Delta between OFM bottommost element and IFM bottommost element (signed)
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_pad6_ig0_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_left_pad() const { uint32_t value = static_cast<uint32_t>(bits.left_pad); return value;}
    CONSTEXPR void set_left_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.left_pad = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_top_pad() const { uint32_t value = static_cast<uint32_t>(bits.top_pad); return value;}
    CONSTEXPR void set_top_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.top_pad = static_cast<uint32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_width_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_width_delta); return value;}
    CONSTEXPR void set_ifm_stripe_width_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_width_delta = static_cast<int32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_height_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_height_delta); return value;}
    CONSTEXPR void set_ifm_stripe_height_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_height_delta = static_cast<int32_t>(value); }
#endif
};


//
// ifm_pad7_ig0_r - IFM padding control
//
struct ifm_pad7_ig0_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t left_pad : 3; // Number of elements to pad on the left
            uint32_t top_pad : 3; // Number of elements to pad on the top
            int32_t ifm_stripe_width_delta : 5; // Delta between OFM rightmost element and IFM rightmost element (signed)
            int32_t ifm_stripe_height_delta : 5; // Delta between OFM bottommost element and IFM bottommost element (signed)
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_pad7_ig0_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_left_pad() const { uint32_t value = static_cast<uint32_t>(bits.left_pad); return value;}
    CONSTEXPR void set_left_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.left_pad = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_top_pad() const { uint32_t value = static_cast<uint32_t>(bits.top_pad); return value;}
    CONSTEXPR void set_top_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.top_pad = static_cast<uint32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_width_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_width_delta); return value;}
    CONSTEXPR void set_ifm_stripe_width_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_width_delta = static_cast<int32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_height_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_height_delta); return value;}
    CONSTEXPR void set_ifm_stripe_height_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_height_delta = static_cast<int32_t>(value); }
#endif
};


//
// ifm_pad8_ig0_r - IFM padding control
//
struct ifm_pad8_ig0_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t left_pad : 3; // Number of elements to pad on the left
            uint32_t top_pad : 3; // Number of elements to pad on the top
            int32_t ifm_stripe_width_delta : 5; // Delta between OFM rightmost element and IFM rightmost element (signed)
            int32_t ifm_stripe_height_delta : 5; // Delta between OFM bottommost element and IFM bottommost element (signed)
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_pad8_ig0_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_left_pad() const { uint32_t value = static_cast<uint32_t>(bits.left_pad); return value;}
    CONSTEXPR void set_left_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.left_pad = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_top_pad() const { uint32_t value = static_cast<uint32_t>(bits.top_pad); return value;}
    CONSTEXPR void set_top_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.top_pad = static_cast<uint32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_width_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_width_delta); return value;}
    CONSTEXPR void set_ifm_stripe_width_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_width_delta = static_cast<int32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_height_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_height_delta); return value;}
    CONSTEXPR void set_ifm_stripe_height_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_height_delta = static_cast<int32_t>(value); }
#endif
};


//
// ifm_pad9_ig0_r - IFM padding control
//
struct ifm_pad9_ig0_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t left_pad : 3; // Number of elements to pad on the left
            uint32_t top_pad : 3; // Number of elements to pad on the top
            int32_t ifm_stripe_width_delta : 5; // Delta between OFM rightmost element and IFM rightmost element (signed)
            int32_t ifm_stripe_height_delta : 5; // Delta between OFM bottommost element and IFM bottommost element (signed)
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_pad9_ig0_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_left_pad() const { uint32_t value = static_cast<uint32_t>(bits.left_pad); return value;}
    CONSTEXPR void set_left_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.left_pad = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_top_pad() const { uint32_t value = static_cast<uint32_t>(bits.top_pad); return value;}
    CONSTEXPR void set_top_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.top_pad = static_cast<uint32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_width_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_width_delta); return value;}
    CONSTEXPR void set_ifm_stripe_width_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_width_delta = static_cast<int32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_height_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_height_delta); return value;}
    CONSTEXPR void set_ifm_stripe_height_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_height_delta = static_cast<int32_t>(value); }
#endif
};


//
// ifm_pad10_ig0_r - IFM padding control
//
struct ifm_pad10_ig0_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t left_pad : 3; // Number of elements to pad on the left
            uint32_t top_pad : 3; // Number of elements to pad on the top
            int32_t ifm_stripe_width_delta : 5; // Delta between OFM rightmost element and IFM rightmost element (signed)
            int32_t ifm_stripe_height_delta : 5; // Delta between OFM bottommost element and IFM bottommost element (signed)
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_pad10_ig0_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_left_pad() const { uint32_t value = static_cast<uint32_t>(bits.left_pad); return value;}
    CONSTEXPR void set_left_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.left_pad = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_top_pad() const { uint32_t value = static_cast<uint32_t>(bits.top_pad); return value;}
    CONSTEXPR void set_top_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.top_pad = static_cast<uint32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_width_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_width_delta); return value;}
    CONSTEXPR void set_ifm_stripe_width_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_width_delta = static_cast<int32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_height_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_height_delta); return value;}
    CONSTEXPR void set_ifm_stripe_height_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_height_delta = static_cast<int32_t>(value); }
#endif
};


//
// ifm_pad11_ig0_r - IFM padding control
//
struct ifm_pad11_ig0_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t left_pad : 3; // Number of elements to pad on the left
            uint32_t top_pad : 3; // Number of elements to pad on the top
            int32_t ifm_stripe_width_delta : 5; // Delta between OFM rightmost element and IFM rightmost element (signed)
            int32_t ifm_stripe_height_delta : 5; // Delta between OFM bottommost element and IFM bottommost element (signed)
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_pad11_ig0_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_left_pad() const { uint32_t value = static_cast<uint32_t>(bits.left_pad); return value;}
    CONSTEXPR void set_left_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.left_pad = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_top_pad() const { uint32_t value = static_cast<uint32_t>(bits.top_pad); return value;}
    CONSTEXPR void set_top_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.top_pad = static_cast<uint32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_width_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_width_delta); return value;}
    CONSTEXPR void set_ifm_stripe_width_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_width_delta = static_cast<int32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_height_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_height_delta); return value;}
    CONSTEXPR void set_ifm_stripe_height_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_height_delta = static_cast<int32_t>(value); }
#endif
};


//
// ifm_pad12_ig0_r - IFM padding control
//
struct ifm_pad12_ig0_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t left_pad : 3; // Number of elements to pad on the left
            uint32_t top_pad : 3; // Number of elements to pad on the top
            int32_t ifm_stripe_width_delta : 5; // Delta between OFM rightmost element and IFM rightmost element (signed)
            int32_t ifm_stripe_height_delta : 5; // Delta between OFM bottommost element and IFM bottommost element (signed)
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_pad12_ig0_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_left_pad() const { uint32_t value = static_cast<uint32_t>(bits.left_pad); return value;}
    CONSTEXPR void set_left_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.left_pad = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_top_pad() const { uint32_t value = static_cast<uint32_t>(bits.top_pad); return value;}
    CONSTEXPR void set_top_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.top_pad = static_cast<uint32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_width_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_width_delta); return value;}
    CONSTEXPR void set_ifm_stripe_width_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_width_delta = static_cast<int32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_height_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_height_delta); return value;}
    CONSTEXPR void set_ifm_stripe_height_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_height_delta = static_cast<int32_t>(value); }
#endif
};


//
// ifm_pad13_ig0_r - IFM padding control
//
struct ifm_pad13_ig0_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t left_pad : 3; // Number of elements to pad on the left
            uint32_t top_pad : 3; // Number of elements to pad on the top
            int32_t ifm_stripe_width_delta : 5; // Delta between OFM rightmost element and IFM rightmost element (signed)
            int32_t ifm_stripe_height_delta : 5; // Delta between OFM bottommost element and IFM bottommost element (signed)
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_pad13_ig0_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_left_pad() const { uint32_t value = static_cast<uint32_t>(bits.left_pad); return value;}
    CONSTEXPR void set_left_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.left_pad = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_top_pad() const { uint32_t value = static_cast<uint32_t>(bits.top_pad); return value;}
    CONSTEXPR void set_top_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.top_pad = static_cast<uint32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_width_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_width_delta); return value;}
    CONSTEXPR void set_ifm_stripe_width_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_width_delta = static_cast<int32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_height_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_height_delta); return value;}
    CONSTEXPR void set_ifm_stripe_height_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_height_delta = static_cast<int32_t>(value); }
#endif
};


//
// ifm_pad14_ig0_r - IFM padding control
//
struct ifm_pad14_ig0_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t left_pad : 3; // Number of elements to pad on the left
            uint32_t top_pad : 3; // Number of elements to pad on the top
            int32_t ifm_stripe_width_delta : 5; // Delta between OFM rightmost element and IFM rightmost element (signed)
            int32_t ifm_stripe_height_delta : 5; // Delta between OFM bottommost element and IFM bottommost element (signed)
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_pad14_ig0_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_left_pad() const { uint32_t value = static_cast<uint32_t>(bits.left_pad); return value;}
    CONSTEXPR void set_left_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.left_pad = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_top_pad() const { uint32_t value = static_cast<uint32_t>(bits.top_pad); return value;}
    CONSTEXPR void set_top_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.top_pad = static_cast<uint32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_width_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_width_delta); return value;}
    CONSTEXPR void set_ifm_stripe_width_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_width_delta = static_cast<int32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_height_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_height_delta); return value;}
    CONSTEXPR void set_ifm_stripe_height_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_height_delta = static_cast<int32_t>(value); }
#endif
};


//
// ifm_pad15_ig0_r - IFM padding control
//
struct ifm_pad15_ig0_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t left_pad : 3; // Number of elements to pad on the left
            uint32_t top_pad : 3; // Number of elements to pad on the top
            int32_t ifm_stripe_width_delta : 5; // Delta between OFM rightmost element and IFM rightmost element (signed)
            int32_t ifm_stripe_height_delta : 5; // Delta between OFM bottommost element and IFM bottommost element (signed)
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_pad15_ig0_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_left_pad() const { uint32_t value = static_cast<uint32_t>(bits.left_pad); return value;}
    CONSTEXPR void set_left_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.left_pad = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_top_pad() const { uint32_t value = static_cast<uint32_t>(bits.top_pad); return value;}
    CONSTEXPR void set_top_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.top_pad = static_cast<uint32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_width_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_width_delta); return value;}
    CONSTEXPR void set_ifm_stripe_width_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_width_delta = static_cast<int32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_height_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_height_delta); return value;}
    CONSTEXPR void set_ifm_stripe_height_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_height_delta = static_cast<int32_t>(value); }
#endif
};


//
// activation_config_r - Activation configuration
//
struct activation_config_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t relu_min : 16; // MIN value to clamp to when RELU is enabled
            uint32_t relu_max : 16; // MAX value to clamp to when RELU is enabled
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR activation_config_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_relu_min() const { uint32_t value = static_cast<uint32_t>(bits.relu_min); return value;}
    CONSTEXPR void set_relu_min(uint32_t value) { assert(static_cast<uint32_t>(value) < 65536u); bits.relu_min = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_relu_max() const { uint32_t value = static_cast<uint32_t>(bits.relu_max); return value;}
    CONSTEXPR void set_relu_max(uint32_t value) { assert(static_cast<uint32_t>(value) < 65536u); bits.relu_max = static_cast<uint32_t>(value); }
#endif
};


//
// stripe_block_config_r - OFM block configuration
//
struct stripe_block_config_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t ofm_default_block_width : 6; // OFM default block width in elements
            uint32_t ofm_default_block_height : 6; // OFM default block height in elements
            uint32_t ofm_bypass_half_patch_output_type : 1; // Output half patch in row or column major order
            uint32_t reserved0 : 11;
            uint32_t mceif_shuffle_pattern : 4; // MCE/PLE interface shuffle pattern
            uint32_t reserved1 : 4;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR stripe_block_config_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_ofm_default_block_width() const { uint32_t value = static_cast<uint32_t>(bits.ofm_default_block_width); return value;}
    CONSTEXPR void set_ofm_default_block_width(uint32_t value) { assert(static_cast<uint32_t>(value) < 64u); bits.ofm_default_block_width = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ofm_default_block_height() const { uint32_t value = static_cast<uint32_t>(bits.ofm_default_block_height); return value;}
    CONSTEXPR void set_ofm_default_block_height(uint32_t value) { assert(static_cast<uint32_t>(value) < 64u); bits.ofm_default_block_height = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ofm_bypass_half_patch_output_type() const { uint32_t value = static_cast<uint32_t>(bits.ofm_bypass_half_patch_output_type); return value;}
    CONSTEXPR void set_ofm_bypass_half_patch_output_type(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ofm_bypass_half_patch_output_type = static_cast<uint32_t>(value); }
    CONSTEXPR mceif_shuffle_pattern_t get_mceif_shuffle_pattern() const { mceif_shuffle_pattern_t value = static_cast<mceif_shuffle_pattern_t>(bits.mceif_shuffle_pattern); return value;}
    CONSTEXPR void set_mceif_shuffle_pattern(mceif_shuffle_pattern_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.mceif_shuffle_pattern = static_cast<uint32_t>(value); }
#endif
};


//
// ofm_stripe_size_r - OFM stripe height/width
//
struct ofm_stripe_size_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t ofm_stripe_width : 16; // OFM stripe width in elements
            uint32_t ofm_stripe_height : 16; // OFM stripe height in elements
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ofm_stripe_size_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_ofm_stripe_width() const { uint32_t value = static_cast<uint32_t>(bits.ofm_stripe_width); return value;}
    CONSTEXPR void set_ofm_stripe_width(uint32_t value) { assert(static_cast<uint32_t>(value) < 65536u); bits.ofm_stripe_width = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ofm_stripe_height() const { uint32_t value = static_cast<uint32_t>(bits.ofm_stripe_height); return value;}
    CONSTEXPR void set_ofm_stripe_height(uint32_t value) { assert(static_cast<uint32_t>(value) < 65536u); bits.ofm_stripe_height = static_cast<uint32_t>(value); }
#endif
};


//
// ofm_config_r - OFM configurations
//
struct ofm_config_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t num_ofm : 16; // Number of OFM in current stripe being processed by all CEs
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ofm_config_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_num_ofm() const { uint32_t value = static_cast<uint32_t>(bits.num_ofm); return value;}
    CONSTEXPR void set_num_ofm(uint32_t value) { assert(static_cast<uint32_t>(value) < 65536u); bits.num_ofm = static_cast<uint32_t>(value); }
#endif
};


//
// vp_control_r - Vector product controls
//
struct vp_control_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t batch_size : 6; // Number of batches minus 1
            uint32_t reserved0 : 26;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR vp_control_r(uint32_t init=0) : word(init) {}
    CONSTEXPR batch_size_t get_batch_size() const { batch_size_t value = static_cast<batch_size_t>(bits.batch_size); return value;}
    CONSTEXPR void set_batch_size(batch_size_t value) { assert(static_cast<uint32_t>(value) < 64u); bits.batch_size = static_cast<uint32_t>(value); }
#endif
};


//
// filter_r - Filter configuration
//
struct filter_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t filter_mode : 3; // Type of filter
            uint32_t filter0_width : 3; // Filter width minus 1 in elements
            uint32_t filter0_height : 3; // Filter height minus 1 in elements
            uint32_t filter1_width : 3; // Filter width minus 1 in elements
            uint32_t filter1_height : 3; // Filter height minus 1 in elements
            uint32_t filter2_width : 3; // Filter width minus 1 in elements
            uint32_t filter2_height : 3; // Filter height minus 1 in elements
            uint32_t filter3_width : 3; // Filter width minus 1 in elements
            uint32_t filter3_height : 3; // Filter height minus 1 in elements
            uint32_t reserved0 : 5;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR filter_r(uint32_t init=0) : word(init) {}
    CONSTEXPR filter_mode_t get_filter_mode() const { filter_mode_t value = static_cast<filter_mode_t>(bits.filter_mode); return value;}
    CONSTEXPR void set_filter_mode(filter_mode_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.filter_mode = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_filter0_width() const { uint32_t value = static_cast<uint32_t>(bits.filter0_width); return (value + 1);}
    CONSTEXPR void set_filter0_width(uint32_t value) { assert(static_cast<uint32_t>((value - 1)) < 8u); bits.filter0_width = static_cast<uint32_t>((value - 1)); }
    CONSTEXPR uint32_t get_filter0_height() const { uint32_t value = static_cast<uint32_t>(bits.filter0_height); return (value + 1);}
    CONSTEXPR void set_filter0_height(uint32_t value) { assert(static_cast<uint32_t>((value - 1)) < 8u); bits.filter0_height = static_cast<uint32_t>((value - 1)); }
    CONSTEXPR uint32_t get_filter1_width() const { uint32_t value = static_cast<uint32_t>(bits.filter1_width); return (value + 1);}
    CONSTEXPR void set_filter1_width(uint32_t value) { assert(static_cast<uint32_t>((value - 1)) < 8u); bits.filter1_width = static_cast<uint32_t>((value - 1)); }
    CONSTEXPR uint32_t get_filter1_height() const { uint32_t value = static_cast<uint32_t>(bits.filter1_height); return (value + 1);}
    CONSTEXPR void set_filter1_height(uint32_t value) { assert(static_cast<uint32_t>((value - 1)) < 8u); bits.filter1_height = static_cast<uint32_t>((value - 1)); }
    CONSTEXPR uint32_t get_filter2_width() const { uint32_t value = static_cast<uint32_t>(bits.filter2_width); return (value + 1);}
    CONSTEXPR void set_filter2_width(uint32_t value) { assert(static_cast<uint32_t>((value - 1)) < 8u); bits.filter2_width = static_cast<uint32_t>((value - 1)); }
    CONSTEXPR uint32_t get_filter2_height() const { uint32_t value = static_cast<uint32_t>(bits.filter2_height); return (value + 1);}
    CONSTEXPR void set_filter2_height(uint32_t value) { assert(static_cast<uint32_t>((value - 1)) < 8u); bits.filter2_height = static_cast<uint32_t>((value - 1)); }
    CONSTEXPR uint32_t get_filter3_width() const { uint32_t value = static_cast<uint32_t>(bits.filter3_width); return (value + 1);}
    CONSTEXPR void set_filter3_width(uint32_t value) { assert(static_cast<uint32_t>((value - 1)) < 8u); bits.filter3_width = static_cast<uint32_t>((value - 1)); }
    CONSTEXPR uint32_t get_filter3_height() const { uint32_t value = static_cast<uint32_t>(bits.filter3_height); return (value + 1);}
    CONSTEXPR void set_filter3_height(uint32_t value) { assert(static_cast<uint32_t>((value - 1)) < 8u); bits.filter3_height = static_cast<uint32_t>((value - 1)); }
#endif
};


//
// mul_enable_og0_r - MAC per multiplier enable
//
struct mul_enable_og0_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mul_enable : 32; // Enable per multiplier in all CEs MAC unit
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR mul_enable_og0_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mul_enable() const { uint32_t value = static_cast<uint32_t>(bits.mul_enable); return value;}
    CONSTEXPR void set_mul_enable(uint32_t value) { bits.mul_enable = static_cast<uint32_t>(value); }
#endif
};


//
// weight_base_addr_og0_r - Weight base address
//
struct weight_base_addr_og0_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t address : 15; // Address into SRAM in terms of 128-bit words
            uint32_t reserved0 : 17;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR weight_base_addr_og0_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_address() const { uint32_t value = static_cast<uint32_t>(bits.address); return (value << 4);}
    CONSTEXPR void set_address(uint32_t value) { assert(static_cast<uint32_t>((value >> 4)) < 32768u); bits.address = static_cast<uint32_t>((value >> 4)); }
#endif
};


//
// ifm_config2_ig1_r - IFM configuration continued
//
struct ifm_config2_ig1_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t num_ifm_local : 16; // Number of IFM in current stripe being processed by current CE
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_config2_ig1_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_num_ifm_local() const { uint32_t value = static_cast<uint32_t>(bits.num_ifm_local); return value;}
    CONSTEXPR void set_num_ifm_local(uint32_t value) { assert(static_cast<uint32_t>(value) < 65536u); bits.num_ifm_local = static_cast<uint32_t>(value); }
#endif
};


//
// ifm_slot_base_address_ig1_r - IFM circular buffer base address
//
struct ifm_slot_base_address_ig1_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t ifm_slot_base_addr : 15; // Base address of the SRAM circular buffer containing the IFM elements. When operating in 16-bit IFM mode, this field contains only the lower bytes of the IFM elements.
            uint32_t reserved0 : 1;
            uint32_t ifm_slot_base_addr_hi : 15; // Base address of the SRAM circular buffer containing the higher bytes of the IFM elements when operating in 16-bit IFM mode.
            uint32_t reserved1 : 1;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_slot_base_address_ig1_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_ifm_slot_base_addr() const { uint32_t value = static_cast<uint32_t>(bits.ifm_slot_base_addr); return (value << 4);}
    CONSTEXPR void set_ifm_slot_base_addr(uint32_t value) { assert(static_cast<uint32_t>((value >> 4)) < 32768u); bits.ifm_slot_base_addr = static_cast<uint32_t>((value >> 4)); }
    CONSTEXPR uint32_t get_ifm_slot_base_addr_hi() const { uint32_t value = static_cast<uint32_t>(bits.ifm_slot_base_addr_hi); return (value << 4);}
    CONSTEXPR void set_ifm_slot_base_addr_hi(uint32_t value) { assert(static_cast<uint32_t>((value >> 4)) < 32768u); bits.ifm_slot_base_addr_hi = static_cast<uint32_t>((value >> 4)); }
#endif
};


//
// ifm_pad0_ig1_r - IFM padding control
//
struct ifm_pad0_ig1_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t left_pad : 3; // Number of elements to pad on the left
            uint32_t top_pad : 3; // Number of elements to pad on the top
            int32_t ifm_stripe_width_delta : 5; // Delta between OFM rightmost element and IFM rightmost element (signed)
            int32_t ifm_stripe_height_delta : 5; // Delta between OFM bottommost element and IFM bottommost element (signed)
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_pad0_ig1_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_left_pad() const { uint32_t value = static_cast<uint32_t>(bits.left_pad); return value;}
    CONSTEXPR void set_left_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.left_pad = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_top_pad() const { uint32_t value = static_cast<uint32_t>(bits.top_pad); return value;}
    CONSTEXPR void set_top_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.top_pad = static_cast<uint32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_width_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_width_delta); return value;}
    CONSTEXPR void set_ifm_stripe_width_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_width_delta = static_cast<int32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_height_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_height_delta); return value;}
    CONSTEXPR void set_ifm_stripe_height_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_height_delta = static_cast<int32_t>(value); }
#endif
};


//
// ifm_pad1_ig1_r - IFM padding control
//
struct ifm_pad1_ig1_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t left_pad : 3; // Number of elements to pad on the left
            uint32_t top_pad : 3; // Number of elements to pad on the top
            int32_t ifm_stripe_width_delta : 5; // Delta between OFM rightmost element and IFM rightmost element (signed)
            int32_t ifm_stripe_height_delta : 5; // Delta between OFM bottommost element and IFM bottommost element (signed)
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_pad1_ig1_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_left_pad() const { uint32_t value = static_cast<uint32_t>(bits.left_pad); return value;}
    CONSTEXPR void set_left_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.left_pad = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_top_pad() const { uint32_t value = static_cast<uint32_t>(bits.top_pad); return value;}
    CONSTEXPR void set_top_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.top_pad = static_cast<uint32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_width_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_width_delta); return value;}
    CONSTEXPR void set_ifm_stripe_width_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_width_delta = static_cast<int32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_height_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_height_delta); return value;}
    CONSTEXPR void set_ifm_stripe_height_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_height_delta = static_cast<int32_t>(value); }
#endif
};


//
// ifm_pad2_ig1_r - IFM padding control
//
struct ifm_pad2_ig1_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t left_pad : 3; // Number of elements to pad on the left
            uint32_t top_pad : 3; // Number of elements to pad on the top
            int32_t ifm_stripe_width_delta : 5; // Delta between OFM rightmost element and IFM rightmost element (signed)
            int32_t ifm_stripe_height_delta : 5; // Delta between OFM bottommost element and IFM bottommost element (signed)
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_pad2_ig1_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_left_pad() const { uint32_t value = static_cast<uint32_t>(bits.left_pad); return value;}
    CONSTEXPR void set_left_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.left_pad = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_top_pad() const { uint32_t value = static_cast<uint32_t>(bits.top_pad); return value;}
    CONSTEXPR void set_top_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.top_pad = static_cast<uint32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_width_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_width_delta); return value;}
    CONSTEXPR void set_ifm_stripe_width_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_width_delta = static_cast<int32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_height_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_height_delta); return value;}
    CONSTEXPR void set_ifm_stripe_height_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_height_delta = static_cast<int32_t>(value); }
#endif
};


//
// ifm_pad3_ig1_r - IFM padding control
//
struct ifm_pad3_ig1_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t left_pad : 3; // Number of elements to pad on the left
            uint32_t top_pad : 3; // Number of elements to pad on the top
            int32_t ifm_stripe_width_delta : 5; // Delta between OFM rightmost element and IFM rightmost element (signed)
            int32_t ifm_stripe_height_delta : 5; // Delta between OFM bottommost element and IFM bottommost element (signed)
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_pad3_ig1_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_left_pad() const { uint32_t value = static_cast<uint32_t>(bits.left_pad); return value;}
    CONSTEXPR void set_left_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.left_pad = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_top_pad() const { uint32_t value = static_cast<uint32_t>(bits.top_pad); return value;}
    CONSTEXPR void set_top_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.top_pad = static_cast<uint32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_width_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_width_delta); return value;}
    CONSTEXPR void set_ifm_stripe_width_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_width_delta = static_cast<int32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_height_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_height_delta); return value;}
    CONSTEXPR void set_ifm_stripe_height_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_height_delta = static_cast<int32_t>(value); }
#endif
};


//
// ifm_pad4_ig1_r - IFM padding control
//
struct ifm_pad4_ig1_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t left_pad : 3; // Number of elements to pad on the left
            uint32_t top_pad : 3; // Number of elements to pad on the top
            int32_t ifm_stripe_width_delta : 5; // Delta between OFM rightmost element and IFM rightmost element (signed)
            int32_t ifm_stripe_height_delta : 5; // Delta between OFM bottommost element and IFM bottommost element (signed)
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_pad4_ig1_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_left_pad() const { uint32_t value = static_cast<uint32_t>(bits.left_pad); return value;}
    CONSTEXPR void set_left_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.left_pad = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_top_pad() const { uint32_t value = static_cast<uint32_t>(bits.top_pad); return value;}
    CONSTEXPR void set_top_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.top_pad = static_cast<uint32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_width_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_width_delta); return value;}
    CONSTEXPR void set_ifm_stripe_width_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_width_delta = static_cast<int32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_height_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_height_delta); return value;}
    CONSTEXPR void set_ifm_stripe_height_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_height_delta = static_cast<int32_t>(value); }
#endif
};


//
// ifm_pad5_ig1_r - IFM padding control
//
struct ifm_pad5_ig1_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t left_pad : 3; // Number of elements to pad on the left
            uint32_t top_pad : 3; // Number of elements to pad on the top
            int32_t ifm_stripe_width_delta : 5; // Delta between OFM rightmost element and IFM rightmost element (signed)
            int32_t ifm_stripe_height_delta : 5; // Delta between OFM bottommost element and IFM bottommost element (signed)
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_pad5_ig1_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_left_pad() const { uint32_t value = static_cast<uint32_t>(bits.left_pad); return value;}
    CONSTEXPR void set_left_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.left_pad = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_top_pad() const { uint32_t value = static_cast<uint32_t>(bits.top_pad); return value;}
    CONSTEXPR void set_top_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.top_pad = static_cast<uint32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_width_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_width_delta); return value;}
    CONSTEXPR void set_ifm_stripe_width_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_width_delta = static_cast<int32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_height_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_height_delta); return value;}
    CONSTEXPR void set_ifm_stripe_height_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_height_delta = static_cast<int32_t>(value); }
#endif
};


//
// ifm_pad6_ig1_r - IFM padding control
//
struct ifm_pad6_ig1_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t left_pad : 3; // Number of elements to pad on the left
            uint32_t top_pad : 3; // Number of elements to pad on the top
            int32_t ifm_stripe_width_delta : 5; // Delta between OFM rightmost element and IFM rightmost element (signed)
            int32_t ifm_stripe_height_delta : 5; // Delta between OFM bottommost element and IFM bottommost element (signed)
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_pad6_ig1_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_left_pad() const { uint32_t value = static_cast<uint32_t>(bits.left_pad); return value;}
    CONSTEXPR void set_left_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.left_pad = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_top_pad() const { uint32_t value = static_cast<uint32_t>(bits.top_pad); return value;}
    CONSTEXPR void set_top_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.top_pad = static_cast<uint32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_width_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_width_delta); return value;}
    CONSTEXPR void set_ifm_stripe_width_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_width_delta = static_cast<int32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_height_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_height_delta); return value;}
    CONSTEXPR void set_ifm_stripe_height_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_height_delta = static_cast<int32_t>(value); }
#endif
};


//
// ifm_pad7_ig1_r - IFM padding control
//
struct ifm_pad7_ig1_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t left_pad : 3; // Number of elements to pad on the left
            uint32_t top_pad : 3; // Number of elements to pad on the top
            int32_t ifm_stripe_width_delta : 5; // Delta between OFM rightmost element and IFM rightmost element (signed)
            int32_t ifm_stripe_height_delta : 5; // Delta between OFM bottommost element and IFM bottommost element (signed)
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_pad7_ig1_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_left_pad() const { uint32_t value = static_cast<uint32_t>(bits.left_pad); return value;}
    CONSTEXPR void set_left_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.left_pad = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_top_pad() const { uint32_t value = static_cast<uint32_t>(bits.top_pad); return value;}
    CONSTEXPR void set_top_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.top_pad = static_cast<uint32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_width_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_width_delta); return value;}
    CONSTEXPR void set_ifm_stripe_width_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_width_delta = static_cast<int32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_height_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_height_delta); return value;}
    CONSTEXPR void set_ifm_stripe_height_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_height_delta = static_cast<int32_t>(value); }
#endif
};


//
// ifm_pad8_ig1_r - IFM padding control
//
struct ifm_pad8_ig1_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t left_pad : 3; // Number of elements to pad on the left
            uint32_t top_pad : 3; // Number of elements to pad on the top
            int32_t ifm_stripe_width_delta : 5; // Delta between OFM rightmost element and IFM rightmost element (signed)
            int32_t ifm_stripe_height_delta : 5; // Delta between OFM bottommost element and IFM bottommost element (signed)
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_pad8_ig1_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_left_pad() const { uint32_t value = static_cast<uint32_t>(bits.left_pad); return value;}
    CONSTEXPR void set_left_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.left_pad = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_top_pad() const { uint32_t value = static_cast<uint32_t>(bits.top_pad); return value;}
    CONSTEXPR void set_top_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.top_pad = static_cast<uint32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_width_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_width_delta); return value;}
    CONSTEXPR void set_ifm_stripe_width_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_width_delta = static_cast<int32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_height_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_height_delta); return value;}
    CONSTEXPR void set_ifm_stripe_height_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_height_delta = static_cast<int32_t>(value); }
#endif
};


//
// ifm_pad9_ig1_r - IFM padding control
//
struct ifm_pad9_ig1_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t left_pad : 3; // Number of elements to pad on the left
            uint32_t top_pad : 3; // Number of elements to pad on the top
            int32_t ifm_stripe_width_delta : 5; // Delta between OFM rightmost element and IFM rightmost element (signed)
            int32_t ifm_stripe_height_delta : 5; // Delta between OFM bottommost element and IFM bottommost element (signed)
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_pad9_ig1_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_left_pad() const { uint32_t value = static_cast<uint32_t>(bits.left_pad); return value;}
    CONSTEXPR void set_left_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.left_pad = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_top_pad() const { uint32_t value = static_cast<uint32_t>(bits.top_pad); return value;}
    CONSTEXPR void set_top_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.top_pad = static_cast<uint32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_width_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_width_delta); return value;}
    CONSTEXPR void set_ifm_stripe_width_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_width_delta = static_cast<int32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_height_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_height_delta); return value;}
    CONSTEXPR void set_ifm_stripe_height_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_height_delta = static_cast<int32_t>(value); }
#endif
};


//
// ifm_pad10_ig1_r - IFM padding control
//
struct ifm_pad10_ig1_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t left_pad : 3; // Number of elements to pad on the left
            uint32_t top_pad : 3; // Number of elements to pad on the top
            int32_t ifm_stripe_width_delta : 5; // Delta between OFM rightmost element and IFM rightmost element (signed)
            int32_t ifm_stripe_height_delta : 5; // Delta between OFM bottommost element and IFM bottommost element (signed)
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_pad10_ig1_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_left_pad() const { uint32_t value = static_cast<uint32_t>(bits.left_pad); return value;}
    CONSTEXPR void set_left_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.left_pad = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_top_pad() const { uint32_t value = static_cast<uint32_t>(bits.top_pad); return value;}
    CONSTEXPR void set_top_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.top_pad = static_cast<uint32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_width_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_width_delta); return value;}
    CONSTEXPR void set_ifm_stripe_width_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_width_delta = static_cast<int32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_height_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_height_delta); return value;}
    CONSTEXPR void set_ifm_stripe_height_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_height_delta = static_cast<int32_t>(value); }
#endif
};


//
// ifm_pad11_ig1_r - IFM padding control
//
struct ifm_pad11_ig1_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t left_pad : 3; // Number of elements to pad on the left
            uint32_t top_pad : 3; // Number of elements to pad on the top
            int32_t ifm_stripe_width_delta : 5; // Delta between OFM rightmost element and IFM rightmost element (signed)
            int32_t ifm_stripe_height_delta : 5; // Delta between OFM bottommost element and IFM bottommost element (signed)
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_pad11_ig1_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_left_pad() const { uint32_t value = static_cast<uint32_t>(bits.left_pad); return value;}
    CONSTEXPR void set_left_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.left_pad = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_top_pad() const { uint32_t value = static_cast<uint32_t>(bits.top_pad); return value;}
    CONSTEXPR void set_top_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.top_pad = static_cast<uint32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_width_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_width_delta); return value;}
    CONSTEXPR void set_ifm_stripe_width_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_width_delta = static_cast<int32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_height_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_height_delta); return value;}
    CONSTEXPR void set_ifm_stripe_height_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_height_delta = static_cast<int32_t>(value); }
#endif
};


//
// ifm_pad12_ig1_r - IFM padding control
//
struct ifm_pad12_ig1_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t left_pad : 3; // Number of elements to pad on the left
            uint32_t top_pad : 3; // Number of elements to pad on the top
            int32_t ifm_stripe_width_delta : 5; // Delta between OFM rightmost element and IFM rightmost element (signed)
            int32_t ifm_stripe_height_delta : 5; // Delta between OFM bottommost element and IFM bottommost element (signed)
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_pad12_ig1_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_left_pad() const { uint32_t value = static_cast<uint32_t>(bits.left_pad); return value;}
    CONSTEXPR void set_left_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.left_pad = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_top_pad() const { uint32_t value = static_cast<uint32_t>(bits.top_pad); return value;}
    CONSTEXPR void set_top_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.top_pad = static_cast<uint32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_width_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_width_delta); return value;}
    CONSTEXPR void set_ifm_stripe_width_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_width_delta = static_cast<int32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_height_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_height_delta); return value;}
    CONSTEXPR void set_ifm_stripe_height_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_height_delta = static_cast<int32_t>(value); }
#endif
};


//
// ifm_pad13_ig1_r - IFM padding control
//
struct ifm_pad13_ig1_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t left_pad : 3; // Number of elements to pad on the left
            uint32_t top_pad : 3; // Number of elements to pad on the top
            int32_t ifm_stripe_width_delta : 5; // Delta between OFM rightmost element and IFM rightmost element (signed)
            int32_t ifm_stripe_height_delta : 5; // Delta between OFM bottommost element and IFM bottommost element (signed)
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_pad13_ig1_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_left_pad() const { uint32_t value = static_cast<uint32_t>(bits.left_pad); return value;}
    CONSTEXPR void set_left_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.left_pad = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_top_pad() const { uint32_t value = static_cast<uint32_t>(bits.top_pad); return value;}
    CONSTEXPR void set_top_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.top_pad = static_cast<uint32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_width_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_width_delta); return value;}
    CONSTEXPR void set_ifm_stripe_width_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_width_delta = static_cast<int32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_height_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_height_delta); return value;}
    CONSTEXPR void set_ifm_stripe_height_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_height_delta = static_cast<int32_t>(value); }
#endif
};


//
// ifm_pad14_ig1_r - IFM padding control
//
struct ifm_pad14_ig1_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t left_pad : 3; // Number of elements to pad on the left
            uint32_t top_pad : 3; // Number of elements to pad on the top
            int32_t ifm_stripe_width_delta : 5; // Delta between OFM rightmost element and IFM rightmost element (signed)
            int32_t ifm_stripe_height_delta : 5; // Delta between OFM bottommost element and IFM bottommost element (signed)
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_pad14_ig1_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_left_pad() const { uint32_t value = static_cast<uint32_t>(bits.left_pad); return value;}
    CONSTEXPR void set_left_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.left_pad = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_top_pad() const { uint32_t value = static_cast<uint32_t>(bits.top_pad); return value;}
    CONSTEXPR void set_top_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.top_pad = static_cast<uint32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_width_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_width_delta); return value;}
    CONSTEXPR void set_ifm_stripe_width_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_width_delta = static_cast<int32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_height_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_height_delta); return value;}
    CONSTEXPR void set_ifm_stripe_height_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_height_delta = static_cast<int32_t>(value); }
#endif
};


//
// ifm_pad15_ig1_r - IFM padding control
//
struct ifm_pad15_ig1_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t left_pad : 3; // Number of elements to pad on the left
            uint32_t top_pad : 3; // Number of elements to pad on the top
            int32_t ifm_stripe_width_delta : 5; // Delta between OFM rightmost element and IFM rightmost element (signed)
            int32_t ifm_stripe_height_delta : 5; // Delta between OFM bottommost element and IFM bottommost element (signed)
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_pad15_ig1_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_left_pad() const { uint32_t value = static_cast<uint32_t>(bits.left_pad); return value;}
    CONSTEXPR void set_left_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.left_pad = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_top_pad() const { uint32_t value = static_cast<uint32_t>(bits.top_pad); return value;}
    CONSTEXPR void set_top_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.top_pad = static_cast<uint32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_width_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_width_delta); return value;}
    CONSTEXPR void set_ifm_stripe_width_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_width_delta = static_cast<int32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_height_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_height_delta); return value;}
    CONSTEXPR void set_ifm_stripe_height_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_height_delta = static_cast<int32_t>(value); }
#endif
};


//
// mul_enable_og1_r - MAC per multiplier enable
//
struct mul_enable_og1_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mul_enable : 32; // Enable per multiplier in all CEs MAC unit
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR mul_enable_og1_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mul_enable() const { uint32_t value = static_cast<uint32_t>(bits.mul_enable); return value;}
    CONSTEXPR void set_mul_enable(uint32_t value) { bits.mul_enable = static_cast<uint32_t>(value); }
#endif
};


//
// weight_base_addr_og1_r - Weight base address
//
struct weight_base_addr_og1_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t address : 15; // Address into SRAM in terms of 128-bit words
            uint32_t reserved0 : 17;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR weight_base_addr_og1_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_address() const { uint32_t value = static_cast<uint32_t>(bits.address); return (value << 4);}
    CONSTEXPR void set_address(uint32_t value) { assert(static_cast<uint32_t>((value >> 4)) < 32768u); bits.address = static_cast<uint32_t>((value >> 4)); }
#endif
};


//
// ifm_config2_ig2_r - IFM configuration continued
//
struct ifm_config2_ig2_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t num_ifm_local : 16; // Number of IFM in current stripe being processed by current CE
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_config2_ig2_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_num_ifm_local() const { uint32_t value = static_cast<uint32_t>(bits.num_ifm_local); return value;}
    CONSTEXPR void set_num_ifm_local(uint32_t value) { assert(static_cast<uint32_t>(value) < 65536u); bits.num_ifm_local = static_cast<uint32_t>(value); }
#endif
};


//
// ifm_slot_base_address_ig2_r - IFM circular buffer base address
//
struct ifm_slot_base_address_ig2_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t ifm_slot_base_addr : 15; // Base address of the SRAM circular buffer containing the IFM elements. When operating in 16-bit IFM mode, this field contains only the lower bytes of the IFM elements.
            uint32_t reserved0 : 1;
            uint32_t ifm_slot_base_addr_hi : 15; // Base address of the SRAM circular buffer containing the higher bytes of the IFM elements when operating in 16-bit IFM mode.
            uint32_t reserved1 : 1;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_slot_base_address_ig2_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_ifm_slot_base_addr() const { uint32_t value = static_cast<uint32_t>(bits.ifm_slot_base_addr); return (value << 4);}
    CONSTEXPR void set_ifm_slot_base_addr(uint32_t value) { assert(static_cast<uint32_t>((value >> 4)) < 32768u); bits.ifm_slot_base_addr = static_cast<uint32_t>((value >> 4)); }
    CONSTEXPR uint32_t get_ifm_slot_base_addr_hi() const { uint32_t value = static_cast<uint32_t>(bits.ifm_slot_base_addr_hi); return (value << 4);}
    CONSTEXPR void set_ifm_slot_base_addr_hi(uint32_t value) { assert(static_cast<uint32_t>((value >> 4)) < 32768u); bits.ifm_slot_base_addr_hi = static_cast<uint32_t>((value >> 4)); }
#endif
};


//
// ifm_pad0_ig2_r - IFM padding control
//
struct ifm_pad0_ig2_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t left_pad : 3; // Number of elements to pad on the left
            uint32_t top_pad : 3; // Number of elements to pad on the top
            int32_t ifm_stripe_width_delta : 5; // Delta between OFM rightmost element and IFM rightmost element (signed)
            int32_t ifm_stripe_height_delta : 5; // Delta between OFM bottommost element and IFM bottommost element (signed)
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_pad0_ig2_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_left_pad() const { uint32_t value = static_cast<uint32_t>(bits.left_pad); return value;}
    CONSTEXPR void set_left_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.left_pad = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_top_pad() const { uint32_t value = static_cast<uint32_t>(bits.top_pad); return value;}
    CONSTEXPR void set_top_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.top_pad = static_cast<uint32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_width_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_width_delta); return value;}
    CONSTEXPR void set_ifm_stripe_width_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_width_delta = static_cast<int32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_height_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_height_delta); return value;}
    CONSTEXPR void set_ifm_stripe_height_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_height_delta = static_cast<int32_t>(value); }
#endif
};


//
// ifm_pad1_ig2_r - IFM padding control
//
struct ifm_pad1_ig2_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t left_pad : 3; // Number of elements to pad on the left
            uint32_t top_pad : 3; // Number of elements to pad on the top
            int32_t ifm_stripe_width_delta : 5; // Delta between OFM rightmost element and IFM rightmost element (signed)
            int32_t ifm_stripe_height_delta : 5; // Delta between OFM bottommost element and IFM bottommost element (signed)
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_pad1_ig2_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_left_pad() const { uint32_t value = static_cast<uint32_t>(bits.left_pad); return value;}
    CONSTEXPR void set_left_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.left_pad = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_top_pad() const { uint32_t value = static_cast<uint32_t>(bits.top_pad); return value;}
    CONSTEXPR void set_top_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.top_pad = static_cast<uint32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_width_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_width_delta); return value;}
    CONSTEXPR void set_ifm_stripe_width_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_width_delta = static_cast<int32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_height_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_height_delta); return value;}
    CONSTEXPR void set_ifm_stripe_height_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_height_delta = static_cast<int32_t>(value); }
#endif
};


//
// ifm_pad2_ig2_r - IFM padding control
//
struct ifm_pad2_ig2_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t left_pad : 3; // Number of elements to pad on the left
            uint32_t top_pad : 3; // Number of elements to pad on the top
            int32_t ifm_stripe_width_delta : 5; // Delta between OFM rightmost element and IFM rightmost element (signed)
            int32_t ifm_stripe_height_delta : 5; // Delta between OFM bottommost element and IFM bottommost element (signed)
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_pad2_ig2_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_left_pad() const { uint32_t value = static_cast<uint32_t>(bits.left_pad); return value;}
    CONSTEXPR void set_left_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.left_pad = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_top_pad() const { uint32_t value = static_cast<uint32_t>(bits.top_pad); return value;}
    CONSTEXPR void set_top_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.top_pad = static_cast<uint32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_width_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_width_delta); return value;}
    CONSTEXPR void set_ifm_stripe_width_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_width_delta = static_cast<int32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_height_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_height_delta); return value;}
    CONSTEXPR void set_ifm_stripe_height_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_height_delta = static_cast<int32_t>(value); }
#endif
};


//
// ifm_pad3_ig2_r - IFM padding control
//
struct ifm_pad3_ig2_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t left_pad : 3; // Number of elements to pad on the left
            uint32_t top_pad : 3; // Number of elements to pad on the top
            int32_t ifm_stripe_width_delta : 5; // Delta between OFM rightmost element and IFM rightmost element (signed)
            int32_t ifm_stripe_height_delta : 5; // Delta between OFM bottommost element and IFM bottommost element (signed)
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_pad3_ig2_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_left_pad() const { uint32_t value = static_cast<uint32_t>(bits.left_pad); return value;}
    CONSTEXPR void set_left_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.left_pad = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_top_pad() const { uint32_t value = static_cast<uint32_t>(bits.top_pad); return value;}
    CONSTEXPR void set_top_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.top_pad = static_cast<uint32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_width_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_width_delta); return value;}
    CONSTEXPR void set_ifm_stripe_width_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_width_delta = static_cast<int32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_height_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_height_delta); return value;}
    CONSTEXPR void set_ifm_stripe_height_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_height_delta = static_cast<int32_t>(value); }
#endif
};


//
// ifm_pad4_ig2_r - IFM padding control
//
struct ifm_pad4_ig2_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t left_pad : 3; // Number of elements to pad on the left
            uint32_t top_pad : 3; // Number of elements to pad on the top
            int32_t ifm_stripe_width_delta : 5; // Delta between OFM rightmost element and IFM rightmost element (signed)
            int32_t ifm_stripe_height_delta : 5; // Delta between OFM bottommost element and IFM bottommost element (signed)
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_pad4_ig2_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_left_pad() const { uint32_t value = static_cast<uint32_t>(bits.left_pad); return value;}
    CONSTEXPR void set_left_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.left_pad = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_top_pad() const { uint32_t value = static_cast<uint32_t>(bits.top_pad); return value;}
    CONSTEXPR void set_top_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.top_pad = static_cast<uint32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_width_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_width_delta); return value;}
    CONSTEXPR void set_ifm_stripe_width_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_width_delta = static_cast<int32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_height_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_height_delta); return value;}
    CONSTEXPR void set_ifm_stripe_height_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_height_delta = static_cast<int32_t>(value); }
#endif
};


//
// ifm_pad5_ig2_r - IFM padding control
//
struct ifm_pad5_ig2_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t left_pad : 3; // Number of elements to pad on the left
            uint32_t top_pad : 3; // Number of elements to pad on the top
            int32_t ifm_stripe_width_delta : 5; // Delta between OFM rightmost element and IFM rightmost element (signed)
            int32_t ifm_stripe_height_delta : 5; // Delta between OFM bottommost element and IFM bottommost element (signed)
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_pad5_ig2_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_left_pad() const { uint32_t value = static_cast<uint32_t>(bits.left_pad); return value;}
    CONSTEXPR void set_left_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.left_pad = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_top_pad() const { uint32_t value = static_cast<uint32_t>(bits.top_pad); return value;}
    CONSTEXPR void set_top_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.top_pad = static_cast<uint32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_width_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_width_delta); return value;}
    CONSTEXPR void set_ifm_stripe_width_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_width_delta = static_cast<int32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_height_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_height_delta); return value;}
    CONSTEXPR void set_ifm_stripe_height_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_height_delta = static_cast<int32_t>(value); }
#endif
};


//
// ifm_pad6_ig2_r - IFM padding control
//
struct ifm_pad6_ig2_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t left_pad : 3; // Number of elements to pad on the left
            uint32_t top_pad : 3; // Number of elements to pad on the top
            int32_t ifm_stripe_width_delta : 5; // Delta between OFM rightmost element and IFM rightmost element (signed)
            int32_t ifm_stripe_height_delta : 5; // Delta between OFM bottommost element and IFM bottommost element (signed)
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_pad6_ig2_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_left_pad() const { uint32_t value = static_cast<uint32_t>(bits.left_pad); return value;}
    CONSTEXPR void set_left_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.left_pad = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_top_pad() const { uint32_t value = static_cast<uint32_t>(bits.top_pad); return value;}
    CONSTEXPR void set_top_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.top_pad = static_cast<uint32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_width_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_width_delta); return value;}
    CONSTEXPR void set_ifm_stripe_width_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_width_delta = static_cast<int32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_height_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_height_delta); return value;}
    CONSTEXPR void set_ifm_stripe_height_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_height_delta = static_cast<int32_t>(value); }
#endif
};


//
// ifm_pad7_ig2_r - IFM padding control
//
struct ifm_pad7_ig2_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t left_pad : 3; // Number of elements to pad on the left
            uint32_t top_pad : 3; // Number of elements to pad on the top
            int32_t ifm_stripe_width_delta : 5; // Delta between OFM rightmost element and IFM rightmost element (signed)
            int32_t ifm_stripe_height_delta : 5; // Delta between OFM bottommost element and IFM bottommost element (signed)
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_pad7_ig2_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_left_pad() const { uint32_t value = static_cast<uint32_t>(bits.left_pad); return value;}
    CONSTEXPR void set_left_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.left_pad = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_top_pad() const { uint32_t value = static_cast<uint32_t>(bits.top_pad); return value;}
    CONSTEXPR void set_top_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.top_pad = static_cast<uint32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_width_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_width_delta); return value;}
    CONSTEXPR void set_ifm_stripe_width_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_width_delta = static_cast<int32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_height_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_height_delta); return value;}
    CONSTEXPR void set_ifm_stripe_height_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_height_delta = static_cast<int32_t>(value); }
#endif
};


//
// ifm_pad8_ig2_r - IFM padding control
//
struct ifm_pad8_ig2_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t left_pad : 3; // Number of elements to pad on the left
            uint32_t top_pad : 3; // Number of elements to pad on the top
            int32_t ifm_stripe_width_delta : 5; // Delta between OFM rightmost element and IFM rightmost element (signed)
            int32_t ifm_stripe_height_delta : 5; // Delta between OFM bottommost element and IFM bottommost element (signed)
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_pad8_ig2_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_left_pad() const { uint32_t value = static_cast<uint32_t>(bits.left_pad); return value;}
    CONSTEXPR void set_left_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.left_pad = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_top_pad() const { uint32_t value = static_cast<uint32_t>(bits.top_pad); return value;}
    CONSTEXPR void set_top_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.top_pad = static_cast<uint32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_width_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_width_delta); return value;}
    CONSTEXPR void set_ifm_stripe_width_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_width_delta = static_cast<int32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_height_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_height_delta); return value;}
    CONSTEXPR void set_ifm_stripe_height_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_height_delta = static_cast<int32_t>(value); }
#endif
};


//
// ifm_pad9_ig2_r - IFM padding control
//
struct ifm_pad9_ig2_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t left_pad : 3; // Number of elements to pad on the left
            uint32_t top_pad : 3; // Number of elements to pad on the top
            int32_t ifm_stripe_width_delta : 5; // Delta between OFM rightmost element and IFM rightmost element (signed)
            int32_t ifm_stripe_height_delta : 5; // Delta between OFM bottommost element and IFM bottommost element (signed)
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_pad9_ig2_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_left_pad() const { uint32_t value = static_cast<uint32_t>(bits.left_pad); return value;}
    CONSTEXPR void set_left_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.left_pad = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_top_pad() const { uint32_t value = static_cast<uint32_t>(bits.top_pad); return value;}
    CONSTEXPR void set_top_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.top_pad = static_cast<uint32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_width_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_width_delta); return value;}
    CONSTEXPR void set_ifm_stripe_width_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_width_delta = static_cast<int32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_height_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_height_delta); return value;}
    CONSTEXPR void set_ifm_stripe_height_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_height_delta = static_cast<int32_t>(value); }
#endif
};


//
// ifm_pad10_ig2_r - IFM padding control
//
struct ifm_pad10_ig2_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t left_pad : 3; // Number of elements to pad on the left
            uint32_t top_pad : 3; // Number of elements to pad on the top
            int32_t ifm_stripe_width_delta : 5; // Delta between OFM rightmost element and IFM rightmost element (signed)
            int32_t ifm_stripe_height_delta : 5; // Delta between OFM bottommost element and IFM bottommost element (signed)
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_pad10_ig2_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_left_pad() const { uint32_t value = static_cast<uint32_t>(bits.left_pad); return value;}
    CONSTEXPR void set_left_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.left_pad = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_top_pad() const { uint32_t value = static_cast<uint32_t>(bits.top_pad); return value;}
    CONSTEXPR void set_top_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.top_pad = static_cast<uint32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_width_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_width_delta); return value;}
    CONSTEXPR void set_ifm_stripe_width_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_width_delta = static_cast<int32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_height_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_height_delta); return value;}
    CONSTEXPR void set_ifm_stripe_height_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_height_delta = static_cast<int32_t>(value); }
#endif
};


//
// ifm_pad11_ig2_r - IFM padding control
//
struct ifm_pad11_ig2_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t left_pad : 3; // Number of elements to pad on the left
            uint32_t top_pad : 3; // Number of elements to pad on the top
            int32_t ifm_stripe_width_delta : 5; // Delta between OFM rightmost element and IFM rightmost element (signed)
            int32_t ifm_stripe_height_delta : 5; // Delta between OFM bottommost element and IFM bottommost element (signed)
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_pad11_ig2_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_left_pad() const { uint32_t value = static_cast<uint32_t>(bits.left_pad); return value;}
    CONSTEXPR void set_left_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.left_pad = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_top_pad() const { uint32_t value = static_cast<uint32_t>(bits.top_pad); return value;}
    CONSTEXPR void set_top_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.top_pad = static_cast<uint32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_width_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_width_delta); return value;}
    CONSTEXPR void set_ifm_stripe_width_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_width_delta = static_cast<int32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_height_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_height_delta); return value;}
    CONSTEXPR void set_ifm_stripe_height_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_height_delta = static_cast<int32_t>(value); }
#endif
};


//
// ifm_pad12_ig2_r - IFM padding control
//
struct ifm_pad12_ig2_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t left_pad : 3; // Number of elements to pad on the left
            uint32_t top_pad : 3; // Number of elements to pad on the top
            int32_t ifm_stripe_width_delta : 5; // Delta between OFM rightmost element and IFM rightmost element (signed)
            int32_t ifm_stripe_height_delta : 5; // Delta between OFM bottommost element and IFM bottommost element (signed)
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_pad12_ig2_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_left_pad() const { uint32_t value = static_cast<uint32_t>(bits.left_pad); return value;}
    CONSTEXPR void set_left_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.left_pad = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_top_pad() const { uint32_t value = static_cast<uint32_t>(bits.top_pad); return value;}
    CONSTEXPR void set_top_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.top_pad = static_cast<uint32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_width_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_width_delta); return value;}
    CONSTEXPR void set_ifm_stripe_width_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_width_delta = static_cast<int32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_height_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_height_delta); return value;}
    CONSTEXPR void set_ifm_stripe_height_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_height_delta = static_cast<int32_t>(value); }
#endif
};


//
// ifm_pad13_ig2_r - IFM padding control
//
struct ifm_pad13_ig2_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t left_pad : 3; // Number of elements to pad on the left
            uint32_t top_pad : 3; // Number of elements to pad on the top
            int32_t ifm_stripe_width_delta : 5; // Delta between OFM rightmost element and IFM rightmost element (signed)
            int32_t ifm_stripe_height_delta : 5; // Delta between OFM bottommost element and IFM bottommost element (signed)
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_pad13_ig2_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_left_pad() const { uint32_t value = static_cast<uint32_t>(bits.left_pad); return value;}
    CONSTEXPR void set_left_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.left_pad = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_top_pad() const { uint32_t value = static_cast<uint32_t>(bits.top_pad); return value;}
    CONSTEXPR void set_top_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.top_pad = static_cast<uint32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_width_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_width_delta); return value;}
    CONSTEXPR void set_ifm_stripe_width_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_width_delta = static_cast<int32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_height_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_height_delta); return value;}
    CONSTEXPR void set_ifm_stripe_height_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_height_delta = static_cast<int32_t>(value); }
#endif
};


//
// ifm_pad14_ig2_r - IFM padding control
//
struct ifm_pad14_ig2_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t left_pad : 3; // Number of elements to pad on the left
            uint32_t top_pad : 3; // Number of elements to pad on the top
            int32_t ifm_stripe_width_delta : 5; // Delta between OFM rightmost element and IFM rightmost element (signed)
            int32_t ifm_stripe_height_delta : 5; // Delta between OFM bottommost element and IFM bottommost element (signed)
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_pad14_ig2_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_left_pad() const { uint32_t value = static_cast<uint32_t>(bits.left_pad); return value;}
    CONSTEXPR void set_left_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.left_pad = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_top_pad() const { uint32_t value = static_cast<uint32_t>(bits.top_pad); return value;}
    CONSTEXPR void set_top_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.top_pad = static_cast<uint32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_width_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_width_delta); return value;}
    CONSTEXPR void set_ifm_stripe_width_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_width_delta = static_cast<int32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_height_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_height_delta); return value;}
    CONSTEXPR void set_ifm_stripe_height_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_height_delta = static_cast<int32_t>(value); }
#endif
};


//
// ifm_pad15_ig2_r - IFM padding control
//
struct ifm_pad15_ig2_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t left_pad : 3; // Number of elements to pad on the left
            uint32_t top_pad : 3; // Number of elements to pad on the top
            int32_t ifm_stripe_width_delta : 5; // Delta between OFM rightmost element and IFM rightmost element (signed)
            int32_t ifm_stripe_height_delta : 5; // Delta between OFM bottommost element and IFM bottommost element (signed)
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_pad15_ig2_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_left_pad() const { uint32_t value = static_cast<uint32_t>(bits.left_pad); return value;}
    CONSTEXPR void set_left_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.left_pad = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_top_pad() const { uint32_t value = static_cast<uint32_t>(bits.top_pad); return value;}
    CONSTEXPR void set_top_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.top_pad = static_cast<uint32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_width_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_width_delta); return value;}
    CONSTEXPR void set_ifm_stripe_width_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_width_delta = static_cast<int32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_height_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_height_delta); return value;}
    CONSTEXPR void set_ifm_stripe_height_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_height_delta = static_cast<int32_t>(value); }
#endif
};


//
// mul_enable_og2_r - MAC per multiplier enable
//
struct mul_enable_og2_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mul_enable : 32; // Enable per multiplier in all CEs MAC unit
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR mul_enable_og2_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mul_enable() const { uint32_t value = static_cast<uint32_t>(bits.mul_enable); return value;}
    CONSTEXPR void set_mul_enable(uint32_t value) { bits.mul_enable = static_cast<uint32_t>(value); }
#endif
};


//
// weight_base_addr_og2_r - Weight base address
//
struct weight_base_addr_og2_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t address : 15; // Address into SRAM in terms of 128-bit words
            uint32_t reserved0 : 17;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR weight_base_addr_og2_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_address() const { uint32_t value = static_cast<uint32_t>(bits.address); return (value << 4);}
    CONSTEXPR void set_address(uint32_t value) { assert(static_cast<uint32_t>((value >> 4)) < 32768u); bits.address = static_cast<uint32_t>((value >> 4)); }
#endif
};


//
// ifm_config2_ig3_r - IFM configuration continued
//
struct ifm_config2_ig3_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t num_ifm_local : 16; // Number of IFM in current stripe being processed by current CE
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_config2_ig3_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_num_ifm_local() const { uint32_t value = static_cast<uint32_t>(bits.num_ifm_local); return value;}
    CONSTEXPR void set_num_ifm_local(uint32_t value) { assert(static_cast<uint32_t>(value) < 65536u); bits.num_ifm_local = static_cast<uint32_t>(value); }
#endif
};


//
// ifm_slot_base_address_ig3_r - IFM circular buffer base address
//
struct ifm_slot_base_address_ig3_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t ifm_slot_base_addr : 15; // Base address of the SRAM circular buffer containing the IFM elements. When operating in 16-bit IFM mode, this field contains only the lower bytes of the IFM elements.
            uint32_t reserved0 : 1;
            uint32_t ifm_slot_base_addr_hi : 15; // Base address of the SRAM circular buffer containing the higher bytes of the IFM elements when operating in 16-bit IFM mode.
            uint32_t reserved1 : 1;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_slot_base_address_ig3_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_ifm_slot_base_addr() const { uint32_t value = static_cast<uint32_t>(bits.ifm_slot_base_addr); return (value << 4);}
    CONSTEXPR void set_ifm_slot_base_addr(uint32_t value) { assert(static_cast<uint32_t>((value >> 4)) < 32768u); bits.ifm_slot_base_addr = static_cast<uint32_t>((value >> 4)); }
    CONSTEXPR uint32_t get_ifm_slot_base_addr_hi() const { uint32_t value = static_cast<uint32_t>(bits.ifm_slot_base_addr_hi); return (value << 4);}
    CONSTEXPR void set_ifm_slot_base_addr_hi(uint32_t value) { assert(static_cast<uint32_t>((value >> 4)) < 32768u); bits.ifm_slot_base_addr_hi = static_cast<uint32_t>((value >> 4)); }
#endif
};


//
// ifm_pad0_ig3_r - IFM padding control
//
struct ifm_pad0_ig3_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t left_pad : 3; // Number of elements to pad on the left
            uint32_t top_pad : 3; // Number of elements to pad on the top
            int32_t ifm_stripe_width_delta : 5; // Delta between OFM rightmost element and IFM rightmost element (signed)
            int32_t ifm_stripe_height_delta : 5; // Delta between OFM bottommost element and IFM bottommost element (signed)
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_pad0_ig3_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_left_pad() const { uint32_t value = static_cast<uint32_t>(bits.left_pad); return value;}
    CONSTEXPR void set_left_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.left_pad = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_top_pad() const { uint32_t value = static_cast<uint32_t>(bits.top_pad); return value;}
    CONSTEXPR void set_top_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.top_pad = static_cast<uint32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_width_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_width_delta); return value;}
    CONSTEXPR void set_ifm_stripe_width_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_width_delta = static_cast<int32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_height_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_height_delta); return value;}
    CONSTEXPR void set_ifm_stripe_height_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_height_delta = static_cast<int32_t>(value); }
#endif
};


//
// ifm_pad1_ig3_r - IFM padding control
//
struct ifm_pad1_ig3_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t left_pad : 3; // Number of elements to pad on the left
            uint32_t top_pad : 3; // Number of elements to pad on the top
            int32_t ifm_stripe_width_delta : 5; // Delta between OFM rightmost element and IFM rightmost element (signed)
            int32_t ifm_stripe_height_delta : 5; // Delta between OFM bottommost element and IFM bottommost element (signed)
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_pad1_ig3_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_left_pad() const { uint32_t value = static_cast<uint32_t>(bits.left_pad); return value;}
    CONSTEXPR void set_left_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.left_pad = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_top_pad() const { uint32_t value = static_cast<uint32_t>(bits.top_pad); return value;}
    CONSTEXPR void set_top_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.top_pad = static_cast<uint32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_width_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_width_delta); return value;}
    CONSTEXPR void set_ifm_stripe_width_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_width_delta = static_cast<int32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_height_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_height_delta); return value;}
    CONSTEXPR void set_ifm_stripe_height_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_height_delta = static_cast<int32_t>(value); }
#endif
};


//
// ifm_pad2_ig3_r - IFM padding control
//
struct ifm_pad2_ig3_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t left_pad : 3; // Number of elements to pad on the left
            uint32_t top_pad : 3; // Number of elements to pad on the top
            int32_t ifm_stripe_width_delta : 5; // Delta between OFM rightmost element and IFM rightmost element (signed)
            int32_t ifm_stripe_height_delta : 5; // Delta between OFM bottommost element and IFM bottommost element (signed)
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_pad2_ig3_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_left_pad() const { uint32_t value = static_cast<uint32_t>(bits.left_pad); return value;}
    CONSTEXPR void set_left_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.left_pad = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_top_pad() const { uint32_t value = static_cast<uint32_t>(bits.top_pad); return value;}
    CONSTEXPR void set_top_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.top_pad = static_cast<uint32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_width_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_width_delta); return value;}
    CONSTEXPR void set_ifm_stripe_width_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_width_delta = static_cast<int32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_height_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_height_delta); return value;}
    CONSTEXPR void set_ifm_stripe_height_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_height_delta = static_cast<int32_t>(value); }
#endif
};


//
// ifm_pad3_ig3_r - IFM padding control
//
struct ifm_pad3_ig3_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t left_pad : 3; // Number of elements to pad on the left
            uint32_t top_pad : 3; // Number of elements to pad on the top
            int32_t ifm_stripe_width_delta : 5; // Delta between OFM rightmost element and IFM rightmost element (signed)
            int32_t ifm_stripe_height_delta : 5; // Delta between OFM bottommost element and IFM bottommost element (signed)
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_pad3_ig3_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_left_pad() const { uint32_t value = static_cast<uint32_t>(bits.left_pad); return value;}
    CONSTEXPR void set_left_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.left_pad = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_top_pad() const { uint32_t value = static_cast<uint32_t>(bits.top_pad); return value;}
    CONSTEXPR void set_top_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.top_pad = static_cast<uint32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_width_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_width_delta); return value;}
    CONSTEXPR void set_ifm_stripe_width_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_width_delta = static_cast<int32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_height_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_height_delta); return value;}
    CONSTEXPR void set_ifm_stripe_height_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_height_delta = static_cast<int32_t>(value); }
#endif
};


//
// ifm_pad4_ig3_r - IFM padding control
//
struct ifm_pad4_ig3_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t left_pad : 3; // Number of elements to pad on the left
            uint32_t top_pad : 3; // Number of elements to pad on the top
            int32_t ifm_stripe_width_delta : 5; // Delta between OFM rightmost element and IFM rightmost element (signed)
            int32_t ifm_stripe_height_delta : 5; // Delta between OFM bottommost element and IFM bottommost element (signed)
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_pad4_ig3_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_left_pad() const { uint32_t value = static_cast<uint32_t>(bits.left_pad); return value;}
    CONSTEXPR void set_left_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.left_pad = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_top_pad() const { uint32_t value = static_cast<uint32_t>(bits.top_pad); return value;}
    CONSTEXPR void set_top_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.top_pad = static_cast<uint32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_width_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_width_delta); return value;}
    CONSTEXPR void set_ifm_stripe_width_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_width_delta = static_cast<int32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_height_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_height_delta); return value;}
    CONSTEXPR void set_ifm_stripe_height_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_height_delta = static_cast<int32_t>(value); }
#endif
};


//
// ifm_pad5_ig3_r - IFM padding control
//
struct ifm_pad5_ig3_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t left_pad : 3; // Number of elements to pad on the left
            uint32_t top_pad : 3; // Number of elements to pad on the top
            int32_t ifm_stripe_width_delta : 5; // Delta between OFM rightmost element and IFM rightmost element (signed)
            int32_t ifm_stripe_height_delta : 5; // Delta between OFM bottommost element and IFM bottommost element (signed)
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_pad5_ig3_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_left_pad() const { uint32_t value = static_cast<uint32_t>(bits.left_pad); return value;}
    CONSTEXPR void set_left_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.left_pad = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_top_pad() const { uint32_t value = static_cast<uint32_t>(bits.top_pad); return value;}
    CONSTEXPR void set_top_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.top_pad = static_cast<uint32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_width_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_width_delta); return value;}
    CONSTEXPR void set_ifm_stripe_width_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_width_delta = static_cast<int32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_height_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_height_delta); return value;}
    CONSTEXPR void set_ifm_stripe_height_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_height_delta = static_cast<int32_t>(value); }
#endif
};


//
// ifm_pad6_ig3_r - IFM padding control
//
struct ifm_pad6_ig3_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t left_pad : 3; // Number of elements to pad on the left
            uint32_t top_pad : 3; // Number of elements to pad on the top
            int32_t ifm_stripe_width_delta : 5; // Delta between OFM rightmost element and IFM rightmost element (signed)
            int32_t ifm_stripe_height_delta : 5; // Delta between OFM bottommost element and IFM bottommost element (signed)
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_pad6_ig3_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_left_pad() const { uint32_t value = static_cast<uint32_t>(bits.left_pad); return value;}
    CONSTEXPR void set_left_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.left_pad = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_top_pad() const { uint32_t value = static_cast<uint32_t>(bits.top_pad); return value;}
    CONSTEXPR void set_top_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.top_pad = static_cast<uint32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_width_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_width_delta); return value;}
    CONSTEXPR void set_ifm_stripe_width_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_width_delta = static_cast<int32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_height_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_height_delta); return value;}
    CONSTEXPR void set_ifm_stripe_height_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_height_delta = static_cast<int32_t>(value); }
#endif
};


//
// ifm_pad7_ig3_r - IFM padding control
//
struct ifm_pad7_ig3_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t left_pad : 3; // Number of elements to pad on the left
            uint32_t top_pad : 3; // Number of elements to pad on the top
            int32_t ifm_stripe_width_delta : 5; // Delta between OFM rightmost element and IFM rightmost element (signed)
            int32_t ifm_stripe_height_delta : 5; // Delta between OFM bottommost element and IFM bottommost element (signed)
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_pad7_ig3_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_left_pad() const { uint32_t value = static_cast<uint32_t>(bits.left_pad); return value;}
    CONSTEXPR void set_left_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.left_pad = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_top_pad() const { uint32_t value = static_cast<uint32_t>(bits.top_pad); return value;}
    CONSTEXPR void set_top_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.top_pad = static_cast<uint32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_width_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_width_delta); return value;}
    CONSTEXPR void set_ifm_stripe_width_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_width_delta = static_cast<int32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_height_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_height_delta); return value;}
    CONSTEXPR void set_ifm_stripe_height_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_height_delta = static_cast<int32_t>(value); }
#endif
};


//
// ifm_pad8_ig3_r - IFM padding control
//
struct ifm_pad8_ig3_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t left_pad : 3; // Number of elements to pad on the left
            uint32_t top_pad : 3; // Number of elements to pad on the top
            int32_t ifm_stripe_width_delta : 5; // Delta between OFM rightmost element and IFM rightmost element (signed)
            int32_t ifm_stripe_height_delta : 5; // Delta between OFM bottommost element and IFM bottommost element (signed)
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_pad8_ig3_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_left_pad() const { uint32_t value = static_cast<uint32_t>(bits.left_pad); return value;}
    CONSTEXPR void set_left_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.left_pad = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_top_pad() const { uint32_t value = static_cast<uint32_t>(bits.top_pad); return value;}
    CONSTEXPR void set_top_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.top_pad = static_cast<uint32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_width_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_width_delta); return value;}
    CONSTEXPR void set_ifm_stripe_width_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_width_delta = static_cast<int32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_height_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_height_delta); return value;}
    CONSTEXPR void set_ifm_stripe_height_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_height_delta = static_cast<int32_t>(value); }
#endif
};


//
// ifm_pad9_ig3_r - IFM padding control
//
struct ifm_pad9_ig3_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t left_pad : 3; // Number of elements to pad on the left
            uint32_t top_pad : 3; // Number of elements to pad on the top
            int32_t ifm_stripe_width_delta : 5; // Delta between OFM rightmost element and IFM rightmost element (signed)
            int32_t ifm_stripe_height_delta : 5; // Delta between OFM bottommost element and IFM bottommost element (signed)
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_pad9_ig3_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_left_pad() const { uint32_t value = static_cast<uint32_t>(bits.left_pad); return value;}
    CONSTEXPR void set_left_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.left_pad = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_top_pad() const { uint32_t value = static_cast<uint32_t>(bits.top_pad); return value;}
    CONSTEXPR void set_top_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.top_pad = static_cast<uint32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_width_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_width_delta); return value;}
    CONSTEXPR void set_ifm_stripe_width_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_width_delta = static_cast<int32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_height_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_height_delta); return value;}
    CONSTEXPR void set_ifm_stripe_height_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_height_delta = static_cast<int32_t>(value); }
#endif
};


//
// ifm_pad10_ig3_r - IFM padding control
//
struct ifm_pad10_ig3_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t left_pad : 3; // Number of elements to pad on the left
            uint32_t top_pad : 3; // Number of elements to pad on the top
            int32_t ifm_stripe_width_delta : 5; // Delta between OFM rightmost element and IFM rightmost element (signed)
            int32_t ifm_stripe_height_delta : 5; // Delta between OFM bottommost element and IFM bottommost element (signed)
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_pad10_ig3_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_left_pad() const { uint32_t value = static_cast<uint32_t>(bits.left_pad); return value;}
    CONSTEXPR void set_left_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.left_pad = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_top_pad() const { uint32_t value = static_cast<uint32_t>(bits.top_pad); return value;}
    CONSTEXPR void set_top_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.top_pad = static_cast<uint32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_width_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_width_delta); return value;}
    CONSTEXPR void set_ifm_stripe_width_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_width_delta = static_cast<int32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_height_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_height_delta); return value;}
    CONSTEXPR void set_ifm_stripe_height_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_height_delta = static_cast<int32_t>(value); }
#endif
};


//
// ifm_pad11_ig3_r - IFM padding control
//
struct ifm_pad11_ig3_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t left_pad : 3; // Number of elements to pad on the left
            uint32_t top_pad : 3; // Number of elements to pad on the top
            int32_t ifm_stripe_width_delta : 5; // Delta between OFM rightmost element and IFM rightmost element (signed)
            int32_t ifm_stripe_height_delta : 5; // Delta between OFM bottommost element and IFM bottommost element (signed)
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_pad11_ig3_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_left_pad() const { uint32_t value = static_cast<uint32_t>(bits.left_pad); return value;}
    CONSTEXPR void set_left_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.left_pad = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_top_pad() const { uint32_t value = static_cast<uint32_t>(bits.top_pad); return value;}
    CONSTEXPR void set_top_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.top_pad = static_cast<uint32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_width_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_width_delta); return value;}
    CONSTEXPR void set_ifm_stripe_width_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_width_delta = static_cast<int32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_height_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_height_delta); return value;}
    CONSTEXPR void set_ifm_stripe_height_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_height_delta = static_cast<int32_t>(value); }
#endif
};


//
// ifm_pad12_ig3_r - IFM padding control
//
struct ifm_pad12_ig3_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t left_pad : 3; // Number of elements to pad on the left
            uint32_t top_pad : 3; // Number of elements to pad on the top
            int32_t ifm_stripe_width_delta : 5; // Delta between OFM rightmost element and IFM rightmost element (signed)
            int32_t ifm_stripe_height_delta : 5; // Delta between OFM bottommost element and IFM bottommost element (signed)
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_pad12_ig3_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_left_pad() const { uint32_t value = static_cast<uint32_t>(bits.left_pad); return value;}
    CONSTEXPR void set_left_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.left_pad = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_top_pad() const { uint32_t value = static_cast<uint32_t>(bits.top_pad); return value;}
    CONSTEXPR void set_top_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.top_pad = static_cast<uint32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_width_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_width_delta); return value;}
    CONSTEXPR void set_ifm_stripe_width_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_width_delta = static_cast<int32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_height_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_height_delta); return value;}
    CONSTEXPR void set_ifm_stripe_height_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_height_delta = static_cast<int32_t>(value); }
#endif
};


//
// ifm_pad13_ig3_r - IFM padding control
//
struct ifm_pad13_ig3_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t left_pad : 3; // Number of elements to pad on the left
            uint32_t top_pad : 3; // Number of elements to pad on the top
            int32_t ifm_stripe_width_delta : 5; // Delta between OFM rightmost element and IFM rightmost element (signed)
            int32_t ifm_stripe_height_delta : 5; // Delta between OFM bottommost element and IFM bottommost element (signed)
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_pad13_ig3_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_left_pad() const { uint32_t value = static_cast<uint32_t>(bits.left_pad); return value;}
    CONSTEXPR void set_left_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.left_pad = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_top_pad() const { uint32_t value = static_cast<uint32_t>(bits.top_pad); return value;}
    CONSTEXPR void set_top_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.top_pad = static_cast<uint32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_width_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_width_delta); return value;}
    CONSTEXPR void set_ifm_stripe_width_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_width_delta = static_cast<int32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_height_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_height_delta); return value;}
    CONSTEXPR void set_ifm_stripe_height_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_height_delta = static_cast<int32_t>(value); }
#endif
};


//
// ifm_pad14_ig3_r - IFM padding control
//
struct ifm_pad14_ig3_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t left_pad : 3; // Number of elements to pad on the left
            uint32_t top_pad : 3; // Number of elements to pad on the top
            int32_t ifm_stripe_width_delta : 5; // Delta between OFM rightmost element and IFM rightmost element (signed)
            int32_t ifm_stripe_height_delta : 5; // Delta between OFM bottommost element and IFM bottommost element (signed)
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_pad14_ig3_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_left_pad() const { uint32_t value = static_cast<uint32_t>(bits.left_pad); return value;}
    CONSTEXPR void set_left_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.left_pad = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_top_pad() const { uint32_t value = static_cast<uint32_t>(bits.top_pad); return value;}
    CONSTEXPR void set_top_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.top_pad = static_cast<uint32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_width_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_width_delta); return value;}
    CONSTEXPR void set_ifm_stripe_width_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_width_delta = static_cast<int32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_height_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_height_delta); return value;}
    CONSTEXPR void set_ifm_stripe_height_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_height_delta = static_cast<int32_t>(value); }
#endif
};


//
// ifm_pad15_ig3_r - IFM padding control
//
struct ifm_pad15_ig3_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t left_pad : 3; // Number of elements to pad on the left
            uint32_t top_pad : 3; // Number of elements to pad on the top
            int32_t ifm_stripe_width_delta : 5; // Delta between OFM rightmost element and IFM rightmost element (signed)
            int32_t ifm_stripe_height_delta : 5; // Delta between OFM bottommost element and IFM bottommost element (signed)
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ifm_pad15_ig3_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_left_pad() const { uint32_t value = static_cast<uint32_t>(bits.left_pad); return value;}
    CONSTEXPR void set_left_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.left_pad = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_top_pad() const { uint32_t value = static_cast<uint32_t>(bits.top_pad); return value;}
    CONSTEXPR void set_top_pad(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.top_pad = static_cast<uint32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_width_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_width_delta); return value;}
    CONSTEXPR void set_ifm_stripe_width_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_width_delta = static_cast<int32_t>(value); }
    CONSTEXPR int32_t get_ifm_stripe_height_delta() const { int32_t value = static_cast<int32_t>(bits.ifm_stripe_height_delta); return value;}
    CONSTEXPR void set_ifm_stripe_height_delta(int32_t value) { assert( static_cast<int32_t>(value) >= -16 && static_cast<int32_t>(value) <= 15); bits.ifm_stripe_height_delta = static_cast<int32_t>(value); }
#endif
};


//
// mul_enable_og3_r - MAC per multiplier enable
//
struct mul_enable_og3_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mul_enable : 32; // Enable per multiplier in all CEs MAC unit
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR mul_enable_og3_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mul_enable() const { uint32_t value = static_cast<uint32_t>(bits.mul_enable); return value;}
    CONSTEXPR void set_mul_enable(uint32_t value) { bits.mul_enable = static_cast<uint32_t>(value); }
#endif
};


//
// weight_base_addr_og3_r - Weight base address
//
struct weight_base_addr_og3_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t address : 15; // Address into SRAM in terms of 128-bit words
            uint32_t reserved0 : 17;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR weight_base_addr_og3_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_address() const { uint32_t value = static_cast<uint32_t>(bits.address); return (value << 4);}
    CONSTEXPR void set_address(uint32_t value) { assert(static_cast<uint32_t>((value >> 4)) < 32768u); bits.address = static_cast<uint32_t>((value >> 4)); }
#endif
};


//
// mce_debug_control_r - Debug control configuration
//
struct mce_debug_control_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t event_suppress : 1; // PMU event suppression
            uint32_t reserved0 : 31;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR mce_debug_control_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_event_suppress() const { uint32_t value = static_cast<uint32_t>(bits.event_suppress); return value;}
    CONSTEXPR void set_event_suppress(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.event_suppress = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_ext_access_control_r - External Access Control
//
struct dl1_ext_access_control_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t excctlr : 1; // Execution control pages access control
            uint32_t ramctlr : 1; // Memory mapped RAMs access control
            uint32_t dbgctlr : 1; // PMU and DBG pages access control
            uint32_t reserved0 : 5;
            uint32_t reserved1 : 8;
            uint32_t reserved2 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_ext_access_control_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_excctlr() const { uint32_t value = static_cast<uint32_t>(bits.excctlr); return value;}
    CONSTEXPR void set_excctlr(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.excctlr = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ramctlr() const { uint32_t value = static_cast<uint32_t>(bits.ramctlr); return value;}
    CONSTEXPR void set_ramctlr(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ramctlr = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_dbgctlr() const { uint32_t value = static_cast<uint32_t>(bits.dbgctlr); return value;}
    CONSTEXPR void set_dbgctlr(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.dbgctlr = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_delegation_r - Control Access Delegation
//
struct dl1_delegation_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t secctlr : 1; // SECCTLR register delegation bit
            uint32_t secmcuctlr : 1; // SECMCUCTLR register delegation bit
            uint32_t sysctlr : 1; // SYSCTLR register delegation bit
            uint32_t pwrctlr : 1; // PWRCTLR register delegation bit
            uint32_t auxctlr : 1; // AUXCTLR register delegation bit
            uint32_t excctlr : 1; // EXCCTLR delegation bit
            uint32_t ramctlr : 1; // RAMCTLR delegation bit
            uint32_t dbgctlr : 1; // DBGCTLR delegation bit
            uint32_t err : 1; // Error register delegation bit
            uint32_t debug : 1; // Debug register delegation bit
            uint32_t job : 1; // Job register delegation bit
            uint32_t event : 1; // Event register delegation bit
            uint32_t interrupt : 1; // Interrupt register delegation bit
            uint32_t nmi : 1; // NMI register delegation bit
            uint32_t irq : 1; // IRQ_STATUS register delegation bit
            uint32_t intext : 1; // INT_STATUS and EXT_STATUS registers delegation bit (shared)
            uint32_t gp0 : 1; // GP0 register delegation bit
            uint32_t gp1 : 1; // GP1 register delegation bit
            uint32_t gp2 : 1; // GP2 register delegation bit
            uint32_t gp3 : 1; // GP3 register delegation bit
            uint32_t gp4 : 1; // GP4 register delegation bit
            uint32_t gp5 : 1; // GP5 register delegation bit
            uint32_t gp6 : 1; // GP6 register delegation bit
            uint32_t gp7 : 1; // GP7 register delegation bit
            uint32_t dfcot : 1; // DFC outstanding transaction registers delegation bit
            uint32_t reserved0 : 7;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_delegation_r(uint32_t init=0) : word(init) {}
    CONSTEXPR delegation_t get_secctlr() const { delegation_t value = static_cast<delegation_t>(bits.secctlr); return value;}
    CONSTEXPR void set_secctlr(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.secctlr = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_secmcuctlr() const { delegation_t value = static_cast<delegation_t>(bits.secmcuctlr); return value;}
    CONSTEXPR void set_secmcuctlr(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.secmcuctlr = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_sysctlr() const { delegation_t value = static_cast<delegation_t>(bits.sysctlr); return value;}
    CONSTEXPR void set_sysctlr(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.sysctlr = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_pwrctlr() const { delegation_t value = static_cast<delegation_t>(bits.pwrctlr); return value;}
    CONSTEXPR void set_pwrctlr(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.pwrctlr = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_auxctlr() const { delegation_t value = static_cast<delegation_t>(bits.auxctlr); return value;}
    CONSTEXPR void set_auxctlr(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.auxctlr = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_excctlr() const { delegation_t value = static_cast<delegation_t>(bits.excctlr); return value;}
    CONSTEXPR void set_excctlr(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.excctlr = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_ramctlr() const { delegation_t value = static_cast<delegation_t>(bits.ramctlr); return value;}
    CONSTEXPR void set_ramctlr(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ramctlr = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_dbgctlr() const { delegation_t value = static_cast<delegation_t>(bits.dbgctlr); return value;}
    CONSTEXPR void set_dbgctlr(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.dbgctlr = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_err() const { delegation_t value = static_cast<delegation_t>(bits.err); return value;}
    CONSTEXPR void set_err(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.err = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_debug() const { delegation_t value = static_cast<delegation_t>(bits.debug); return value;}
    CONSTEXPR void set_debug(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.debug = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_job() const { delegation_t value = static_cast<delegation_t>(bits.job); return value;}
    CONSTEXPR void set_job(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.job = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_event() const { delegation_t value = static_cast<delegation_t>(bits.event); return value;}
    CONSTEXPR void set_event(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.event = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_interrupt() const { delegation_t value = static_cast<delegation_t>(bits.interrupt); return value;}
    CONSTEXPR void set_interrupt(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.interrupt = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_nmi() const { delegation_t value = static_cast<delegation_t>(bits.nmi); return value;}
    CONSTEXPR void set_nmi(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.nmi = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_irq() const { delegation_t value = static_cast<delegation_t>(bits.irq); return value;}
    CONSTEXPR void set_irq(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.irq = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_intext() const { delegation_t value = static_cast<delegation_t>(bits.intext); return value;}
    CONSTEXPR void set_intext(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.intext = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_gp0() const { delegation_t value = static_cast<delegation_t>(bits.gp0); return value;}
    CONSTEXPR void set_gp0(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.gp0 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_gp1() const { delegation_t value = static_cast<delegation_t>(bits.gp1); return value;}
    CONSTEXPR void set_gp1(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.gp1 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_gp2() const { delegation_t value = static_cast<delegation_t>(bits.gp2); return value;}
    CONSTEXPR void set_gp2(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.gp2 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_gp3() const { delegation_t value = static_cast<delegation_t>(bits.gp3); return value;}
    CONSTEXPR void set_gp3(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.gp3 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_gp4() const { delegation_t value = static_cast<delegation_t>(bits.gp4); return value;}
    CONSTEXPR void set_gp4(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.gp4 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_gp5() const { delegation_t value = static_cast<delegation_t>(bits.gp5); return value;}
    CONSTEXPR void set_gp5(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.gp5 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_gp6() const { delegation_t value = static_cast<delegation_t>(bits.gp6); return value;}
    CONSTEXPR void set_gp6(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.gp6 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_gp7() const { delegation_t value = static_cast<delegation_t>(bits.gp7); return value;}
    CONSTEXPR void set_gp7(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.gp7 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_dfcot() const { delegation_t value = static_cast<delegation_t>(bits.dfcot); return value;}
    CONSTEXPR void set_dfcot(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.dfcot = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_secctlr_r - NPU security controls
//
struct dl1_secctlr_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t ns_allowed : 1; // Allow Non-secure transactions
            uint32_t npu_ns_mode : 1; // NPU Non-secure mode
            uint32_t reserved0 : 6;
            uint32_t ext_ns_evnt_to_s_evnt : 1; // NCU MCU S x NS Event
            uint32_t ext_ns_irq_to_s_irq : 1; // NCU MCU S x NS Interrupt
            uint32_t ext_s_evnt_to_ns_evnt : 1; // NCU MCU NS x S Event
            uint32_t ext_s_evnt_to_ns_irq : 1; // NCU MCU NS x S Event interrupt upgrade
            uint32_t reserved1 : 20;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_secctlr_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_ns_allowed() const { uint32_t value = static_cast<uint32_t>(bits.ns_allowed); return value;}
    CONSTEXPR void set_ns_allowed(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ns_allowed = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_npu_ns_mode() const { uint32_t value = static_cast<uint32_t>(bits.npu_ns_mode); return value;}
    CONSTEXPR void set_npu_ns_mode(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.npu_ns_mode = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ext_ns_evnt_to_s_evnt() const { uint32_t value = static_cast<uint32_t>(bits.ext_ns_evnt_to_s_evnt); return value;}
    CONSTEXPR void set_ext_ns_evnt_to_s_evnt(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ext_ns_evnt_to_s_evnt = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ext_ns_irq_to_s_irq() const { uint32_t value = static_cast<uint32_t>(bits.ext_ns_irq_to_s_irq); return value;}
    CONSTEXPR void set_ext_ns_irq_to_s_irq(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ext_ns_irq_to_s_irq = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ext_s_evnt_to_ns_evnt() const { uint32_t value = static_cast<uint32_t>(bits.ext_s_evnt_to_ns_evnt); return value;}
    CONSTEXPR void set_ext_s_evnt_to_ns_evnt(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ext_s_evnt_to_ns_evnt = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ext_s_evnt_to_ns_irq() const { uint32_t value = static_cast<uint32_t>(bits.ext_s_evnt_to_ns_irq); return value;}
    CONSTEXPR void set_ext_s_evnt_to_ns_irq(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ext_s_evnt_to_ns_irq = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_secmcuctlr_r - NCU MCU security state control
//
struct dl1_secmcuctlr_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mcu_state : 1; // NCU MCU security state
            uint32_t reserved0 : 31;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_secmcuctlr_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mcu_state() const { uint32_t value = static_cast<uint32_t>(bits.mcu_state); return value;}
    CONSTEXPR void set_mcu_state(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mcu_state = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_sysctlr0_r - System control 0 - MCU Control and Status
//
struct dl1_sysctlr0_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t cpuwait : 1; // MCU CPUWAIT input
            uint32_t lockup : 1; // MCU LOCKUP output
            uint32_t halted : 1; // MCU HALTED output
            uint32_t rstreq : 1; // MCU SYSRESETREQ output
            uint32_t sleeping : 1; // MCU SLEEPING and TRCENA output
            uint32_t reserved0 : 2;
            uint32_t initvtor : 22; // MCU Vector Table address
            uint32_t soft_rstreq : 2; // Soft reset request
            uint32_t hard_rstreq : 1; // Hard reset request
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_sysctlr0_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_cpuwait() const { uint32_t value = static_cast<uint32_t>(bits.cpuwait); return value;}
    CONSTEXPR void set_cpuwait(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.cpuwait = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_lockup() const { uint32_t value = static_cast<uint32_t>(bits.lockup); return value;}
    CONSTEXPR void set_lockup(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.lockup = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_halted() const { uint32_t value = static_cast<uint32_t>(bits.halted); return value;}
    CONSTEXPR void set_halted(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.halted = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_rstreq() const { uint32_t value = static_cast<uint32_t>(bits.rstreq); return value;}
    CONSTEXPR void set_rstreq(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.rstreq = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_sleeping() const { uint32_t value = static_cast<uint32_t>(bits.sleeping); return value;}
    CONSTEXPR void set_sleeping(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.sleeping = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_initvtor() const { uint32_t value = static_cast<uint32_t>(bits.initvtor); return value;}
    CONSTEXPR void set_initvtor(uint32_t value) { assert(static_cast<uint32_t>(value) < 4194304u); bits.initvtor = static_cast<uint32_t>(value); }
    CONSTEXPR soft_reset_t get_soft_rstreq() const { soft_reset_t value = static_cast<soft_reset_t>(bits.soft_rstreq); return value;}
    CONSTEXPR void set_soft_rstreq(soft_reset_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.soft_rstreq = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_hard_rstreq() const { uint32_t value = static_cast<uint32_t>(bits.hard_rstreq); return value;}
    CONSTEXPR void set_hard_rstreq(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.hard_rstreq = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_sysctlr1_r - System control 1 - Event Control
//
struct dl1_sysctlr1_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t reserved0 : 4;
            uint32_t mcu_setevnt : 1; // MCU SET event
            uint32_t mcu_setirq : 1; // MCU SET interrupt
            uint32_t mcu_gpevnt : 1; // MCU GP event
            uint32_t reserved1 : 1;
            uint32_t tsu_evnt : 1; // TSU event
            uint32_t tsu_irq : 1; // TSU interrupt
            uint32_t tsu_dbg : 1; // TSU debug request
            uint32_t reserved2 : 5;
            uint32_t txev_ple : 1; // MCU TXEV sent to PLE
            uint32_t reserved3 : 1;
            uint32_t txev_dbg : 1; // MCU TXEV sent to Host
            uint32_t rxev_degroup : 1; // Degroup PLE TXEV sent to MCU
            uint32_t rxev_evnt : 1; // PLE TXEV sent to MCU
            uint32_t rxev_irq : 1; // PLE TXEV triggers MCU interrupt
            uint32_t reserved4 : 2;
            uint32_t pmu_evnt : 1; // PMU counter overflow event
            uint32_t pmu_irq : 1; // PMU counter overflow interrupt
            uint32_t pmu_dbg : 1; // PMU counter overflow debug request
            uint32_t pmu_eng : 1; // PMU engine counter overflow request
            uint32_t err_tolr_evnt : 1; // Tolerable error triggers MCU event
            uint32_t err_tolr_irq : 1; // Tolerable error triggers MCU interrupt
            uint32_t err_func_irq : 1; // Functional error triggers MCU interrupt
            uint32_t err_recv_irq : 1; // Recoverable error triggers MCU interrupt
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_sysctlr1_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mcu_setevnt() const { uint32_t value = static_cast<uint32_t>(bits.mcu_setevnt); return value;}
    CONSTEXPR void set_mcu_setevnt(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mcu_setevnt = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mcu_setirq() const { uint32_t value = static_cast<uint32_t>(bits.mcu_setirq); return value;}
    CONSTEXPR void set_mcu_setirq(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mcu_setirq = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mcu_gpevnt() const { uint32_t value = static_cast<uint32_t>(bits.mcu_gpevnt); return value;}
    CONSTEXPR void set_mcu_gpevnt(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mcu_gpevnt = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_tsu_evnt() const { uint32_t value = static_cast<uint32_t>(bits.tsu_evnt); return value;}
    CONSTEXPR void set_tsu_evnt(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.tsu_evnt = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_tsu_irq() const { uint32_t value = static_cast<uint32_t>(bits.tsu_irq); return value;}
    CONSTEXPR void set_tsu_irq(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.tsu_irq = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_tsu_dbg() const { uint32_t value = static_cast<uint32_t>(bits.tsu_dbg); return value;}
    CONSTEXPR void set_tsu_dbg(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.tsu_dbg = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_txev_ple() const { uint32_t value = static_cast<uint32_t>(bits.txev_ple); return value;}
    CONSTEXPR void set_txev_ple(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.txev_ple = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_txev_dbg() const { uint32_t value = static_cast<uint32_t>(bits.txev_dbg); return value;}
    CONSTEXPR void set_txev_dbg(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.txev_dbg = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_rxev_degroup() const { uint32_t value = static_cast<uint32_t>(bits.rxev_degroup); return value;}
    CONSTEXPR void set_rxev_degroup(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.rxev_degroup = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_rxev_evnt() const { uint32_t value = static_cast<uint32_t>(bits.rxev_evnt); return value;}
    CONSTEXPR void set_rxev_evnt(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.rxev_evnt = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_rxev_irq() const { uint32_t value = static_cast<uint32_t>(bits.rxev_irq); return value;}
    CONSTEXPR void set_rxev_irq(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.rxev_irq = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_pmu_evnt() const { uint32_t value = static_cast<uint32_t>(bits.pmu_evnt); return value;}
    CONSTEXPR void set_pmu_evnt(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.pmu_evnt = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_pmu_irq() const { uint32_t value = static_cast<uint32_t>(bits.pmu_irq); return value;}
    CONSTEXPR void set_pmu_irq(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.pmu_irq = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_pmu_dbg() const { uint32_t value = static_cast<uint32_t>(bits.pmu_dbg); return value;}
    CONSTEXPR void set_pmu_dbg(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.pmu_dbg = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_pmu_eng() const { uint32_t value = static_cast<uint32_t>(bits.pmu_eng); return value;}
    CONSTEXPR void set_pmu_eng(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.pmu_eng = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_err_tolr_evnt() const { uint32_t value = static_cast<uint32_t>(bits.err_tolr_evnt); return value;}
    CONSTEXPR void set_err_tolr_evnt(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.err_tolr_evnt = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_err_tolr_irq() const { uint32_t value = static_cast<uint32_t>(bits.err_tolr_irq); return value;}
    CONSTEXPR void set_err_tolr_irq(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.err_tolr_irq = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_err_func_irq() const { uint32_t value = static_cast<uint32_t>(bits.err_func_irq); return value;}
    CONSTEXPR void set_err_func_irq(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.err_func_irq = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_err_recv_irq() const { uint32_t value = static_cast<uint32_t>(bits.err_recv_irq); return value;}
    CONSTEXPR void set_err_recv_irq(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.err_recv_irq = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_pwrctlr_r - Power Control
//
struct dl1_pwrctlr_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t active : 1; // NPU activity state
            uint32_t qreqn : 1; // Value of CLK Q-channel QREQn
            uint32_t reserved0 : 30;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_pwrctlr_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_active() const { uint32_t value = static_cast<uint32_t>(bits.active); return value;}
    CONSTEXPR void set_active(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.active = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_qreqn() const { uint32_t value = static_cast<uint32_t>(bits.qreqn); return value;}
    CONSTEXPR void set_qreqn(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.qreqn = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_auxctlr_r - Auxiliary Control
//
struct dl1_auxctlr_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t dis_clkgate : 1; // Disable clock gating
            uint32_t dis_qdeny : 1; // Q-channel FSM deny control
            uint32_t dis_edgeirq : 1; // Change sensitivity of DEBUG and JOB IRQs
            uint32_t dis_mcu_unique_rid : 1; // Disable MCU logic enforcing unique RIDs
            uint32_t dis_stshtrnsltn : 1; // Disable StashTranslation transactions
            uint32_t reserved0 : 2;
            uint32_t increase_outstanding_writes : 1; // Increase outstanding master write transactions
            uint32_t dbgen : 1; // Invasive debug enable
            uint32_t niden : 1; // Non-invasive debug enable
            uint32_t reserved1 : 2;
            uint32_t dis_ext_err_unrecoverable : 1; // Disable ext err irq for unrecoverable errors
            uint32_t dis_ext_err_recoverable : 1; // Disable ext err irq for recoverable errors
            uint32_t dis_ext_err_functional : 1; // Disable ext err irq for functional errors
            uint32_t dis_ext_err_tolerable : 1; // Disable ext debug irq for tolerable errors
            uint32_t dis_non_broadcast_global_err : 1; // Disable non broadcast global errors
            uint32_t en_ple_block_done : 1; // Enable detection in TSU of PLE_BLOCK_DONE events indicated by engines.
            uint32_t mac_ramp_cycles : 2; // Number of ramp cycles when the MAC units transition between idle and active states.
            uint32_t snoop_dis : 1; // Disable external snooping of internal signals
            uint32_t wd_ramp_dis : 1; // Disable weight decoder ramping
            uint32_t reserved2 : 2;
            uint32_t stash_ahead : 4; // Number of 4kB pages to automatically read ahead for each of read and write before the corresponding DMA accesses
            uint32_t stash_issue : 4; // Issuing capacity for StashTranslation transactions
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_auxctlr_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_dis_clkgate() const { uint32_t value = static_cast<uint32_t>(bits.dis_clkgate); return value;}
    CONSTEXPR void set_dis_clkgate(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.dis_clkgate = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_dis_qdeny() const { uint32_t value = static_cast<uint32_t>(bits.dis_qdeny); return value;}
    CONSTEXPR void set_dis_qdeny(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.dis_qdeny = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_dis_edgeirq() const { uint32_t value = static_cast<uint32_t>(bits.dis_edgeirq); return value;}
    CONSTEXPR void set_dis_edgeirq(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.dis_edgeirq = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_dis_mcu_unique_rid() const { uint32_t value = static_cast<uint32_t>(bits.dis_mcu_unique_rid); return value;}
    CONSTEXPR void set_dis_mcu_unique_rid(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.dis_mcu_unique_rid = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_dis_stshtrnsltn() const { uint32_t value = static_cast<uint32_t>(bits.dis_stshtrnsltn); return value;}
    CONSTEXPR void set_dis_stshtrnsltn(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.dis_stshtrnsltn = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_increase_outstanding_writes() const { uint32_t value = static_cast<uint32_t>(bits.increase_outstanding_writes); return value;}
    CONSTEXPR void set_increase_outstanding_writes(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.increase_outstanding_writes = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_dbgen() const { uint32_t value = static_cast<uint32_t>(bits.dbgen); return value;}
    CONSTEXPR void set_dbgen(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.dbgen = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_niden() const { uint32_t value = static_cast<uint32_t>(bits.niden); return value;}
    CONSTEXPR void set_niden(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.niden = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_dis_ext_err_unrecoverable() const { uint32_t value = static_cast<uint32_t>(bits.dis_ext_err_unrecoverable); return value;}
    CONSTEXPR void set_dis_ext_err_unrecoverable(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.dis_ext_err_unrecoverable = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_dis_ext_err_recoverable() const { uint32_t value = static_cast<uint32_t>(bits.dis_ext_err_recoverable); return value;}
    CONSTEXPR void set_dis_ext_err_recoverable(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.dis_ext_err_recoverable = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_dis_ext_err_functional() const { uint32_t value = static_cast<uint32_t>(bits.dis_ext_err_functional); return value;}
    CONSTEXPR void set_dis_ext_err_functional(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.dis_ext_err_functional = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_dis_ext_err_tolerable() const { uint32_t value = static_cast<uint32_t>(bits.dis_ext_err_tolerable); return value;}
    CONSTEXPR void set_dis_ext_err_tolerable(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.dis_ext_err_tolerable = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_dis_non_broadcast_global_err() const { uint32_t value = static_cast<uint32_t>(bits.dis_non_broadcast_global_err); return value;}
    CONSTEXPR void set_dis_non_broadcast_global_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.dis_non_broadcast_global_err = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_en_ple_block_done() const { uint32_t value = static_cast<uint32_t>(bits.en_ple_block_done); return value;}
    CONSTEXPR void set_en_ple_block_done(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.en_ple_block_done = static_cast<uint32_t>(value); }
    CONSTEXPR mac_ramp_t get_mac_ramp_cycles() const { mac_ramp_t value = static_cast<mac_ramp_t>(bits.mac_ramp_cycles); return value;}
    CONSTEXPR void set_mac_ramp_cycles(mac_ramp_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.mac_ramp_cycles = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_snoop_dis() const { uint32_t value = static_cast<uint32_t>(bits.snoop_dis); return value;}
    CONSTEXPR void set_snoop_dis(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.snoop_dis = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_wd_ramp_dis() const { uint32_t value = static_cast<uint32_t>(bits.wd_ramp_dis); return value;}
    CONSTEXPR void set_wd_ramp_dis(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.wd_ramp_dis = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_stash_ahead() const { uint32_t value = static_cast<uint32_t>(bits.stash_ahead); return value;}
    CONSTEXPR void set_stash_ahead(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.stash_ahead = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_stash_issue() const { uint32_t value = static_cast<uint32_t>(bits.stash_issue); return value;}
    CONSTEXPR void set_stash_issue(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.stash_issue = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_setirq_ext_r - Set external interrupts (to host)
//
struct dl1_setirq_ext_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t err : 1; // Host error interrupt set request (level-sensitive to host)
            uint32_t debug : 1; // Host debug interrupt set request
            uint32_t job : 1; // Host job interrupt set request
            uint32_t reserved0 : 29;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_setirq_ext_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_err() const { uint32_t value = static_cast<uint32_t>(bits.err); return value;}
    CONSTEXPR void set_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.err = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_debug() const { uint32_t value = static_cast<uint32_t>(bits.debug); return value;}
    CONSTEXPR void set_debug(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.debug = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_job() const { uint32_t value = static_cast<uint32_t>(bits.job); return value;}
    CONSTEXPR void set_job(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.job = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_clrirq_ext_r - Clear external interrupts (to host)
//
struct dl1_clrirq_ext_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t err : 1; // Host error interrupt clear request
            uint32_t debug : 1; // Host debug interrupt clear request
            uint32_t job : 1; // Host job interrupt clear request
            uint32_t reserved0 : 29;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_clrirq_ext_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_err() const { uint32_t value = static_cast<uint32_t>(bits.err); return value;}
    CONSTEXPR void set_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.err = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_debug() const { uint32_t value = static_cast<uint32_t>(bits.debug); return value;}
    CONSTEXPR void set_debug(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.debug = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_job() const { uint32_t value = static_cast<uint32_t>(bits.job); return value;}
    CONSTEXPR void set_job(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.job = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_setirq_int_r - Raise internal interrupts and events
//
struct dl1_setirq_int_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t reserved0 : 4;
            uint32_t event : 1; // MCU event (edge-sensitive to MCU'S RXEV pin)
            uint32_t interrupt : 1; // MCU interrupt (edge-sensitive to MCU's IRQ pin)
            uint32_t reserved1 : 1;
            uint32_t nmi : 1; // MCU interrupt (edge-sensitive to MCU's NMI pin)
            uint32_t reserved2 : 24;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_setirq_int_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_event() const { uint32_t value = static_cast<uint32_t>(bits.event); return value;}
    CONSTEXPR void set_event(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.event = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_interrupt() const { uint32_t value = static_cast<uint32_t>(bits.interrupt); return value;}
    CONSTEXPR void set_interrupt(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.interrupt = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_nmi() const { uint32_t value = static_cast<uint32_t>(bits.nmi); return value;}
    CONSTEXPR void set_nmi(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.nmi = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_dfc_slv_ord_r - DFC Slave Outstanding Reads
//
struct dl1_dfc_slv_ord_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t out_reads : 8; // Outstanding read transaction count
            uint32_t reserved0 : 24;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_dfc_slv_ord_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_out_reads() const { uint32_t value = static_cast<uint32_t>(bits.out_reads); return value;}
    CONSTEXPR void set_out_reads(uint32_t value) { assert(static_cast<uint32_t>(value) < 256u); bits.out_reads = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_dfc_slv_owr_r - DFC Slave Outstanding Writes
//
struct dl1_dfc_slv_owr_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t out_writes : 8; // Outstanding write transaction count
            uint32_t reserved0 : 24;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_dfc_slv_owr_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_out_writes() const { uint32_t value = static_cast<uint32_t>(bits.out_writes); return value;}
    CONSTEXPR void set_out_writes(uint32_t value) { assert(static_cast<uint32_t>(value) < 256u); bits.out_writes = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_dfc_mst_ord_r - DFC Master Outstanding Reads
//
struct dl1_dfc_mst_ord_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t out_reads : 8; // Outstanding read transaction count
            uint32_t reserved0 : 24;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_dfc_mst_ord_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_out_reads() const { uint32_t value = static_cast<uint32_t>(bits.out_reads); return value;}
    CONSTEXPR void set_out_reads(uint32_t value) { assert(static_cast<uint32_t>(value) < 256u); bits.out_reads = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_dfc_mst_owr_r - DFC Master Outstanding Writes
//
struct dl1_dfc_mst_owr_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t out_writes : 8; // Outstanding write transaction count
            uint32_t reserved0 : 24;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_dfc_mst_owr_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_out_writes() const { uint32_t value = static_cast<uint32_t>(bits.out_writes); return value;}
    CONSTEXPR void set_out_writes(uint32_t value) { assert(static_cast<uint32_t>(value) < 256u); bits.out_writes = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_irq_status_r - Status register used by the Host system
//
struct dl1_irq_status_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t setirq_err : 1; // ERR interrupt caused by SETIRQ
            uint32_t setirq_dbg : 1; // DEBUG interrupt caused by SETIRQ
            uint32_t setirq_job : 1; // JOB interrupt caused by SETIRQ
            uint32_t reserved0 : 7;
            uint32_t tsu_dbg : 1; // DEBUG interrupt caused by TSU
            uint32_t reserved1 : 15;
            uint32_t pmu_dbg : 1; // DEBUG interrupt caused by top-level PMU
            uint32_t pmu_eng : 1; // DEBUG interrupt caused by engine-level PMU
            uint32_t tol_err : 1; // Tolerable error
            uint32_t func_err : 1; // Functional error
            uint32_t rec_err : 1; // Recoverable error
            uint32_t unrec_err : 1; // Unrecoverable error
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_irq_status_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_setirq_err() const { uint32_t value = static_cast<uint32_t>(bits.setirq_err); return value;}
    CONSTEXPR void set_setirq_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.setirq_err = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_setirq_dbg() const { uint32_t value = static_cast<uint32_t>(bits.setirq_dbg); return value;}
    CONSTEXPR void set_setirq_dbg(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.setirq_dbg = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_setirq_job() const { uint32_t value = static_cast<uint32_t>(bits.setirq_job); return value;}
    CONSTEXPR void set_setirq_job(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.setirq_job = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_tsu_dbg() const { uint32_t value = static_cast<uint32_t>(bits.tsu_dbg); return value;}
    CONSTEXPR void set_tsu_dbg(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.tsu_dbg = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_pmu_dbg() const { uint32_t value = static_cast<uint32_t>(bits.pmu_dbg); return value;}
    CONSTEXPR void set_pmu_dbg(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.pmu_dbg = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_pmu_eng() const { uint32_t value = static_cast<uint32_t>(bits.pmu_eng); return value;}
    CONSTEXPR void set_pmu_eng(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.pmu_eng = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_tol_err() const { uint32_t value = static_cast<uint32_t>(bits.tol_err); return value;}
    CONSTEXPR void set_tol_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.tol_err = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_func_err() const { uint32_t value = static_cast<uint32_t>(bits.func_err); return value;}
    CONSTEXPR void set_func_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.func_err = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_rec_err() const { uint32_t value = static_cast<uint32_t>(bits.rec_err); return value;}
    CONSTEXPR void set_rec_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.rec_err = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_unrec_err() const { uint32_t value = static_cast<uint32_t>(bits.unrec_err); return value;}
    CONSTEXPR void set_unrec_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.unrec_err = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_int_status_r - Internal status register used by the NCU's MCU
//
struct dl1_int_status_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t reserved0 : 8;
            uint32_t tsu_evnt : 1; // Event caused by TSU
            uint32_t tsu_irq : 1; // Interrupt caused by TSU
            uint32_t reserved1 : 10;
            uint32_t rxev_evnt : 1; // Event caused by PLE's SEV
            uint32_t rxev_irq : 1; // Interrupt caused by PLE's SEV
            uint32_t reserved2 : 2;
            uint32_t pmu_evnt : 1; // Event caused by PMU overflow
            uint32_t pmu_irq : 1; // Interrupt caused by PMU overflow
            uint32_t reserved3 : 1;
            uint32_t pmu_eng : 1; // Event or interrupt caused by engine PMU
            uint32_t tol_err : 1; // Tolerable error
            uint32_t func_err : 1; // Functional error
            uint32_t rec_err : 1; // Recoverable error
            uint32_t unrec_err : 1; // Unrecoverable error
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_int_status_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_tsu_evnt() const { uint32_t value = static_cast<uint32_t>(bits.tsu_evnt); return value;}
    CONSTEXPR void set_tsu_evnt(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.tsu_evnt = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_tsu_irq() const { uint32_t value = static_cast<uint32_t>(bits.tsu_irq); return value;}
    CONSTEXPR void set_tsu_irq(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.tsu_irq = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_rxev_evnt() const { uint32_t value = static_cast<uint32_t>(bits.rxev_evnt); return value;}
    CONSTEXPR void set_rxev_evnt(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.rxev_evnt = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_rxev_irq() const { uint32_t value = static_cast<uint32_t>(bits.rxev_irq); return value;}
    CONSTEXPR void set_rxev_irq(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.rxev_irq = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_pmu_evnt() const { uint32_t value = static_cast<uint32_t>(bits.pmu_evnt); return value;}
    CONSTEXPR void set_pmu_evnt(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.pmu_evnt = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_pmu_irq() const { uint32_t value = static_cast<uint32_t>(bits.pmu_irq); return value;}
    CONSTEXPR void set_pmu_irq(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.pmu_irq = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_pmu_eng() const { uint32_t value = static_cast<uint32_t>(bits.pmu_eng); return value;}
    CONSTEXPR void set_pmu_eng(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.pmu_eng = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_tol_err() const { uint32_t value = static_cast<uint32_t>(bits.tol_err); return value;}
    CONSTEXPR void set_tol_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.tol_err = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_func_err() const { uint32_t value = static_cast<uint32_t>(bits.func_err); return value;}
    CONSTEXPR void set_func_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.func_err = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_rec_err() const { uint32_t value = static_cast<uint32_t>(bits.rec_err); return value;}
    CONSTEXPR void set_rec_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.rec_err = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_unrec_err() const { uint32_t value = static_cast<uint32_t>(bits.unrec_err); return value;}
    CONSTEXPR void set_unrec_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.unrec_err = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_ext_status_r - External status register used by the NCU's MCU
//
struct dl1_ext_status_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t reserved0 : 4;
            uint32_t setirq_evnt : 1; // Event caused by SETIRQ_INT
            uint32_t setirq_irq : 1; // Interrupt caused by SETIRQ_INT
            uint32_t gp_evnt : 1; // Event caused by host write to GPreg
            uint32_t reserved1 : 25;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_ext_status_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_setirq_evnt() const { uint32_t value = static_cast<uint32_t>(bits.setirq_evnt); return value;}
    CONSTEXPR void set_setirq_evnt(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.setirq_evnt = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_setirq_irq() const { uint32_t value = static_cast<uint32_t>(bits.setirq_irq); return value;}
    CONSTEXPR void set_setirq_irq(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.setirq_irq = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_gp_evnt() const { uint32_t value = static_cast<uint32_t>(bits.gp_evnt); return value;}
    CONSTEXPR void set_gp_evnt(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.gp_evnt = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_gp0_r - General purpose register 0
//
struct dl1_gp0_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t gp0 : 32; // General purpose register 0
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_gp0_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_gp0() const { uint32_t value = static_cast<uint32_t>(bits.gp0); return value;}
    CONSTEXPR void set_gp0(uint32_t value) { bits.gp0 = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_gp1_r - General purpose register 1
//
struct dl1_gp1_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t gp1 : 32; // General purpose register 1
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_gp1_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_gp1() const { uint32_t value = static_cast<uint32_t>(bits.gp1); return value;}
    CONSTEXPR void set_gp1(uint32_t value) { bits.gp1 = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_gp2_r - General purpose register 2
//
struct dl1_gp2_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t gp2 : 32; // General purpose register 2
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_gp2_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_gp2() const { uint32_t value = static_cast<uint32_t>(bits.gp2); return value;}
    CONSTEXPR void set_gp2(uint32_t value) { bits.gp2 = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_gp3_r - General purpose register 3
//
struct dl1_gp3_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t gp3 : 32; // General purpose register 3
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_gp3_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_gp3() const { uint32_t value = static_cast<uint32_t>(bits.gp3); return value;}
    CONSTEXPR void set_gp3(uint32_t value) { bits.gp3 = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_gp4_r - General purpose register 4
//
struct dl1_gp4_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t gp4 : 32; // General purpose register 4
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_gp4_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_gp4() const { uint32_t value = static_cast<uint32_t>(bits.gp4); return value;}
    CONSTEXPR void set_gp4(uint32_t value) { bits.gp4 = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_gp5_r - General purpose register 5
//
struct dl1_gp5_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t gp5 : 32; // General purpose register 5
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_gp5_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_gp5() const { uint32_t value = static_cast<uint32_t>(bits.gp5); return value;}
    CONSTEXPR void set_gp5(uint32_t value) { bits.gp5 = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_gp6_r - General purpose register 6
//
struct dl1_gp6_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t gp6 : 32; // General purpose register 6
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_gp6_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_gp6() const { uint32_t value = static_cast<uint32_t>(bits.gp6); return value;}
    CONSTEXPR void set_gp6(uint32_t value) { bits.gp6 = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_gp7_r - General purpose register 7
//
struct dl1_gp7_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t gp7 : 32; // General purpose register 7
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_gp7_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_gp7() const { uint32_t value = static_cast<uint32_t>(bits.gp7); return value;}
    CONSTEXPR void set_gp7(uint32_t value) { bits.gp7 = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_delegation_stream_security_r - Stream security state control delegation
//
struct dl1_delegation_stream_security_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusecsid0 : 1; // Delegation bit for stream 0 MMUSECSID register
            uint32_t protns0 : 1; // Delegation bit for stream 0 PROTNS register
            uint32_t mmusecsid1 : 1; // Delegation bit for stream 1 MMUSECSID register
            uint32_t protns1 : 1; // Delegation bit for stream 1 PROTNS register
            uint32_t mmusecsid2 : 1; // Delegation bit for stream 2 MMUSECSID register
            uint32_t protns2 : 1; // Delegation bit for stream 2 PROTNS register
            uint32_t mmusecsid3 : 1; // Delegation bit for stream 3 MMUSECSID register
            uint32_t protns3 : 1; // Delegation bit for stream 3 PROTNS register
            uint32_t mmusecsid4 : 1; // Delegation bit for stream 4 MMUSECSID register
            uint32_t protns4 : 1; // Delegation bit for stream 4 PROTNS register
            uint32_t mmusecsid5 : 1; // Delegation bit for stream 5 MMUSECSID register
            uint32_t protns5 : 1; // Delegation bit for stream 5 PROTNS register
            uint32_t mmusecsid6 : 1; // Delegation bit for stream 6 MMUSECSID register
            uint32_t protns6 : 1; // Delegation bit for stream 6 PROTNS register
            uint32_t mmusecsid7 : 1; // Delegation bit for stream 7 MMUSECSID register
            uint32_t protns7 : 1; // Delegation bit for stream 7 PROTNS register
            uint32_t mmusecsid8 : 1; // Delegation bit for stream 8 MMUSECSID register
            uint32_t protns8 : 1; // Delegation bit for stream 8 PROTNS register
            uint32_t reserved0 : 14;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_delegation_stream_security_r(uint32_t init=0) : word(init) {}
    CONSTEXPR delegation_t get_mmusecsid0() const { delegation_t value = static_cast<delegation_t>(bits.mmusecsid0); return value;}
    CONSTEXPR void set_mmusecsid0(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmusecsid0 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_protns0() const { delegation_t value = static_cast<delegation_t>(bits.protns0); return value;}
    CONSTEXPR void set_protns0(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.protns0 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_mmusecsid1() const { delegation_t value = static_cast<delegation_t>(bits.mmusecsid1); return value;}
    CONSTEXPR void set_mmusecsid1(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmusecsid1 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_protns1() const { delegation_t value = static_cast<delegation_t>(bits.protns1); return value;}
    CONSTEXPR void set_protns1(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.protns1 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_mmusecsid2() const { delegation_t value = static_cast<delegation_t>(bits.mmusecsid2); return value;}
    CONSTEXPR void set_mmusecsid2(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmusecsid2 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_protns2() const { delegation_t value = static_cast<delegation_t>(bits.protns2); return value;}
    CONSTEXPR void set_protns2(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.protns2 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_mmusecsid3() const { delegation_t value = static_cast<delegation_t>(bits.mmusecsid3); return value;}
    CONSTEXPR void set_mmusecsid3(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmusecsid3 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_protns3() const { delegation_t value = static_cast<delegation_t>(bits.protns3); return value;}
    CONSTEXPR void set_protns3(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.protns3 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_mmusecsid4() const { delegation_t value = static_cast<delegation_t>(bits.mmusecsid4); return value;}
    CONSTEXPR void set_mmusecsid4(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmusecsid4 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_protns4() const { delegation_t value = static_cast<delegation_t>(bits.protns4); return value;}
    CONSTEXPR void set_protns4(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.protns4 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_mmusecsid5() const { delegation_t value = static_cast<delegation_t>(bits.mmusecsid5); return value;}
    CONSTEXPR void set_mmusecsid5(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmusecsid5 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_protns5() const { delegation_t value = static_cast<delegation_t>(bits.protns5); return value;}
    CONSTEXPR void set_protns5(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.protns5 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_mmusecsid6() const { delegation_t value = static_cast<delegation_t>(bits.mmusecsid6); return value;}
    CONSTEXPR void set_mmusecsid6(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmusecsid6 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_protns6() const { delegation_t value = static_cast<delegation_t>(bits.protns6); return value;}
    CONSTEXPR void set_protns6(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.protns6 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_mmusecsid7() const { delegation_t value = static_cast<delegation_t>(bits.mmusecsid7); return value;}
    CONSTEXPR void set_mmusecsid7(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmusecsid7 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_protns7() const { delegation_t value = static_cast<delegation_t>(bits.protns7); return value;}
    CONSTEXPR void set_protns7(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.protns7 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_mmusecsid8() const { delegation_t value = static_cast<delegation_t>(bits.mmusecsid8); return value;}
    CONSTEXPR void set_mmusecsid8(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmusecsid8 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_protns8() const { delegation_t value = static_cast<delegation_t>(bits.protns8); return value;}
    CONSTEXPR void set_protns8(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.protns8 = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_delegation_nsaid_r - Non-secure Access Identifier delegation
//
struct dl1_delegation_nsaid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t nsaid0 : 1; // Delegation bit for stream 0 NSAID register
            uint32_t reserved0 : 1;
            uint32_t nsaid1 : 1; // Delegation bit for stream 1 NSAID register
            uint32_t reserved1 : 1;
            uint32_t nsaid2 : 1; // Delegation bit for stream 2 NSAID register
            uint32_t reserved2 : 1;
            uint32_t nsaid3 : 1; // Delegation bit for stream 3 NSAID register
            uint32_t reserved3 : 1;
            uint32_t nsaid4 : 1; // Delegation bit for stream 4 NSAID register
            uint32_t reserved4 : 1;
            uint32_t nsaid5 : 1; // Delegation bit for stream 5 NSAID register
            uint32_t reserved5 : 1;
            uint32_t nsaid6 : 1; // Delegation bit for stream 6 NSAID register
            uint32_t reserved6 : 1;
            uint32_t nsaid7 : 1; // Delegation bit for stream 7 NSAID register
            uint32_t reserved7 : 1;
            uint32_t nsaid8 : 1; // Delegation bit for stream 8 NSAID register
            uint32_t reserved8 : 15;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_delegation_nsaid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR delegation_t get_nsaid0() const { delegation_t value = static_cast<delegation_t>(bits.nsaid0); return value;}
    CONSTEXPR void set_nsaid0(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.nsaid0 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_nsaid1() const { delegation_t value = static_cast<delegation_t>(bits.nsaid1); return value;}
    CONSTEXPR void set_nsaid1(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.nsaid1 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_nsaid2() const { delegation_t value = static_cast<delegation_t>(bits.nsaid2); return value;}
    CONSTEXPR void set_nsaid2(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.nsaid2 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_nsaid3() const { delegation_t value = static_cast<delegation_t>(bits.nsaid3); return value;}
    CONSTEXPR void set_nsaid3(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.nsaid3 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_nsaid4() const { delegation_t value = static_cast<delegation_t>(bits.nsaid4); return value;}
    CONSTEXPR void set_nsaid4(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.nsaid4 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_nsaid5() const { delegation_t value = static_cast<delegation_t>(bits.nsaid5); return value;}
    CONSTEXPR void set_nsaid5(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.nsaid5 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_nsaid6() const { delegation_t value = static_cast<delegation_t>(bits.nsaid6); return value;}
    CONSTEXPR void set_nsaid6(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.nsaid6 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_nsaid7() const { delegation_t value = static_cast<delegation_t>(bits.nsaid7); return value;}
    CONSTEXPR void set_nsaid7(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.nsaid7 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_nsaid8() const { delegation_t value = static_cast<delegation_t>(bits.nsaid8); return value;}
    CONSTEXPR void set_nsaid8(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.nsaid8 = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_delegation_mmusid_r - MMU Stream Identifier delegation
//
struct dl1_delegation_mmusid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t sid0 : 2; // Delegation bit for stream 0 MMUSID register
            uint32_t sid1 : 2; // Delegation bit for stream 1 MMUSID register
            uint32_t sid2 : 2; // Delegation bit for stream 2 MMUSID register
            uint32_t sid3 : 2; // Delegation bit for stream 3 MMUSID register
            uint32_t sid4 : 2; // Delegation bit for stream 4 MMUSID register
            uint32_t sid5 : 2; // Delegation bit for stream 5 MMUSID register
            uint32_t sid6 : 2; // Delegation bit for stream 6 MMUSID register
            uint32_t sid7 : 2; // Delegation bit for stream 7 MMUSID register
            uint32_t sid8 : 2; // Delegation bit for stream 8 MMUSID register
            uint32_t reserved0 : 14;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_delegation_mmusid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR streamid_delegation_t get_sid0() const { streamid_delegation_t value = static_cast<streamid_delegation_t>(bits.sid0); return value;}
    CONSTEXPR void set_sid0(streamid_delegation_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.sid0 = static_cast<uint32_t>(value); }
    CONSTEXPR streamid_delegation_t get_sid1() const { streamid_delegation_t value = static_cast<streamid_delegation_t>(bits.sid1); return value;}
    CONSTEXPR void set_sid1(streamid_delegation_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.sid1 = static_cast<uint32_t>(value); }
    CONSTEXPR streamid_delegation_t get_sid2() const { streamid_delegation_t value = static_cast<streamid_delegation_t>(bits.sid2); return value;}
    CONSTEXPR void set_sid2(streamid_delegation_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.sid2 = static_cast<uint32_t>(value); }
    CONSTEXPR streamid_delegation_t get_sid3() const { streamid_delegation_t value = static_cast<streamid_delegation_t>(bits.sid3); return value;}
    CONSTEXPR void set_sid3(streamid_delegation_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.sid3 = static_cast<uint32_t>(value); }
    CONSTEXPR streamid_delegation_t get_sid4() const { streamid_delegation_t value = static_cast<streamid_delegation_t>(bits.sid4); return value;}
    CONSTEXPR void set_sid4(streamid_delegation_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.sid4 = static_cast<uint32_t>(value); }
    CONSTEXPR streamid_delegation_t get_sid5() const { streamid_delegation_t value = static_cast<streamid_delegation_t>(bits.sid5); return value;}
    CONSTEXPR void set_sid5(streamid_delegation_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.sid5 = static_cast<uint32_t>(value); }
    CONSTEXPR streamid_delegation_t get_sid6() const { streamid_delegation_t value = static_cast<streamid_delegation_t>(bits.sid6); return value;}
    CONSTEXPR void set_sid6(streamid_delegation_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.sid6 = static_cast<uint32_t>(value); }
    CONSTEXPR streamid_delegation_t get_sid7() const { streamid_delegation_t value = static_cast<streamid_delegation_t>(bits.sid7); return value;}
    CONSTEXPR void set_sid7(streamid_delegation_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.sid7 = static_cast<uint32_t>(value); }
    CONSTEXPR streamid_delegation_t get_sid8() const { streamid_delegation_t value = static_cast<streamid_delegation_t>(bits.sid8); return value;}
    CONSTEXPR void set_sid8(streamid_delegation_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.sid8 = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_delegation_mmussid_r - MMU Sub-stream Stream ID delegation
//
struct dl1_delegation_mmussid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t ssid0 : 2; // Delegation bit for stream 0 MMUSSID register
            uint32_t ssid1 : 2; // Delegation bit for stream 1 MMUSSID register
            uint32_t ssid2 : 2; // Delegation bit for stream 2 MMUSSID register
            uint32_t ssid3 : 2; // Delegation bit for stream 3 MMUSSID register
            uint32_t ssid4 : 2; // Delegation bit for stream 4 MMUSSID register
            uint32_t ssid5 : 2; // Delegation bit for stream 5 MMUSSID register
            uint32_t ssid6 : 2; // Delegation bit for stream 6 MMUSSID register
            uint32_t ssid7 : 2; // Delegation bit for stream 7 MMUSSID register
            uint32_t ssid8 : 2; // Delegation bit for stream 8 MMUSSID register
            uint32_t reserved0 : 14;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_delegation_mmussid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR substreamid_delegation_t get_ssid0() const { substreamid_delegation_t value = static_cast<substreamid_delegation_t>(bits.ssid0); return value;}
    CONSTEXPR void set_ssid0(substreamid_delegation_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.ssid0 = static_cast<uint32_t>(value); }
    CONSTEXPR substreamid_delegation_t get_ssid1() const { substreamid_delegation_t value = static_cast<substreamid_delegation_t>(bits.ssid1); return value;}
    CONSTEXPR void set_ssid1(substreamid_delegation_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.ssid1 = static_cast<uint32_t>(value); }
    CONSTEXPR substreamid_delegation_t get_ssid2() const { substreamid_delegation_t value = static_cast<substreamid_delegation_t>(bits.ssid2); return value;}
    CONSTEXPR void set_ssid2(substreamid_delegation_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.ssid2 = static_cast<uint32_t>(value); }
    CONSTEXPR substreamid_delegation_t get_ssid3() const { substreamid_delegation_t value = static_cast<substreamid_delegation_t>(bits.ssid3); return value;}
    CONSTEXPR void set_ssid3(substreamid_delegation_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.ssid3 = static_cast<uint32_t>(value); }
    CONSTEXPR substreamid_delegation_t get_ssid4() const { substreamid_delegation_t value = static_cast<substreamid_delegation_t>(bits.ssid4); return value;}
    CONSTEXPR void set_ssid4(substreamid_delegation_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.ssid4 = static_cast<uint32_t>(value); }
    CONSTEXPR substreamid_delegation_t get_ssid5() const { substreamid_delegation_t value = static_cast<substreamid_delegation_t>(bits.ssid5); return value;}
    CONSTEXPR void set_ssid5(substreamid_delegation_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.ssid5 = static_cast<uint32_t>(value); }
    CONSTEXPR substreamid_delegation_t get_ssid6() const { substreamid_delegation_t value = static_cast<substreamid_delegation_t>(bits.ssid6); return value;}
    CONSTEXPR void set_ssid6(substreamid_delegation_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.ssid6 = static_cast<uint32_t>(value); }
    CONSTEXPR substreamid_delegation_t get_ssid7() const { substreamid_delegation_t value = static_cast<substreamid_delegation_t>(bits.ssid7); return value;}
    CONSTEXPR void set_ssid7(substreamid_delegation_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.ssid7 = static_cast<uint32_t>(value); }
    CONSTEXPR substreamid_delegation_t get_ssid8() const { substreamid_delegation_t value = static_cast<substreamid_delegation_t>(bits.ssid8); return value;}
    CONSTEXPR void set_ssid8(substreamid_delegation_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.ssid8 = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_delegation_mmussidv_r - MMU Sub-stream Stream IDV delegation
//
struct dl1_delegation_mmussidv_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t ssidv0 : 1; // Delegation bit for stream 0 MMUSSIDV register
            uint32_t ssidv1 : 1; // Delegation bit for stream 1 MMUSSIDV register
            uint32_t ssidv2 : 1; // Delegation bit for stream 2 MMUSSIDV register
            uint32_t ssidv3 : 1; // Delegation bit for stream 3 MMUSSIDV register
            uint32_t ssidv4 : 1; // Delegation bit for stream 4 MMUSSIDV register
            uint32_t ssidv5 : 1; // Delegation bit for stream 5 MMUSSIDV register
            uint32_t ssidv6 : 1; // Delegation bit for stream 6 MMUSSIDV register
            uint32_t ssidv7 : 1; // Delegation bit for stream 7 MMUSSIDV register
            uint32_t ssidv8 : 1; // Delegation bit for stream 8 MMUSSIDV register
            uint32_t reserved0 : 23;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_delegation_mmussidv_r(uint32_t init=0) : word(init) {}
    CONSTEXPR delegation_t get_ssidv0() const { delegation_t value = static_cast<delegation_t>(bits.ssidv0); return value;}
    CONSTEXPR void set_ssidv0(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ssidv0 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_ssidv1() const { delegation_t value = static_cast<delegation_t>(bits.ssidv1); return value;}
    CONSTEXPR void set_ssidv1(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ssidv1 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_ssidv2() const { delegation_t value = static_cast<delegation_t>(bits.ssidv2); return value;}
    CONSTEXPR void set_ssidv2(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ssidv2 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_ssidv3() const { delegation_t value = static_cast<delegation_t>(bits.ssidv3); return value;}
    CONSTEXPR void set_ssidv3(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ssidv3 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_ssidv4() const { delegation_t value = static_cast<delegation_t>(bits.ssidv4); return value;}
    CONSTEXPR void set_ssidv4(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ssidv4 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_ssidv5() const { delegation_t value = static_cast<delegation_t>(bits.ssidv5); return value;}
    CONSTEXPR void set_ssidv5(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ssidv5 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_ssidv6() const { delegation_t value = static_cast<delegation_t>(bits.ssidv6); return value;}
    CONSTEXPR void set_ssidv6(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ssidv6 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_ssidv7() const { delegation_t value = static_cast<delegation_t>(bits.ssidv7); return value;}
    CONSTEXPR void set_ssidv7(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ssidv7 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_ssidv8() const { delegation_t value = static_cast<delegation_t>(bits.ssidv8); return value;}
    CONSTEXPR void set_ssidv8(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ssidv8 = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_delegation_attr_control_r - Attribute Control delegation
//
struct dl1_delegation_attr_control_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t attrctrl0 : 1; // Delegation bit for stream 0 Attribute Control register
            uint32_t attrctrl1 : 1; // Delegation bit for stream 1 Attribute Control register
            uint32_t attrctrl2 : 1; // Delegation bit for stream 2 Attribute Control register
            uint32_t attrctrl3 : 1; // Delegation bit for stream 3 Attribute Control register
            uint32_t attrctrl4 : 1; // Delegation bit for stream 4 Attribute Control register
            uint32_t attrctrl5 : 1; // Delegation bit for stream 5 Attribute Control register
            uint32_t attrctrl6 : 1; // Delegation bit for stream 6 Attribute Control register
            uint32_t attrctrl7 : 1; // Delegation bit for stream 7 Attribute Control register
            uint32_t attrctrl8 : 1; // Delegation bit for stream 8 Attribute Control register
            uint32_t reserved0 : 23;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_delegation_attr_control_r(uint32_t init=0) : word(init) {}
    CONSTEXPR delegation_t get_attrctrl0() const { delegation_t value = static_cast<delegation_t>(bits.attrctrl0); return value;}
    CONSTEXPR void set_attrctrl0(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.attrctrl0 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_attrctrl1() const { delegation_t value = static_cast<delegation_t>(bits.attrctrl1); return value;}
    CONSTEXPR void set_attrctrl1(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.attrctrl1 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_attrctrl2() const { delegation_t value = static_cast<delegation_t>(bits.attrctrl2); return value;}
    CONSTEXPR void set_attrctrl2(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.attrctrl2 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_attrctrl3() const { delegation_t value = static_cast<delegation_t>(bits.attrctrl3); return value;}
    CONSTEXPR void set_attrctrl3(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.attrctrl3 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_attrctrl4() const { delegation_t value = static_cast<delegation_t>(bits.attrctrl4); return value;}
    CONSTEXPR void set_attrctrl4(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.attrctrl4 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_attrctrl5() const { delegation_t value = static_cast<delegation_t>(bits.attrctrl5); return value;}
    CONSTEXPR void set_attrctrl5(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.attrctrl5 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_attrctrl6() const { delegation_t value = static_cast<delegation_t>(bits.attrctrl6); return value;}
    CONSTEXPR void set_attrctrl6(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.attrctrl6 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_attrctrl7() const { delegation_t value = static_cast<delegation_t>(bits.attrctrl7); return value;}
    CONSTEXPR void set_attrctrl7(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.attrctrl7 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_attrctrl8() const { delegation_t value = static_cast<delegation_t>(bits.attrctrl8); return value;}
    CONSTEXPR void set_attrctrl8(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.attrctrl8 = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_delegation_memattr_r - Memory Attributes delegation
//
struct dl1_delegation_memattr_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t memattr0 : 1; // Delegation bit for stream 0 Memory Attributes register
            uint32_t memattr1 : 1; // Delegation bit for stream 1 Memory Attributes register
            uint32_t memattr2 : 1; // Delegation bit for stream 2 Memory Attributes register
            uint32_t memattr3 : 1; // Delegation bit for stream 3 Memory Attributes register
            uint32_t memattr4 : 1; // Delegation bit for stream 4 Memory Attributes register
            uint32_t memattr5 : 1; // Delegation bit for stream 5 Memory Attributes register
            uint32_t memattr6 : 1; // Delegation bit for stream 6 Memory Attributes register
            uint32_t memattr7 : 1; // Delegation bit for stream 7 Memory Attributes register
            uint32_t memattr8 : 1; // Delegation bit for stream 8 Memory Attributes register
            uint32_t reserved0 : 23;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_delegation_memattr_r(uint32_t init=0) : word(init) {}
    CONSTEXPR delegation_t get_memattr0() const { delegation_t value = static_cast<delegation_t>(bits.memattr0); return value;}
    CONSTEXPR void set_memattr0(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.memattr0 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_memattr1() const { delegation_t value = static_cast<delegation_t>(bits.memattr1); return value;}
    CONSTEXPR void set_memattr1(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.memattr1 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_memattr2() const { delegation_t value = static_cast<delegation_t>(bits.memattr2); return value;}
    CONSTEXPR void set_memattr2(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.memattr2 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_memattr3() const { delegation_t value = static_cast<delegation_t>(bits.memattr3); return value;}
    CONSTEXPR void set_memattr3(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.memattr3 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_memattr4() const { delegation_t value = static_cast<delegation_t>(bits.memattr4); return value;}
    CONSTEXPR void set_memattr4(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.memattr4 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_memattr5() const { delegation_t value = static_cast<delegation_t>(bits.memattr5); return value;}
    CONSTEXPR void set_memattr5(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.memattr5 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_memattr6() const { delegation_t value = static_cast<delegation_t>(bits.memattr6); return value;}
    CONSTEXPR void set_memattr6(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.memattr6 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_memattr7() const { delegation_t value = static_cast<delegation_t>(bits.memattr7); return value;}
    CONSTEXPR void set_memattr7(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.memattr7 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_memattr8() const { delegation_t value = static_cast<delegation_t>(bits.memattr8); return value;}
    CONSTEXPR void set_memattr8(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.memattr8 = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_delegation_address_extend_r - Extended address bits control delegation
//
struct dl1_delegation_address_extend_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t addressextend0 : 1; // Delegation bit for stream 0 ADDRESSEXTEND register
            uint32_t reserved0 : 1;
            uint32_t addressextend1 : 1; // Delegation bit for stream 1 ADDRESSEXTEND register
            uint32_t reserved1 : 1;
            uint32_t addressextend2 : 1; // Delegation bit for stream 2 ADDRESSEXTEND register
            uint32_t reserved2 : 27;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_delegation_address_extend_r(uint32_t init=0) : word(init) {}
    CONSTEXPR delegation_t get_addressextend0() const { delegation_t value = static_cast<delegation_t>(bits.addressextend0); return value;}
    CONSTEXPR void set_addressextend0(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.addressextend0 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_addressextend1() const { delegation_t value = static_cast<delegation_t>(bits.addressextend1); return value;}
    CONSTEXPR void set_addressextend1(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.addressextend1 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_addressextend2() const { delegation_t value = static_cast<delegation_t>(bits.addressextend2); return value;}
    CONSTEXPR void set_addressextend2(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.addressextend2 = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_stream0_stream_security_r - Stream 0 - Security State
//
struct dl1_stream0_stream_security_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusecsid : 1; // MMU stream security state
            uint32_t protns : 1; // AXI stream security state
            uint32_t reserved0 : 30;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_stream0_stream_security_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmusecsid() const { uint32_t value = static_cast<uint32_t>(bits.mmusecsid); return value;}
    CONSTEXPR void set_mmusecsid(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmusecsid = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_protns() const { uint32_t value = static_cast<uint32_t>(bits.protns); return value;}
    CONSTEXPR void set_protns(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.protns = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_stream0_nsaid_r - Stream 0 - Non-secure Access Identifier
//
struct dl1_stream0_nsaid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t nsaid : 4; // Non-Secure Address Identifier
            uint32_t reserved0 : 28;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_stream0_nsaid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_nsaid() const { uint32_t value = static_cast<uint32_t>(bits.nsaid); return value;}
    CONSTEXPR void set_nsaid(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.nsaid = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_stream0_mmusid_r - Stream 0 - MMU Stream Identifier
//
struct dl1_stream0_mmusid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusid : 32; // MMU Stream ID (actual width is implementation defined)
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_stream0_mmusid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmusid() const { uint32_t value = static_cast<uint32_t>(bits.mmusid); return value;}
    CONSTEXPR void set_mmusid(uint32_t value) { bits.mmusid = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_stream0_mmussid_r - Stream 0 - MMU Sub-stream Stream Identifier
//
struct dl1_stream0_mmussid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmussid : 20; // MMU Sub-Stream ID (actual width is implementation defined)
            uint32_t reserved0 : 11;
            uint32_t mmussidv : 1; // MMUSSID valid bit
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_stream0_mmussid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmussid() const { uint32_t value = static_cast<uint32_t>(bits.mmussid); return value;}
    CONSTEXPR void set_mmussid(uint32_t value) { assert(static_cast<uint32_t>(value) < 1048576u); bits.mmussid = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mmussidv() const { uint32_t value = static_cast<uint32_t>(bits.mmussidv); return value;}
    CONSTEXPR void set_mmussidv(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmussidv = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_stream0_attr_control_r - Stream 0 - Attribute Control
//
struct dl1_stream0_attr_control_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t attrlocked : 1; // Stream attributes locked
            uint32_t reserved0 : 31;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_stream0_attr_control_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_attrlocked() const { uint32_t value = static_cast<uint32_t>(bits.attrlocked); return value;}
    CONSTEXPR void set_attrlocked(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.attrlocked = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_stream0_memattr_r - Stream 0 - Memory Attributes
//
struct dl1_stream0_memattr_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t memattr : 4; // Memory attributes
            uint32_t reserved0 : 28;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_stream0_memattr_r(uint32_t init=0) : word(init) {}
    CONSTEXPR memory_attributes_t get_memattr() const { memory_attributes_t value = static_cast<memory_attributes_t>(bits.memattr); return value;}
    CONSTEXPR void set_memattr(memory_attributes_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.memattr = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_stream0_address_extend_r - Stream 0 - Extended address bits per stream
//
struct dl1_stream0_address_extend_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t reserved0 : 9;
            uint32_t addrextend : 20; // Address extension bits [48:29]
            uint32_t reserved1 : 3;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_stream0_address_extend_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_addrextend() const { uint32_t value = static_cast<uint32_t>(bits.addrextend); return value;}
    CONSTEXPR void set_addrextend(uint32_t value) { assert(static_cast<uint32_t>(value) < 1048576u); bits.addrextend = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_stream1_stream_security_r - Stream 1 - Security State
//
struct dl1_stream1_stream_security_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusecsid : 1; // MMU stream security state
            uint32_t protns : 1; // AXI stream security state
            uint32_t reserved0 : 30;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_stream1_stream_security_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmusecsid() const { uint32_t value = static_cast<uint32_t>(bits.mmusecsid); return value;}
    CONSTEXPR void set_mmusecsid(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmusecsid = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_protns() const { uint32_t value = static_cast<uint32_t>(bits.protns); return value;}
    CONSTEXPR void set_protns(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.protns = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_stream1_nsaid_r - Stream 1 - Non-secure Access Identifier
//
struct dl1_stream1_nsaid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t nsaid : 4; // Non-Secure Address Identifier
            uint32_t reserved0 : 28;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_stream1_nsaid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_nsaid() const { uint32_t value = static_cast<uint32_t>(bits.nsaid); return value;}
    CONSTEXPR void set_nsaid(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.nsaid = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_stream1_mmusid_r - Stream 1 - MMU Stream Identifier
//
struct dl1_stream1_mmusid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusid : 32; // MMU Stream ID (actual width is implementation defined)
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_stream1_mmusid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmusid() const { uint32_t value = static_cast<uint32_t>(bits.mmusid); return value;}
    CONSTEXPR void set_mmusid(uint32_t value) { bits.mmusid = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_stream1_mmussid_r - Stream 1 - MMU Sub-stream Stream Identifier
//
struct dl1_stream1_mmussid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmussid : 20; // MMU Sub-Stream ID (actual width is implementation defined)
            uint32_t reserved0 : 11;
            uint32_t mmussidv : 1; // MMUSSID valid bit
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_stream1_mmussid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmussid() const { uint32_t value = static_cast<uint32_t>(bits.mmussid); return value;}
    CONSTEXPR void set_mmussid(uint32_t value) { assert(static_cast<uint32_t>(value) < 1048576u); bits.mmussid = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mmussidv() const { uint32_t value = static_cast<uint32_t>(bits.mmussidv); return value;}
    CONSTEXPR void set_mmussidv(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmussidv = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_stream1_attr_control_r - Stream 1 - Attribute Control
//
struct dl1_stream1_attr_control_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t attrlocked : 1; // Stream attributes locked
            uint32_t reserved0 : 31;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_stream1_attr_control_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_attrlocked() const { uint32_t value = static_cast<uint32_t>(bits.attrlocked); return value;}
    CONSTEXPR void set_attrlocked(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.attrlocked = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_stream1_memattr_r - Stream 1 - Memory Attributes
//
struct dl1_stream1_memattr_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t memattr : 4; // Memory attributes
            uint32_t reserved0 : 28;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_stream1_memattr_r(uint32_t init=0) : word(init) {}
    CONSTEXPR memory_attributes_t get_memattr() const { memory_attributes_t value = static_cast<memory_attributes_t>(bits.memattr); return value;}
    CONSTEXPR void set_memattr(memory_attributes_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.memattr = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_stream1_address_extend_r - Stream 1 - Extended address bits per stream
//
struct dl1_stream1_address_extend_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t reserved0 : 9;
            uint32_t addrextend : 20; // Address extension bits [48:29]
            uint32_t reserved1 : 3;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_stream1_address_extend_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_addrextend() const { uint32_t value = static_cast<uint32_t>(bits.addrextend); return value;}
    CONSTEXPR void set_addrextend(uint32_t value) { assert(static_cast<uint32_t>(value) < 1048576u); bits.addrextend = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_stream2_stream_security_r - Stream 2 - Security State
//
struct dl1_stream2_stream_security_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusecsid : 1; // MMU stream security state
            uint32_t protns : 1; // AXI stream security state
            uint32_t reserved0 : 30;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_stream2_stream_security_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmusecsid() const { uint32_t value = static_cast<uint32_t>(bits.mmusecsid); return value;}
    CONSTEXPR void set_mmusecsid(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmusecsid = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_protns() const { uint32_t value = static_cast<uint32_t>(bits.protns); return value;}
    CONSTEXPR void set_protns(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.protns = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_stream2_nsaid_r - Stream 2 - Non-secure Access Identifier
//
struct dl1_stream2_nsaid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t nsaid : 4; // Non-Secure Address Identifier
            uint32_t reserved0 : 28;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_stream2_nsaid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_nsaid() const { uint32_t value = static_cast<uint32_t>(bits.nsaid); return value;}
    CONSTEXPR void set_nsaid(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.nsaid = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_stream2_mmusid_r - Stream 2 - MMU Stream Identifier
//
struct dl1_stream2_mmusid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusid : 32; // MMU Stream ID (actual width is implementation defined)
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_stream2_mmusid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmusid() const { uint32_t value = static_cast<uint32_t>(bits.mmusid); return value;}
    CONSTEXPR void set_mmusid(uint32_t value) { bits.mmusid = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_stream2_mmussid_r - Stream 2 - MMU Sub-stream Stream Identifier
//
struct dl1_stream2_mmussid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmussid : 20; // MMU Sub-Stream ID (actual width is implementation defined)
            uint32_t reserved0 : 11;
            uint32_t mmussidv : 1; // MMUSSID valid bit
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_stream2_mmussid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmussid() const { uint32_t value = static_cast<uint32_t>(bits.mmussid); return value;}
    CONSTEXPR void set_mmussid(uint32_t value) { assert(static_cast<uint32_t>(value) < 1048576u); bits.mmussid = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mmussidv() const { uint32_t value = static_cast<uint32_t>(bits.mmussidv); return value;}
    CONSTEXPR void set_mmussidv(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmussidv = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_stream2_attr_control_r - Stream 2 - Attribute Control
//
struct dl1_stream2_attr_control_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t attrlocked : 1; // Stream attributes locked
            uint32_t reserved0 : 31;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_stream2_attr_control_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_attrlocked() const { uint32_t value = static_cast<uint32_t>(bits.attrlocked); return value;}
    CONSTEXPR void set_attrlocked(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.attrlocked = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_stream2_memattr_r - Stream 2 - Memory Attributes
//
struct dl1_stream2_memattr_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t memattr : 4; // Memory attributes
            uint32_t reserved0 : 28;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_stream2_memattr_r(uint32_t init=0) : word(init) {}
    CONSTEXPR memory_attributes_t get_memattr() const { memory_attributes_t value = static_cast<memory_attributes_t>(bits.memattr); return value;}
    CONSTEXPR void set_memattr(memory_attributes_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.memattr = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_stream2_address_extend_r - Stream 2 - Extended address bits per stream
//
struct dl1_stream2_address_extend_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t reserved0 : 9;
            uint32_t addrextend : 20; // Address extension bits [48:29]
            uint32_t reserved1 : 3;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_stream2_address_extend_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_addrextend() const { uint32_t value = static_cast<uint32_t>(bits.addrextend); return value;}
    CONSTEXPR void set_addrextend(uint32_t value) { assert(static_cast<uint32_t>(value) < 1048576u); bits.addrextend = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_stream3_stream_security_r - Stream 3 - Security State
//
struct dl1_stream3_stream_security_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusecsid : 1; // MMU stream security state
            uint32_t protns : 1; // AXI stream security state
            uint32_t reserved0 : 30;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_stream3_stream_security_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmusecsid() const { uint32_t value = static_cast<uint32_t>(bits.mmusecsid); return value;}
    CONSTEXPR void set_mmusecsid(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmusecsid = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_protns() const { uint32_t value = static_cast<uint32_t>(bits.protns); return value;}
    CONSTEXPR void set_protns(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.protns = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_stream3_nsaid_r - Stream 3 - Non-secure Access Identifier
//
struct dl1_stream3_nsaid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t nsaid : 4; // Non-Secure Address Identifier
            uint32_t reserved0 : 28;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_stream3_nsaid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_nsaid() const { uint32_t value = static_cast<uint32_t>(bits.nsaid); return value;}
    CONSTEXPR void set_nsaid(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.nsaid = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_stream3_mmusid_r - Stream 3 - MMU Stream Identifier
//
struct dl1_stream3_mmusid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusid : 32; // MMU Stream ID (actual width is implementation defined)
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_stream3_mmusid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmusid() const { uint32_t value = static_cast<uint32_t>(bits.mmusid); return value;}
    CONSTEXPR void set_mmusid(uint32_t value) { bits.mmusid = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_stream3_mmussid_r - Stream 3 - MMU Sub-stream Stream Identifier
//
struct dl1_stream3_mmussid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmussid : 20; // MMU Sub-Stream ID (actual width is implementation defined)
            uint32_t reserved0 : 11;
            uint32_t mmussidv : 1; // MMUSSID valid bit
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_stream3_mmussid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmussid() const { uint32_t value = static_cast<uint32_t>(bits.mmussid); return value;}
    CONSTEXPR void set_mmussid(uint32_t value) { assert(static_cast<uint32_t>(value) < 1048576u); bits.mmussid = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mmussidv() const { uint32_t value = static_cast<uint32_t>(bits.mmussidv); return value;}
    CONSTEXPR void set_mmussidv(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmussidv = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_stream3_attr_control_r - Stream 3 - Attribute Control
//
struct dl1_stream3_attr_control_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t attrlocked : 1; // Stream attributes locked
            uint32_t reserved0 : 31;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_stream3_attr_control_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_attrlocked() const { uint32_t value = static_cast<uint32_t>(bits.attrlocked); return value;}
    CONSTEXPR void set_attrlocked(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.attrlocked = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_stream3_memattr_r - Stream 3 - Memory Attributes
//
struct dl1_stream3_memattr_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t memattr : 4; // Memory attributes
            uint32_t reserved0 : 28;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_stream3_memattr_r(uint32_t init=0) : word(init) {}
    CONSTEXPR memory_attributes_t get_memattr() const { memory_attributes_t value = static_cast<memory_attributes_t>(bits.memattr); return value;}
    CONSTEXPR void set_memattr(memory_attributes_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.memattr = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_stream4_stream_security_r - Stream 4 - Security State
//
struct dl1_stream4_stream_security_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusecsid : 1; // MMU stream security state
            uint32_t protns : 1; // AXI stream security state
            uint32_t reserved0 : 30;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_stream4_stream_security_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmusecsid() const { uint32_t value = static_cast<uint32_t>(bits.mmusecsid); return value;}
    CONSTEXPR void set_mmusecsid(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmusecsid = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_protns() const { uint32_t value = static_cast<uint32_t>(bits.protns); return value;}
    CONSTEXPR void set_protns(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.protns = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_stream4_nsaid_r - Stream 4 - Non-secure Access Identifier
//
struct dl1_stream4_nsaid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t nsaid : 4; // Non-Secure Address Identifier
            uint32_t reserved0 : 28;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_stream4_nsaid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_nsaid() const { uint32_t value = static_cast<uint32_t>(bits.nsaid); return value;}
    CONSTEXPR void set_nsaid(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.nsaid = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_stream4_mmusid_r - Stream 4 - MMU Stream Identifier
//
struct dl1_stream4_mmusid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusid : 32; // MMU Stream ID (actual width is implementation defined)
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_stream4_mmusid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmusid() const { uint32_t value = static_cast<uint32_t>(bits.mmusid); return value;}
    CONSTEXPR void set_mmusid(uint32_t value) { bits.mmusid = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_stream4_mmussid_r - Stream 4 - MMU Sub-stream Stream Identifier
//
struct dl1_stream4_mmussid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmussid : 20; // MMU Sub-Stream ID (actual width is implementation defined)
            uint32_t reserved0 : 11;
            uint32_t mmussidv : 1; // MMUSSID valid bit
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_stream4_mmussid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmussid() const { uint32_t value = static_cast<uint32_t>(bits.mmussid); return value;}
    CONSTEXPR void set_mmussid(uint32_t value) { assert(static_cast<uint32_t>(value) < 1048576u); bits.mmussid = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mmussidv() const { uint32_t value = static_cast<uint32_t>(bits.mmussidv); return value;}
    CONSTEXPR void set_mmussidv(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmussidv = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_stream4_attr_control_r - Stream 4 - Attribute Control
//
struct dl1_stream4_attr_control_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t attrlocked : 1; // Stream attributes locked
            uint32_t reserved0 : 31;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_stream4_attr_control_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_attrlocked() const { uint32_t value = static_cast<uint32_t>(bits.attrlocked); return value;}
    CONSTEXPR void set_attrlocked(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.attrlocked = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_stream4_memattr_r - Stream 4 - Memory Attributes
//
struct dl1_stream4_memattr_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t memattr : 4; // Memory attributes
            uint32_t reserved0 : 28;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_stream4_memattr_r(uint32_t init=0) : word(init) {}
    CONSTEXPR memory_attributes_t get_memattr() const { memory_attributes_t value = static_cast<memory_attributes_t>(bits.memattr); return value;}
    CONSTEXPR void set_memattr(memory_attributes_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.memattr = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_stream5_stream_security_r - Stream 5 - Security State
//
struct dl1_stream5_stream_security_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusecsid : 1; // MMU stream security state
            uint32_t protns : 1; // AXI stream security state
            uint32_t reserved0 : 30;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_stream5_stream_security_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmusecsid() const { uint32_t value = static_cast<uint32_t>(bits.mmusecsid); return value;}
    CONSTEXPR void set_mmusecsid(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmusecsid = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_protns() const { uint32_t value = static_cast<uint32_t>(bits.protns); return value;}
    CONSTEXPR void set_protns(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.protns = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_stream5_nsaid_r - Stream 5 - Non-secure Access Identifier
//
struct dl1_stream5_nsaid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t nsaid : 4; // Non-Secure Address Identifier
            uint32_t reserved0 : 28;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_stream5_nsaid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_nsaid() const { uint32_t value = static_cast<uint32_t>(bits.nsaid); return value;}
    CONSTEXPR void set_nsaid(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.nsaid = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_stream5_mmusid_r - Stream 5 - MMU Stream Identifier
//
struct dl1_stream5_mmusid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusid : 32; // MMU Stream ID (actual width is implementation defined)
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_stream5_mmusid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmusid() const { uint32_t value = static_cast<uint32_t>(bits.mmusid); return value;}
    CONSTEXPR void set_mmusid(uint32_t value) { bits.mmusid = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_stream5_mmussid_r - Stream 5 - MMU Sub-stream Stream Identifier
//
struct dl1_stream5_mmussid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmussid : 20; // MMU Sub-Stream ID (actual width is implementation defined)
            uint32_t reserved0 : 11;
            uint32_t mmussidv : 1; // MMUSSID valid bit
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_stream5_mmussid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmussid() const { uint32_t value = static_cast<uint32_t>(bits.mmussid); return value;}
    CONSTEXPR void set_mmussid(uint32_t value) { assert(static_cast<uint32_t>(value) < 1048576u); bits.mmussid = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mmussidv() const { uint32_t value = static_cast<uint32_t>(bits.mmussidv); return value;}
    CONSTEXPR void set_mmussidv(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmussidv = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_stream5_attr_control_r - Stream 5 - Attribute Control
//
struct dl1_stream5_attr_control_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t attrlocked : 1; // Stream attributes locked
            uint32_t reserved0 : 31;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_stream5_attr_control_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_attrlocked() const { uint32_t value = static_cast<uint32_t>(bits.attrlocked); return value;}
    CONSTEXPR void set_attrlocked(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.attrlocked = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_stream5_memattr_r - Stream 5 - Memory Attributes
//
struct dl1_stream5_memattr_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t memattr : 4; // Memory attributes
            uint32_t reserved0 : 28;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_stream5_memattr_r(uint32_t init=0) : word(init) {}
    CONSTEXPR memory_attributes_t get_memattr() const { memory_attributes_t value = static_cast<memory_attributes_t>(bits.memattr); return value;}
    CONSTEXPR void set_memattr(memory_attributes_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.memattr = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_stream6_stream_security_r - Stream 6 - Security State
//
struct dl1_stream6_stream_security_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusecsid : 1; // MMU stream security state
            uint32_t protns : 1; // AXI stream security state
            uint32_t reserved0 : 30;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_stream6_stream_security_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmusecsid() const { uint32_t value = static_cast<uint32_t>(bits.mmusecsid); return value;}
    CONSTEXPR void set_mmusecsid(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmusecsid = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_protns() const { uint32_t value = static_cast<uint32_t>(bits.protns); return value;}
    CONSTEXPR void set_protns(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.protns = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_stream6_nsaid_r - Stream 6 - Non-secure Access Identifier
//
struct dl1_stream6_nsaid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t nsaid : 4; // Non-Secure Address Identifier
            uint32_t reserved0 : 28;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_stream6_nsaid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_nsaid() const { uint32_t value = static_cast<uint32_t>(bits.nsaid); return value;}
    CONSTEXPR void set_nsaid(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.nsaid = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_stream6_mmusid_r - Stream 6 - MMU Stream Identifier
//
struct dl1_stream6_mmusid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusid : 32; // MMU Stream ID (actual width is implementation defined)
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_stream6_mmusid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmusid() const { uint32_t value = static_cast<uint32_t>(bits.mmusid); return value;}
    CONSTEXPR void set_mmusid(uint32_t value) { bits.mmusid = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_stream6_mmussid_r - Stream 6 - MMU Sub-stream Stream Identifier
//
struct dl1_stream6_mmussid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmussid : 20; // MMU Sub-Stream ID (actual width is implementation defined)
            uint32_t reserved0 : 11;
            uint32_t mmussidv : 1; // MMUSSID valid bit
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_stream6_mmussid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmussid() const { uint32_t value = static_cast<uint32_t>(bits.mmussid); return value;}
    CONSTEXPR void set_mmussid(uint32_t value) { assert(static_cast<uint32_t>(value) < 1048576u); bits.mmussid = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mmussidv() const { uint32_t value = static_cast<uint32_t>(bits.mmussidv); return value;}
    CONSTEXPR void set_mmussidv(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmussidv = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_stream6_attr_control_r - Stream 6 - Attribute Control
//
struct dl1_stream6_attr_control_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t attrlocked : 1; // Stream attributes locked
            uint32_t reserved0 : 31;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_stream6_attr_control_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_attrlocked() const { uint32_t value = static_cast<uint32_t>(bits.attrlocked); return value;}
    CONSTEXPR void set_attrlocked(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.attrlocked = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_stream6_memattr_r - Stream 6 - Memory Attributes
//
struct dl1_stream6_memattr_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t memattr : 4; // Memory attributes
            uint32_t reserved0 : 28;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_stream6_memattr_r(uint32_t init=0) : word(init) {}
    CONSTEXPR memory_attributes_t get_memattr() const { memory_attributes_t value = static_cast<memory_attributes_t>(bits.memattr); return value;}
    CONSTEXPR void set_memattr(memory_attributes_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.memattr = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_stream7_stream_security_r - Stream 7 - Security State
//
struct dl1_stream7_stream_security_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusecsid : 1; // MMU stream security state
            uint32_t protns : 1; // AXI stream security state
            uint32_t reserved0 : 30;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_stream7_stream_security_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmusecsid() const { uint32_t value = static_cast<uint32_t>(bits.mmusecsid); return value;}
    CONSTEXPR void set_mmusecsid(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmusecsid = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_protns() const { uint32_t value = static_cast<uint32_t>(bits.protns); return value;}
    CONSTEXPR void set_protns(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.protns = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_stream7_nsaid_r - Stream 7 - Non-secure Access Identifier
//
struct dl1_stream7_nsaid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t nsaid : 4; // Non-Secure Address Identifier
            uint32_t reserved0 : 28;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_stream7_nsaid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_nsaid() const { uint32_t value = static_cast<uint32_t>(bits.nsaid); return value;}
    CONSTEXPR void set_nsaid(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.nsaid = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_stream7_mmusid_r - Stream 7 - MMU Stream Identifier
//
struct dl1_stream7_mmusid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusid : 32; // MMU Stream ID (actual width is implementation defined)
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_stream7_mmusid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmusid() const { uint32_t value = static_cast<uint32_t>(bits.mmusid); return value;}
    CONSTEXPR void set_mmusid(uint32_t value) { bits.mmusid = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_stream7_mmussid_r - Stream 7 - MMU Sub-stream Stream Identifier
//
struct dl1_stream7_mmussid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmussid : 20; // MMU Sub-Stream ID (actual width is implementation defined)
            uint32_t reserved0 : 11;
            uint32_t mmussidv : 1; // MMUSSID valid bit
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_stream7_mmussid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmussid() const { uint32_t value = static_cast<uint32_t>(bits.mmussid); return value;}
    CONSTEXPR void set_mmussid(uint32_t value) { assert(static_cast<uint32_t>(value) < 1048576u); bits.mmussid = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mmussidv() const { uint32_t value = static_cast<uint32_t>(bits.mmussidv); return value;}
    CONSTEXPR void set_mmussidv(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmussidv = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_stream7_attr_control_r - Stream 7 - Attribute Control
//
struct dl1_stream7_attr_control_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t attrlocked : 1; // Stream attributes locked
            uint32_t reserved0 : 31;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_stream7_attr_control_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_attrlocked() const { uint32_t value = static_cast<uint32_t>(bits.attrlocked); return value;}
    CONSTEXPR void set_attrlocked(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.attrlocked = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_stream7_memattr_r - Stream 7 - Memory Attributes
//
struct dl1_stream7_memattr_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t memattr : 4; // Memory attributes
            uint32_t reserved0 : 28;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_stream7_memattr_r(uint32_t init=0) : word(init) {}
    CONSTEXPR memory_attributes_t get_memattr() const { memory_attributes_t value = static_cast<memory_attributes_t>(bits.memattr); return value;}
    CONSTEXPR void set_memattr(memory_attributes_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.memattr = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_stream8_stream_security_r - Stream 8 - Security State
//
struct dl1_stream8_stream_security_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusecsid : 1; // MMU stream security state
            uint32_t protns : 1; // AXI stream security state
            uint32_t reserved0 : 30;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_stream8_stream_security_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmusecsid() const { uint32_t value = static_cast<uint32_t>(bits.mmusecsid); return value;}
    CONSTEXPR void set_mmusecsid(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmusecsid = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_protns() const { uint32_t value = static_cast<uint32_t>(bits.protns); return value;}
    CONSTEXPR void set_protns(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.protns = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_stream8_nsaid_r - Stream 8 - Non-secure Access Identifier
//
struct dl1_stream8_nsaid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t nsaid : 4; // Non-Secure Address Identifier
            uint32_t reserved0 : 28;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_stream8_nsaid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_nsaid() const { uint32_t value = static_cast<uint32_t>(bits.nsaid); return value;}
    CONSTEXPR void set_nsaid(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.nsaid = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_stream8_mmusid_r - Stream 8 - MMU Stream Identifier
//
struct dl1_stream8_mmusid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusid : 32; // MMU Stream ID (actual width is implementation defined)
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_stream8_mmusid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmusid() const { uint32_t value = static_cast<uint32_t>(bits.mmusid); return value;}
    CONSTEXPR void set_mmusid(uint32_t value) { bits.mmusid = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_stream8_mmussid_r - Stream 8 - MMU Sub-stream Stream Identifier
//
struct dl1_stream8_mmussid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmussid : 20; // MMU Sub-Stream ID (actual width is implementation defined)
            uint32_t reserved0 : 11;
            uint32_t mmussidv : 1; // MMUSSID valid bit
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_stream8_mmussid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmussid() const { uint32_t value = static_cast<uint32_t>(bits.mmussid); return value;}
    CONSTEXPR void set_mmussid(uint32_t value) { assert(static_cast<uint32_t>(value) < 1048576u); bits.mmussid = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mmussidv() const { uint32_t value = static_cast<uint32_t>(bits.mmussidv); return value;}
    CONSTEXPR void set_mmussidv(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmussidv = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_stream8_attr_control_r - Stream 8 - Attribute Control
//
struct dl1_stream8_attr_control_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t attrlocked : 1; // Stream attributes locked
            uint32_t reserved0 : 31;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_stream8_attr_control_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_attrlocked() const { uint32_t value = static_cast<uint32_t>(bits.attrlocked); return value;}
    CONSTEXPR void set_attrlocked(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.attrlocked = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_stream8_memattr_r - Stream 8 - Memory Attributes
//
struct dl1_stream8_memattr_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t memattr : 4; // Memory attributes
            uint32_t reserved0 : 28;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_stream8_memattr_r(uint32_t init=0) : word(init) {}
    CONSTEXPR memory_attributes_t get_memattr() const { memory_attributes_t value = static_cast<memory_attributes_t>(bits.memattr); return value;}
    CONSTEXPR void set_memattr(memory_attributes_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.memattr = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_npu_id_r - NPU ID register
//
struct dl1_npu_id_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t version_status : 4; // Status of the NPU release
            uint32_t version_minor : 4; // Minor release version number
            uint32_t version_major : 4; // Major release version number
            uint32_t product_major : 4; // Product identifier
            uint32_t arch_rev : 8; // Architecture patch revision
            uint32_t arch_minor : 4; // Architecture minor revision
            uint32_t arch_major : 4; // Architecture major revision
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_npu_id_r(uint32_t init=0) : word(init) {}
    CONSTEXPR npu_version_status_t get_version_status() const { npu_version_status_t value = static_cast<npu_version_status_t>(bits.version_status); return value;}
    CONSTEXPR void set_version_status(npu_version_status_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.version_status = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_version_minor() const { uint32_t value = static_cast<uint32_t>(bits.version_minor); return value;}
    CONSTEXPR void set_version_minor(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.version_minor = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_version_major() const { uint32_t value = static_cast<uint32_t>(bits.version_major); return value;}
    CONSTEXPR void set_version_major(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.version_major = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_product_major() const { uint32_t value = static_cast<uint32_t>(bits.product_major); return value;}
    CONSTEXPR void set_product_major(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.product_major = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_arch_rev() const { uint32_t value = static_cast<uint32_t>(bits.arch_rev); return value;}
    CONSTEXPR void set_arch_rev(uint32_t value) { assert(static_cast<uint32_t>(value) < 256u); bits.arch_rev = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_arch_minor() const { uint32_t value = static_cast<uint32_t>(bits.arch_minor); return value;}
    CONSTEXPR void set_arch_minor(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.arch_minor = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_arch_major() const { uint32_t value = static_cast<uint32_t>(bits.arch_major); return value;}
    CONSTEXPR void set_arch_major(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.arch_major = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_unit_count_r - Units present count
//
struct dl1_unit_count_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t quad_count : 8; // Number of quads
            uint32_t engines_per_quad : 8; // Number of engines per quad
            uint32_t dfc_emc_per_engine : 4; // Number of memory controllers per engine
            uint32_t reserved0 : 12;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_unit_count_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_quad_count() const { uint32_t value = static_cast<uint32_t>(bits.quad_count); return value;}
    CONSTEXPR void set_quad_count(uint32_t value) { assert(static_cast<uint32_t>(value) < 256u); bits.quad_count = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_engines_per_quad() const { uint32_t value = static_cast<uint32_t>(bits.engines_per_quad); return value;}
    CONSTEXPR void set_engines_per_quad(uint32_t value) { assert(static_cast<uint32_t>(value) < 256u); bits.engines_per_quad = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_dfc_emc_per_engine() const { uint32_t value = static_cast<uint32_t>(bits.dfc_emc_per_engine); return value;}
    CONSTEXPR void set_dfc_emc_per_engine(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.dfc_emc_per_engine = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_mce_features_r - MCE features
//
struct dl1_mce_features_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t ifm_generated_per_engine : 4; // IFMs sent to broadcast network per engine
            uint32_t reserved0 : 4;
            uint32_t ofm_generated_per_engine : 4; // OFMs generated per Engine
            uint32_t mce_num_macs : 8; // Number of MAC units per MCE
            uint32_t mce_num_acc : 8; // Number of accumulators per MAC unit
            uint32_t winograd_support : 1; // Winograd funcationality present
            uint32_t tsu_16bit_sequence_support : 1; // TSU support for automatically sequencing 16 bit IFM and weights
            uint32_t ofm_scaling_16bit_support : 1; // Hardware support for scaling results from 16-bit operations
            uint32_t reserved1 : 1;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_mce_features_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_ifm_generated_per_engine() const { uint32_t value = static_cast<uint32_t>(bits.ifm_generated_per_engine); return value;}
    CONSTEXPR void set_ifm_generated_per_engine(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.ifm_generated_per_engine = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ofm_generated_per_engine() const { uint32_t value = static_cast<uint32_t>(bits.ofm_generated_per_engine); return value;}
    CONSTEXPR void set_ofm_generated_per_engine(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.ofm_generated_per_engine = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mce_num_macs() const { uint32_t value = static_cast<uint32_t>(bits.mce_num_macs); return value;}
    CONSTEXPR void set_mce_num_macs(uint32_t value) { assert(static_cast<uint32_t>(value) < 256u); bits.mce_num_macs = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mce_num_acc() const { uint32_t value = static_cast<uint32_t>(bits.mce_num_acc); return value;}
    CONSTEXPR void set_mce_num_acc(uint32_t value) { assert(static_cast<uint32_t>(value) < 256u); bits.mce_num_acc = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_winograd_support() const { uint32_t value = static_cast<uint32_t>(bits.winograd_support); return value;}
    CONSTEXPR void set_winograd_support(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.winograd_support = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_tsu_16bit_sequence_support() const { uint32_t value = static_cast<uint32_t>(bits.tsu_16bit_sequence_support); return value;}
    CONSTEXPR void set_tsu_16bit_sequence_support(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.tsu_16bit_sequence_support = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ofm_scaling_16bit_support() const { uint32_t value = static_cast<uint32_t>(bits.ofm_scaling_16bit_support); return value;}
    CONSTEXPR void set_ofm_scaling_16bit_support(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ofm_scaling_16bit_support = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_dfc_features_r - DFC features
//
struct dl1_dfc_features_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t dfc_mem_size_per_emc : 16; // DFC memory size per EMC
            uint32_t bank_count : 6; // Number of banks in DFC memory
            uint32_t activation_compression : 4; // Version of activation compression supported
            uint32_t reserved0 : 6;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_dfc_features_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_dfc_mem_size_per_emc() const { uint32_t value = static_cast<uint32_t>(bits.dfc_mem_size_per_emc); return (value << 12);}
    CONSTEXPR void set_dfc_mem_size_per_emc(uint32_t value) { assert(static_cast<uint32_t>((value >> 12)) < 65536u); bits.dfc_mem_size_per_emc = static_cast<uint32_t>((value >> 12)); }
    CONSTEXPR uint32_t get_bank_count() const { uint32_t value = static_cast<uint32_t>(bits.bank_count); return value;}
    CONSTEXPR void set_bank_count(uint32_t value) { assert(static_cast<uint32_t>(value) < 64u); bits.bank_count = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_activation_compression() const { uint32_t value = static_cast<uint32_t>(bits.activation_compression); return value;}
    CONSTEXPR void set_activation_compression(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.activation_compression = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_ple_features_r - PLE features
//
struct dl1_ple_features_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t ple_input_mem_size : 8; // PLE input memory size
            uint32_t ple_output_mem_size : 8; // PLE output memory size
            uint32_t ple_vrf_mem_size : 8; // PLE vector register file memory size
            uint32_t ple_mem_size : 8; // PLE base memory size
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_ple_features_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_ple_input_mem_size() const { uint32_t value = static_cast<uint32_t>(bits.ple_input_mem_size); return (value << 8);}
    CONSTEXPR void set_ple_input_mem_size(uint32_t value) { assert(static_cast<uint32_t>((value >> 8)) < 256u); bits.ple_input_mem_size = static_cast<uint32_t>((value >> 8)); }
    CONSTEXPR uint32_t get_ple_output_mem_size() const { uint32_t value = static_cast<uint32_t>(bits.ple_output_mem_size); return (value << 8);}
    CONSTEXPR void set_ple_output_mem_size(uint32_t value) { assert(static_cast<uint32_t>((value >> 8)) < 256u); bits.ple_output_mem_size = static_cast<uint32_t>((value >> 8)); }
    CONSTEXPR uint32_t get_ple_vrf_mem_size() const { uint32_t value = static_cast<uint32_t>(bits.ple_vrf_mem_size); return (value << 4);}
    CONSTEXPR void set_ple_vrf_mem_size(uint32_t value) { assert(static_cast<uint32_t>((value >> 4)) < 256u); bits.ple_vrf_mem_size = static_cast<uint32_t>((value >> 4)); }
    CONSTEXPR uint32_t get_ple_mem_size() const { uint32_t value = static_cast<uint32_t>(bits.ple_mem_size); return (value << 8);}
    CONSTEXPR void set_ple_mem_size(uint32_t value) { assert(static_cast<uint32_t>((value >> 8)) < 256u); bits.ple_mem_size = static_cast<uint32_t>((value >> 8)); }
#endif
};


//
// dl1_wd_features_r - Weight Decoder features
//
struct dl1_wd_features_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t buffer_size : 8; // Weight decoder buffer size
            uint32_t max_dim : 8; // Weight decoder max dimension
            uint32_t compression_version : 4; // Version of weight compression implemented
            uint32_t reserved0 : 12;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_wd_features_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_buffer_size() const { uint32_t value = static_cast<uint32_t>(bits.buffer_size); return value;}
    CONSTEXPR void set_buffer_size(uint32_t value) { assert(static_cast<uint32_t>(value) < 256u); bits.buffer_size = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_max_dim() const { uint32_t value = static_cast<uint32_t>(bits.max_dim); return value;}
    CONSTEXPR void set_max_dim(uint32_t value) { assert(static_cast<uint32_t>(value) < 256u); bits.max_dim = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_compression_version() const { uint32_t value = static_cast<uint32_t>(bits.compression_version); return value;}
    CONSTEXPR void set_compression_version(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.compression_version = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_vector_engine_features_r - PLE VE features
//
struct dl1_vector_engine_features_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t vector_engine_version : 4; // Version of the vector engine implemented
            uint32_t ple_lanes : 2; // Number of lanes in the PLE
            uint32_t reserved0 : 26;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_vector_engine_features_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_vector_engine_version() const { uint32_t value = static_cast<uint32_t>(bits.vector_engine_version); return value;}
    CONSTEXPR void set_vector_engine_version(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.vector_engine_version = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ple_lanes() const { uint32_t value = static_cast<uint32_t>(bits.ple_lanes); return (value + 1);}
    CONSTEXPR void set_ple_lanes(uint32_t value) { assert(static_cast<uint32_t>((value - 1)) < 4u); bits.ple_lanes = static_cast<uint32_t>((value - 1)); }
#endif
};


//
// dl1_ecoid_r - Encoding describing ECOs implemented
//
struct dl1_ecoid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t ecoid : 12; // Field for describing ECOs implemented
            uint32_t reserved0 : 20;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_ecoid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_ecoid() const { uint32_t value = static_cast<uint32_t>(bits.ecoid); return value;}
    CONSTEXPR void set_ecoid(uint32_t value) { assert(static_cast<uint32_t>(value) < 4096u); bits.ecoid = static_cast<uint32_t>(value); }
#endif
};


//
// dl1_streamid_width_r - Configured StreamID widths
//
struct dl1_streamid_width_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusid_w : 5; // Configured width of StreamID (AxMMUSID)
            uint32_t reserved0 : 3;
            uint32_t mmussid_w : 5; // Configured width of SubstreamID (AxMMUSSID)
            uint32_t reserved1 : 19;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl1_streamid_width_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmusid_w() const { uint32_t value = static_cast<uint32_t>(bits.mmusid_w); return (value + 1);}
    CONSTEXPR void set_mmusid_w(uint32_t value) { assert(static_cast<uint32_t>((value - 1)) < 32u); bits.mmusid_w = static_cast<uint32_t>((value - 1)); }
    CONSTEXPR uint32_t get_mmussid_w() const { uint32_t value = static_cast<uint32_t>(bits.mmussid_w); return (value + 1);}
    CONSTEXPR void set_mmussid_w(uint32_t value) { assert(static_cast<uint32_t>((value - 1)) < 32u); bits.mmussid_w = static_cast<uint32_t>((value - 1)); }
#endif
};


//
// dl2_ext_access_control_r - External Access Control
//
struct dl2_ext_access_control_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t excctlr : 1; // Execution control pages access control
            uint32_t ramctlr : 1; // Memory mapped RAMs access control
            uint32_t dbgctlr : 1; // PMU and DBG pages access control
            uint32_t reserved0 : 5;
            uint32_t reserved1 : 8;
            uint32_t reserved2 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_ext_access_control_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_excctlr() const { uint32_t value = static_cast<uint32_t>(bits.excctlr); return value;}
    CONSTEXPR void set_excctlr(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.excctlr = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ramctlr() const { uint32_t value = static_cast<uint32_t>(bits.ramctlr); return value;}
    CONSTEXPR void set_ramctlr(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ramctlr = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_dbgctlr() const { uint32_t value = static_cast<uint32_t>(bits.dbgctlr); return value;}
    CONSTEXPR void set_dbgctlr(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.dbgctlr = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_delegation_r - Control Access Delegation
//
struct dl2_delegation_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t secctlr : 1; // SECCTLR register delegation bit
            uint32_t secmcuctlr : 1; // SECMCUCTLR register delegation bit
            uint32_t sysctlr : 1; // SYSCTLR register delegation bit
            uint32_t pwrctlr : 1; // PWRCTLR register delegation bit
            uint32_t auxctlr : 1; // AUXCTLR register delegation bit
            uint32_t excctlr : 1; // EXCCTLR delegation bit
            uint32_t ramctlr : 1; // RAMCTLR delegation bit
            uint32_t dbgctlr : 1; // DBGCTLR delegation bit
            uint32_t err : 1; // Error register delegation bit
            uint32_t debug : 1; // Debug register delegation bit
            uint32_t job : 1; // Job register delegation bit
            uint32_t event : 1; // Event register delegation bit
            uint32_t interrupt : 1; // Interrupt register delegation bit
            uint32_t nmi : 1; // NMI register delegation bit
            uint32_t irq : 1; // IRQ_STATUS register delegation bit
            uint32_t intext : 1; // INT_STATUS and EXT_STATUS registers delegation bit (shared)
            uint32_t gp0 : 1; // GP0 register delegation bit
            uint32_t gp1 : 1; // GP1 register delegation bit
            uint32_t gp2 : 1; // GP2 register delegation bit
            uint32_t gp3 : 1; // GP3 register delegation bit
            uint32_t gp4 : 1; // GP4 register delegation bit
            uint32_t gp5 : 1; // GP5 register delegation bit
            uint32_t gp6 : 1; // GP6 register delegation bit
            uint32_t gp7 : 1; // GP7 register delegation bit
            uint32_t dfcot : 1; // DFC outstanding transaction registers delegation bit
            uint32_t reserved0 : 7;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_delegation_r(uint32_t init=0) : word(init) {}
    CONSTEXPR delegation_t get_secctlr() const { delegation_t value = static_cast<delegation_t>(bits.secctlr); return value;}
    CONSTEXPR void set_secctlr(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.secctlr = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_secmcuctlr() const { delegation_t value = static_cast<delegation_t>(bits.secmcuctlr); return value;}
    CONSTEXPR void set_secmcuctlr(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.secmcuctlr = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_sysctlr() const { delegation_t value = static_cast<delegation_t>(bits.sysctlr); return value;}
    CONSTEXPR void set_sysctlr(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.sysctlr = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_pwrctlr() const { delegation_t value = static_cast<delegation_t>(bits.pwrctlr); return value;}
    CONSTEXPR void set_pwrctlr(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.pwrctlr = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_auxctlr() const { delegation_t value = static_cast<delegation_t>(bits.auxctlr); return value;}
    CONSTEXPR void set_auxctlr(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.auxctlr = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_excctlr() const { delegation_t value = static_cast<delegation_t>(bits.excctlr); return value;}
    CONSTEXPR void set_excctlr(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.excctlr = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_ramctlr() const { delegation_t value = static_cast<delegation_t>(bits.ramctlr); return value;}
    CONSTEXPR void set_ramctlr(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ramctlr = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_dbgctlr() const { delegation_t value = static_cast<delegation_t>(bits.dbgctlr); return value;}
    CONSTEXPR void set_dbgctlr(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.dbgctlr = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_err() const { delegation_t value = static_cast<delegation_t>(bits.err); return value;}
    CONSTEXPR void set_err(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.err = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_debug() const { delegation_t value = static_cast<delegation_t>(bits.debug); return value;}
    CONSTEXPR void set_debug(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.debug = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_job() const { delegation_t value = static_cast<delegation_t>(bits.job); return value;}
    CONSTEXPR void set_job(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.job = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_event() const { delegation_t value = static_cast<delegation_t>(bits.event); return value;}
    CONSTEXPR void set_event(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.event = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_interrupt() const { delegation_t value = static_cast<delegation_t>(bits.interrupt); return value;}
    CONSTEXPR void set_interrupt(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.interrupt = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_nmi() const { delegation_t value = static_cast<delegation_t>(bits.nmi); return value;}
    CONSTEXPR void set_nmi(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.nmi = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_irq() const { delegation_t value = static_cast<delegation_t>(bits.irq); return value;}
    CONSTEXPR void set_irq(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.irq = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_intext() const { delegation_t value = static_cast<delegation_t>(bits.intext); return value;}
    CONSTEXPR void set_intext(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.intext = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_gp0() const { delegation_t value = static_cast<delegation_t>(bits.gp0); return value;}
    CONSTEXPR void set_gp0(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.gp0 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_gp1() const { delegation_t value = static_cast<delegation_t>(bits.gp1); return value;}
    CONSTEXPR void set_gp1(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.gp1 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_gp2() const { delegation_t value = static_cast<delegation_t>(bits.gp2); return value;}
    CONSTEXPR void set_gp2(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.gp2 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_gp3() const { delegation_t value = static_cast<delegation_t>(bits.gp3); return value;}
    CONSTEXPR void set_gp3(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.gp3 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_gp4() const { delegation_t value = static_cast<delegation_t>(bits.gp4); return value;}
    CONSTEXPR void set_gp4(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.gp4 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_gp5() const { delegation_t value = static_cast<delegation_t>(bits.gp5); return value;}
    CONSTEXPR void set_gp5(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.gp5 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_gp6() const { delegation_t value = static_cast<delegation_t>(bits.gp6); return value;}
    CONSTEXPR void set_gp6(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.gp6 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_gp7() const { delegation_t value = static_cast<delegation_t>(bits.gp7); return value;}
    CONSTEXPR void set_gp7(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.gp7 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_dfcot() const { delegation_t value = static_cast<delegation_t>(bits.dfcot); return value;}
    CONSTEXPR void set_dfcot(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.dfcot = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_secctlr_r - NPU security controls
//
struct dl2_secctlr_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t ns_allowed : 1; // Allow Non-secure transactions
            uint32_t npu_ns_mode : 1; // NPU Non-secure mode
            uint32_t reserved0 : 6;
            uint32_t ext_ns_evnt_to_s_evnt : 1; // NCU MCU S x NS Event
            uint32_t ext_ns_irq_to_s_irq : 1; // NCU MCU S x NS Interrupt
            uint32_t ext_s_evnt_to_ns_evnt : 1; // NCU MCU NS x S Event
            uint32_t ext_s_evnt_to_ns_irq : 1; // NCU MCU NS x S Event interrupt upgrade
            uint32_t reserved1 : 20;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_secctlr_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_ns_allowed() const { uint32_t value = static_cast<uint32_t>(bits.ns_allowed); return value;}
    CONSTEXPR void set_ns_allowed(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ns_allowed = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_npu_ns_mode() const { uint32_t value = static_cast<uint32_t>(bits.npu_ns_mode); return value;}
    CONSTEXPR void set_npu_ns_mode(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.npu_ns_mode = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ext_ns_evnt_to_s_evnt() const { uint32_t value = static_cast<uint32_t>(bits.ext_ns_evnt_to_s_evnt); return value;}
    CONSTEXPR void set_ext_ns_evnt_to_s_evnt(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ext_ns_evnt_to_s_evnt = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ext_ns_irq_to_s_irq() const { uint32_t value = static_cast<uint32_t>(bits.ext_ns_irq_to_s_irq); return value;}
    CONSTEXPR void set_ext_ns_irq_to_s_irq(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ext_ns_irq_to_s_irq = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ext_s_evnt_to_ns_evnt() const { uint32_t value = static_cast<uint32_t>(bits.ext_s_evnt_to_ns_evnt); return value;}
    CONSTEXPR void set_ext_s_evnt_to_ns_evnt(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ext_s_evnt_to_ns_evnt = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ext_s_evnt_to_ns_irq() const { uint32_t value = static_cast<uint32_t>(bits.ext_s_evnt_to_ns_irq); return value;}
    CONSTEXPR void set_ext_s_evnt_to_ns_irq(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ext_s_evnt_to_ns_irq = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_secmcuctlr_r - NCU MCU security state control
//
struct dl2_secmcuctlr_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mcu_state : 1; // NCU MCU security state
            uint32_t reserved0 : 31;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_secmcuctlr_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mcu_state() const { uint32_t value = static_cast<uint32_t>(bits.mcu_state); return value;}
    CONSTEXPR void set_mcu_state(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mcu_state = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_sysctlr0_r - System control 0 - MCU Control and Status
//
struct dl2_sysctlr0_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t cpuwait : 1; // MCU CPUWAIT input
            uint32_t lockup : 1; // MCU LOCKUP output
            uint32_t halted : 1; // MCU HALTED output
            uint32_t rstreq : 1; // MCU SYSRESETREQ output
            uint32_t sleeping : 1; // MCU SLEEPING and TRCENA output
            uint32_t reserved0 : 2;
            uint32_t initvtor : 22; // MCU Vector Table address
            uint32_t soft_rstreq : 2; // Soft reset request
            uint32_t hard_rstreq : 1; // Hard reset request
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_sysctlr0_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_cpuwait() const { uint32_t value = static_cast<uint32_t>(bits.cpuwait); return value;}
    CONSTEXPR void set_cpuwait(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.cpuwait = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_lockup() const { uint32_t value = static_cast<uint32_t>(bits.lockup); return value;}
    CONSTEXPR void set_lockup(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.lockup = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_halted() const { uint32_t value = static_cast<uint32_t>(bits.halted); return value;}
    CONSTEXPR void set_halted(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.halted = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_rstreq() const { uint32_t value = static_cast<uint32_t>(bits.rstreq); return value;}
    CONSTEXPR void set_rstreq(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.rstreq = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_sleeping() const { uint32_t value = static_cast<uint32_t>(bits.sleeping); return value;}
    CONSTEXPR void set_sleeping(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.sleeping = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_initvtor() const { uint32_t value = static_cast<uint32_t>(bits.initvtor); return value;}
    CONSTEXPR void set_initvtor(uint32_t value) { assert(static_cast<uint32_t>(value) < 4194304u); bits.initvtor = static_cast<uint32_t>(value); }
    CONSTEXPR soft_reset_t get_soft_rstreq() const { soft_reset_t value = static_cast<soft_reset_t>(bits.soft_rstreq); return value;}
    CONSTEXPR void set_soft_rstreq(soft_reset_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.soft_rstreq = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_hard_rstreq() const { uint32_t value = static_cast<uint32_t>(bits.hard_rstreq); return value;}
    CONSTEXPR void set_hard_rstreq(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.hard_rstreq = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_sysctlr1_r - System control 1 - Event Control
//
struct dl2_sysctlr1_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t reserved0 : 4;
            uint32_t mcu_setevnt : 1; // MCU SET event
            uint32_t mcu_setirq : 1; // MCU SET interrupt
            uint32_t mcu_gpevnt : 1; // MCU GP event
            uint32_t reserved1 : 1;
            uint32_t tsu_evnt : 1; // TSU event
            uint32_t tsu_irq : 1; // TSU interrupt
            uint32_t tsu_dbg : 1; // TSU debug request
            uint32_t reserved2 : 5;
            uint32_t txev_ple : 1; // MCU TXEV sent to PLE
            uint32_t reserved3 : 1;
            uint32_t txev_dbg : 1; // MCU TXEV sent to Host
            uint32_t rxev_degroup : 1; // Degroup PLE TXEV sent to MCU
            uint32_t rxev_evnt : 1; // PLE TXEV sent to MCU
            uint32_t rxev_irq : 1; // PLE TXEV triggers MCU interrupt
            uint32_t reserved4 : 2;
            uint32_t pmu_evnt : 1; // PMU counter overflow event
            uint32_t pmu_irq : 1; // PMU counter overflow interrupt
            uint32_t pmu_dbg : 1; // PMU counter overflow debug request
            uint32_t pmu_eng : 1; // PMU engine counter overflow request
            uint32_t err_tolr_evnt : 1; // Tolerable error triggers MCU event
            uint32_t err_tolr_irq : 1; // Tolerable error triggers MCU interrupt
            uint32_t err_func_irq : 1; // Functional error triggers MCU interrupt
            uint32_t err_recv_irq : 1; // Recoverable error triggers MCU interrupt
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_sysctlr1_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mcu_setevnt() const { uint32_t value = static_cast<uint32_t>(bits.mcu_setevnt); return value;}
    CONSTEXPR void set_mcu_setevnt(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mcu_setevnt = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mcu_setirq() const { uint32_t value = static_cast<uint32_t>(bits.mcu_setirq); return value;}
    CONSTEXPR void set_mcu_setirq(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mcu_setirq = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mcu_gpevnt() const { uint32_t value = static_cast<uint32_t>(bits.mcu_gpevnt); return value;}
    CONSTEXPR void set_mcu_gpevnt(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mcu_gpevnt = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_tsu_evnt() const { uint32_t value = static_cast<uint32_t>(bits.tsu_evnt); return value;}
    CONSTEXPR void set_tsu_evnt(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.tsu_evnt = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_tsu_irq() const { uint32_t value = static_cast<uint32_t>(bits.tsu_irq); return value;}
    CONSTEXPR void set_tsu_irq(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.tsu_irq = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_tsu_dbg() const { uint32_t value = static_cast<uint32_t>(bits.tsu_dbg); return value;}
    CONSTEXPR void set_tsu_dbg(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.tsu_dbg = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_txev_ple() const { uint32_t value = static_cast<uint32_t>(bits.txev_ple); return value;}
    CONSTEXPR void set_txev_ple(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.txev_ple = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_txev_dbg() const { uint32_t value = static_cast<uint32_t>(bits.txev_dbg); return value;}
    CONSTEXPR void set_txev_dbg(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.txev_dbg = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_rxev_degroup() const { uint32_t value = static_cast<uint32_t>(bits.rxev_degroup); return value;}
    CONSTEXPR void set_rxev_degroup(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.rxev_degroup = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_rxev_evnt() const { uint32_t value = static_cast<uint32_t>(bits.rxev_evnt); return value;}
    CONSTEXPR void set_rxev_evnt(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.rxev_evnt = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_rxev_irq() const { uint32_t value = static_cast<uint32_t>(bits.rxev_irq); return value;}
    CONSTEXPR void set_rxev_irq(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.rxev_irq = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_pmu_evnt() const { uint32_t value = static_cast<uint32_t>(bits.pmu_evnt); return value;}
    CONSTEXPR void set_pmu_evnt(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.pmu_evnt = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_pmu_irq() const { uint32_t value = static_cast<uint32_t>(bits.pmu_irq); return value;}
    CONSTEXPR void set_pmu_irq(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.pmu_irq = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_pmu_dbg() const { uint32_t value = static_cast<uint32_t>(bits.pmu_dbg); return value;}
    CONSTEXPR void set_pmu_dbg(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.pmu_dbg = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_pmu_eng() const { uint32_t value = static_cast<uint32_t>(bits.pmu_eng); return value;}
    CONSTEXPR void set_pmu_eng(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.pmu_eng = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_err_tolr_evnt() const { uint32_t value = static_cast<uint32_t>(bits.err_tolr_evnt); return value;}
    CONSTEXPR void set_err_tolr_evnt(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.err_tolr_evnt = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_err_tolr_irq() const { uint32_t value = static_cast<uint32_t>(bits.err_tolr_irq); return value;}
    CONSTEXPR void set_err_tolr_irq(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.err_tolr_irq = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_err_func_irq() const { uint32_t value = static_cast<uint32_t>(bits.err_func_irq); return value;}
    CONSTEXPR void set_err_func_irq(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.err_func_irq = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_err_recv_irq() const { uint32_t value = static_cast<uint32_t>(bits.err_recv_irq); return value;}
    CONSTEXPR void set_err_recv_irq(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.err_recv_irq = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_pwrctlr_r - Power Control
//
struct dl2_pwrctlr_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t active : 1; // NPU activity state
            uint32_t qreqn : 1; // Value of CLK Q-channel QREQn
            uint32_t reserved0 : 30;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_pwrctlr_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_active() const { uint32_t value = static_cast<uint32_t>(bits.active); return value;}
    CONSTEXPR void set_active(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.active = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_qreqn() const { uint32_t value = static_cast<uint32_t>(bits.qreqn); return value;}
    CONSTEXPR void set_qreqn(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.qreqn = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_auxctlr_r - Auxiliary Control
//
struct dl2_auxctlr_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t dis_clkgate : 1; // Disable clock gating
            uint32_t dis_qdeny : 1; // Q-channel FSM deny control
            uint32_t dis_edgeirq : 1; // Change sensitivity of DEBUG and JOB IRQs
            uint32_t dis_mcu_unique_rid : 1; // Disable MCU logic enforcing unique RIDs
            uint32_t dis_stshtrnsltn : 1; // Disable StashTranslation transactions
            uint32_t reserved0 : 2;
            uint32_t increase_outstanding_writes : 1; // Increase outstanding master write transactions
            uint32_t dbgen : 1; // Invasive debug enable
            uint32_t niden : 1; // Non-invasive debug enable
            uint32_t reserved1 : 2;
            uint32_t dis_ext_err_unrecoverable : 1; // Disable ext err irq for unrecoverable errors
            uint32_t dis_ext_err_recoverable : 1; // Disable ext err irq for recoverable errors
            uint32_t dis_ext_err_functional : 1; // Disable ext err irq for functional errors
            uint32_t dis_ext_err_tolerable : 1; // Disable ext debug irq for tolerable errors
            uint32_t dis_non_broadcast_global_err : 1; // Disable non broadcast global errors
            uint32_t en_ple_block_done : 1; // Enable detection in TSU of PLE_BLOCK_DONE events indicated by engines.
            uint32_t mac_ramp_cycles : 2; // Number of ramp cycles when the MAC units transition between idle and active states.
            uint32_t snoop_dis : 1; // Disable external snooping of internal signals
            uint32_t wd_ramp_dis : 1; // Disable weight decoder ramping
            uint32_t reserved2 : 2;
            uint32_t stash_ahead : 4; // Number of 4kB pages to automatically read ahead for each of read and write before the corresponding DMA accesses
            uint32_t stash_issue : 4; // Issuing capacity for StashTranslation transactions
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_auxctlr_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_dis_clkgate() const { uint32_t value = static_cast<uint32_t>(bits.dis_clkgate); return value;}
    CONSTEXPR void set_dis_clkgate(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.dis_clkgate = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_dis_qdeny() const { uint32_t value = static_cast<uint32_t>(bits.dis_qdeny); return value;}
    CONSTEXPR void set_dis_qdeny(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.dis_qdeny = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_dis_edgeirq() const { uint32_t value = static_cast<uint32_t>(bits.dis_edgeirq); return value;}
    CONSTEXPR void set_dis_edgeirq(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.dis_edgeirq = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_dis_mcu_unique_rid() const { uint32_t value = static_cast<uint32_t>(bits.dis_mcu_unique_rid); return value;}
    CONSTEXPR void set_dis_mcu_unique_rid(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.dis_mcu_unique_rid = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_dis_stshtrnsltn() const { uint32_t value = static_cast<uint32_t>(bits.dis_stshtrnsltn); return value;}
    CONSTEXPR void set_dis_stshtrnsltn(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.dis_stshtrnsltn = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_increase_outstanding_writes() const { uint32_t value = static_cast<uint32_t>(bits.increase_outstanding_writes); return value;}
    CONSTEXPR void set_increase_outstanding_writes(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.increase_outstanding_writes = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_dbgen() const { uint32_t value = static_cast<uint32_t>(bits.dbgen); return value;}
    CONSTEXPR void set_dbgen(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.dbgen = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_niden() const { uint32_t value = static_cast<uint32_t>(bits.niden); return value;}
    CONSTEXPR void set_niden(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.niden = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_dis_ext_err_unrecoverable() const { uint32_t value = static_cast<uint32_t>(bits.dis_ext_err_unrecoverable); return value;}
    CONSTEXPR void set_dis_ext_err_unrecoverable(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.dis_ext_err_unrecoverable = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_dis_ext_err_recoverable() const { uint32_t value = static_cast<uint32_t>(bits.dis_ext_err_recoverable); return value;}
    CONSTEXPR void set_dis_ext_err_recoverable(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.dis_ext_err_recoverable = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_dis_ext_err_functional() const { uint32_t value = static_cast<uint32_t>(bits.dis_ext_err_functional); return value;}
    CONSTEXPR void set_dis_ext_err_functional(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.dis_ext_err_functional = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_dis_ext_err_tolerable() const { uint32_t value = static_cast<uint32_t>(bits.dis_ext_err_tolerable); return value;}
    CONSTEXPR void set_dis_ext_err_tolerable(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.dis_ext_err_tolerable = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_dis_non_broadcast_global_err() const { uint32_t value = static_cast<uint32_t>(bits.dis_non_broadcast_global_err); return value;}
    CONSTEXPR void set_dis_non_broadcast_global_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.dis_non_broadcast_global_err = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_en_ple_block_done() const { uint32_t value = static_cast<uint32_t>(bits.en_ple_block_done); return value;}
    CONSTEXPR void set_en_ple_block_done(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.en_ple_block_done = static_cast<uint32_t>(value); }
    CONSTEXPR mac_ramp_t get_mac_ramp_cycles() const { mac_ramp_t value = static_cast<mac_ramp_t>(bits.mac_ramp_cycles); return value;}
    CONSTEXPR void set_mac_ramp_cycles(mac_ramp_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.mac_ramp_cycles = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_snoop_dis() const { uint32_t value = static_cast<uint32_t>(bits.snoop_dis); return value;}
    CONSTEXPR void set_snoop_dis(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.snoop_dis = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_wd_ramp_dis() const { uint32_t value = static_cast<uint32_t>(bits.wd_ramp_dis); return value;}
    CONSTEXPR void set_wd_ramp_dis(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.wd_ramp_dis = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_stash_ahead() const { uint32_t value = static_cast<uint32_t>(bits.stash_ahead); return value;}
    CONSTEXPR void set_stash_ahead(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.stash_ahead = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_stash_issue() const { uint32_t value = static_cast<uint32_t>(bits.stash_issue); return value;}
    CONSTEXPR void set_stash_issue(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.stash_issue = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_setirq_ext_r - Set external interrupts (to host)
//
struct dl2_setirq_ext_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t err : 1; // Host error interrupt set request (level-sensitive to host)
            uint32_t debug : 1; // Host debug interrupt set request
            uint32_t job : 1; // Host job interrupt set request
            uint32_t reserved0 : 29;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_setirq_ext_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_err() const { uint32_t value = static_cast<uint32_t>(bits.err); return value;}
    CONSTEXPR void set_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.err = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_debug() const { uint32_t value = static_cast<uint32_t>(bits.debug); return value;}
    CONSTEXPR void set_debug(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.debug = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_job() const { uint32_t value = static_cast<uint32_t>(bits.job); return value;}
    CONSTEXPR void set_job(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.job = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_clrirq_ext_r - Clear external interrupts (to host)
//
struct dl2_clrirq_ext_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t err : 1; // Host error interrupt clear request
            uint32_t debug : 1; // Host debug interrupt clear request
            uint32_t job : 1; // Host job interrupt clear request
            uint32_t reserved0 : 29;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_clrirq_ext_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_err() const { uint32_t value = static_cast<uint32_t>(bits.err); return value;}
    CONSTEXPR void set_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.err = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_debug() const { uint32_t value = static_cast<uint32_t>(bits.debug); return value;}
    CONSTEXPR void set_debug(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.debug = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_job() const { uint32_t value = static_cast<uint32_t>(bits.job); return value;}
    CONSTEXPR void set_job(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.job = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_setirq_int_r - Raise internal interrupts and events
//
struct dl2_setirq_int_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t reserved0 : 4;
            uint32_t event : 1; // MCU event (edge-sensitive to MCU'S RXEV pin)
            uint32_t interrupt : 1; // MCU interrupt (edge-sensitive to MCU's IRQ pin)
            uint32_t reserved1 : 1;
            uint32_t nmi : 1; // MCU interrupt (edge-sensitive to MCU's NMI pin)
            uint32_t reserved2 : 24;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_setirq_int_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_event() const { uint32_t value = static_cast<uint32_t>(bits.event); return value;}
    CONSTEXPR void set_event(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.event = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_interrupt() const { uint32_t value = static_cast<uint32_t>(bits.interrupt); return value;}
    CONSTEXPR void set_interrupt(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.interrupt = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_nmi() const { uint32_t value = static_cast<uint32_t>(bits.nmi); return value;}
    CONSTEXPR void set_nmi(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.nmi = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_dfc_slv_ord_r - DFC Slave Outstanding Reads
//
struct dl2_dfc_slv_ord_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t out_reads : 8; // Outstanding read transaction count
            uint32_t reserved0 : 24;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_dfc_slv_ord_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_out_reads() const { uint32_t value = static_cast<uint32_t>(bits.out_reads); return value;}
    CONSTEXPR void set_out_reads(uint32_t value) { assert(static_cast<uint32_t>(value) < 256u); bits.out_reads = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_dfc_slv_owr_r - DFC Slave Outstanding Writes
//
struct dl2_dfc_slv_owr_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t out_writes : 8; // Outstanding write transaction count
            uint32_t reserved0 : 24;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_dfc_slv_owr_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_out_writes() const { uint32_t value = static_cast<uint32_t>(bits.out_writes); return value;}
    CONSTEXPR void set_out_writes(uint32_t value) { assert(static_cast<uint32_t>(value) < 256u); bits.out_writes = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_dfc_mst_ord_r - DFC Master Outstanding Reads
//
struct dl2_dfc_mst_ord_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t out_reads : 8; // Outstanding read transaction count
            uint32_t reserved0 : 24;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_dfc_mst_ord_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_out_reads() const { uint32_t value = static_cast<uint32_t>(bits.out_reads); return value;}
    CONSTEXPR void set_out_reads(uint32_t value) { assert(static_cast<uint32_t>(value) < 256u); bits.out_reads = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_dfc_mst_owr_r - DFC Master Outstanding Writes
//
struct dl2_dfc_mst_owr_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t out_writes : 8; // Outstanding write transaction count
            uint32_t reserved0 : 24;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_dfc_mst_owr_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_out_writes() const { uint32_t value = static_cast<uint32_t>(bits.out_writes); return value;}
    CONSTEXPR void set_out_writes(uint32_t value) { assert(static_cast<uint32_t>(value) < 256u); bits.out_writes = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_irq_status_r - Status register used by the Host system
//
struct dl2_irq_status_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t setirq_err : 1; // ERR interrupt caused by SETIRQ
            uint32_t setirq_dbg : 1; // DEBUG interrupt caused by SETIRQ
            uint32_t setirq_job : 1; // JOB interrupt caused by SETIRQ
            uint32_t reserved0 : 7;
            uint32_t tsu_dbg : 1; // DEBUG interrupt caused by TSU
            uint32_t reserved1 : 15;
            uint32_t pmu_dbg : 1; // DEBUG interrupt caused by top-level PMU
            uint32_t pmu_eng : 1; // DEBUG interrupt caused by engine-level PMU
            uint32_t tol_err : 1; // Tolerable error
            uint32_t func_err : 1; // Functional error
            uint32_t rec_err : 1; // Recoverable error
            uint32_t unrec_err : 1; // Unrecoverable error
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_irq_status_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_setirq_err() const { uint32_t value = static_cast<uint32_t>(bits.setirq_err); return value;}
    CONSTEXPR void set_setirq_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.setirq_err = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_setirq_dbg() const { uint32_t value = static_cast<uint32_t>(bits.setirq_dbg); return value;}
    CONSTEXPR void set_setirq_dbg(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.setirq_dbg = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_setirq_job() const { uint32_t value = static_cast<uint32_t>(bits.setirq_job); return value;}
    CONSTEXPR void set_setirq_job(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.setirq_job = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_tsu_dbg() const { uint32_t value = static_cast<uint32_t>(bits.tsu_dbg); return value;}
    CONSTEXPR void set_tsu_dbg(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.tsu_dbg = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_pmu_dbg() const { uint32_t value = static_cast<uint32_t>(bits.pmu_dbg); return value;}
    CONSTEXPR void set_pmu_dbg(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.pmu_dbg = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_pmu_eng() const { uint32_t value = static_cast<uint32_t>(bits.pmu_eng); return value;}
    CONSTEXPR void set_pmu_eng(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.pmu_eng = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_tol_err() const { uint32_t value = static_cast<uint32_t>(bits.tol_err); return value;}
    CONSTEXPR void set_tol_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.tol_err = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_func_err() const { uint32_t value = static_cast<uint32_t>(bits.func_err); return value;}
    CONSTEXPR void set_func_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.func_err = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_rec_err() const { uint32_t value = static_cast<uint32_t>(bits.rec_err); return value;}
    CONSTEXPR void set_rec_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.rec_err = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_unrec_err() const { uint32_t value = static_cast<uint32_t>(bits.unrec_err); return value;}
    CONSTEXPR void set_unrec_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.unrec_err = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_int_status_r - Internal status register used by the NCU's MCU
//
struct dl2_int_status_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t reserved0 : 8;
            uint32_t tsu_evnt : 1; // Event caused by TSU
            uint32_t tsu_irq : 1; // Interrupt caused by TSU
            uint32_t reserved1 : 10;
            uint32_t rxev_evnt : 1; // Event caused by PLE's SEV
            uint32_t rxev_irq : 1; // Interrupt caused by PLE's SEV
            uint32_t reserved2 : 2;
            uint32_t pmu_evnt : 1; // Event caused by PMU overflow
            uint32_t pmu_irq : 1; // Interrupt caused by PMU overflow
            uint32_t reserved3 : 1;
            uint32_t pmu_eng : 1; // Event or interrupt caused by engine PMU
            uint32_t tol_err : 1; // Tolerable error
            uint32_t func_err : 1; // Functional error
            uint32_t rec_err : 1; // Recoverable error
            uint32_t unrec_err : 1; // Unrecoverable error
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_int_status_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_tsu_evnt() const { uint32_t value = static_cast<uint32_t>(bits.tsu_evnt); return value;}
    CONSTEXPR void set_tsu_evnt(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.tsu_evnt = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_tsu_irq() const { uint32_t value = static_cast<uint32_t>(bits.tsu_irq); return value;}
    CONSTEXPR void set_tsu_irq(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.tsu_irq = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_rxev_evnt() const { uint32_t value = static_cast<uint32_t>(bits.rxev_evnt); return value;}
    CONSTEXPR void set_rxev_evnt(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.rxev_evnt = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_rxev_irq() const { uint32_t value = static_cast<uint32_t>(bits.rxev_irq); return value;}
    CONSTEXPR void set_rxev_irq(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.rxev_irq = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_pmu_evnt() const { uint32_t value = static_cast<uint32_t>(bits.pmu_evnt); return value;}
    CONSTEXPR void set_pmu_evnt(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.pmu_evnt = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_pmu_irq() const { uint32_t value = static_cast<uint32_t>(bits.pmu_irq); return value;}
    CONSTEXPR void set_pmu_irq(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.pmu_irq = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_pmu_eng() const { uint32_t value = static_cast<uint32_t>(bits.pmu_eng); return value;}
    CONSTEXPR void set_pmu_eng(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.pmu_eng = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_tol_err() const { uint32_t value = static_cast<uint32_t>(bits.tol_err); return value;}
    CONSTEXPR void set_tol_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.tol_err = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_func_err() const { uint32_t value = static_cast<uint32_t>(bits.func_err); return value;}
    CONSTEXPR void set_func_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.func_err = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_rec_err() const { uint32_t value = static_cast<uint32_t>(bits.rec_err); return value;}
    CONSTEXPR void set_rec_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.rec_err = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_unrec_err() const { uint32_t value = static_cast<uint32_t>(bits.unrec_err); return value;}
    CONSTEXPR void set_unrec_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.unrec_err = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_ext_status_r - External status register used by the NCU's MCU
//
struct dl2_ext_status_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t reserved0 : 4;
            uint32_t setirq_evnt : 1; // Event caused by SETIRQ_INT
            uint32_t setirq_irq : 1; // Interrupt caused by SETIRQ_INT
            uint32_t gp_evnt : 1; // Event caused by host write to GPreg
            uint32_t reserved1 : 25;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_ext_status_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_setirq_evnt() const { uint32_t value = static_cast<uint32_t>(bits.setirq_evnt); return value;}
    CONSTEXPR void set_setirq_evnt(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.setirq_evnt = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_setirq_irq() const { uint32_t value = static_cast<uint32_t>(bits.setirq_irq); return value;}
    CONSTEXPR void set_setirq_irq(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.setirq_irq = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_gp_evnt() const { uint32_t value = static_cast<uint32_t>(bits.gp_evnt); return value;}
    CONSTEXPR void set_gp_evnt(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.gp_evnt = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_gp0_r - General purpose register 0
//
struct dl2_gp0_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t gp0 : 32; // General purpose register 0
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_gp0_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_gp0() const { uint32_t value = static_cast<uint32_t>(bits.gp0); return value;}
    CONSTEXPR void set_gp0(uint32_t value) { bits.gp0 = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_gp1_r - General purpose register 1
//
struct dl2_gp1_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t gp1 : 32; // General purpose register 1
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_gp1_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_gp1() const { uint32_t value = static_cast<uint32_t>(bits.gp1); return value;}
    CONSTEXPR void set_gp1(uint32_t value) { bits.gp1 = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_gp2_r - General purpose register 2
//
struct dl2_gp2_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t gp2 : 32; // General purpose register 2
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_gp2_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_gp2() const { uint32_t value = static_cast<uint32_t>(bits.gp2); return value;}
    CONSTEXPR void set_gp2(uint32_t value) { bits.gp2 = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_gp3_r - General purpose register 3
//
struct dl2_gp3_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t gp3 : 32; // General purpose register 3
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_gp3_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_gp3() const { uint32_t value = static_cast<uint32_t>(bits.gp3); return value;}
    CONSTEXPR void set_gp3(uint32_t value) { bits.gp3 = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_gp4_r - General purpose register 4
//
struct dl2_gp4_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t gp4 : 32; // General purpose register 4
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_gp4_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_gp4() const { uint32_t value = static_cast<uint32_t>(bits.gp4); return value;}
    CONSTEXPR void set_gp4(uint32_t value) { bits.gp4 = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_gp5_r - General purpose register 5
//
struct dl2_gp5_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t gp5 : 32; // General purpose register 5
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_gp5_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_gp5() const { uint32_t value = static_cast<uint32_t>(bits.gp5); return value;}
    CONSTEXPR void set_gp5(uint32_t value) { bits.gp5 = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_gp6_r - General purpose register 6
//
struct dl2_gp6_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t gp6 : 32; // General purpose register 6
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_gp6_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_gp6() const { uint32_t value = static_cast<uint32_t>(bits.gp6); return value;}
    CONSTEXPR void set_gp6(uint32_t value) { bits.gp6 = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_gp7_r - General purpose register 7
//
struct dl2_gp7_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t gp7 : 32; // General purpose register 7
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_gp7_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_gp7() const { uint32_t value = static_cast<uint32_t>(bits.gp7); return value;}
    CONSTEXPR void set_gp7(uint32_t value) { bits.gp7 = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_delegation_stream_security_r - Stream security state control delegation
//
struct dl2_delegation_stream_security_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusecsid0 : 1; // Delegation bit for stream 0 MMUSECSID register
            uint32_t protns0 : 1; // Delegation bit for stream 0 PROTNS register
            uint32_t mmusecsid1 : 1; // Delegation bit for stream 1 MMUSECSID register
            uint32_t protns1 : 1; // Delegation bit for stream 1 PROTNS register
            uint32_t mmusecsid2 : 1; // Delegation bit for stream 2 MMUSECSID register
            uint32_t protns2 : 1; // Delegation bit for stream 2 PROTNS register
            uint32_t mmusecsid3 : 1; // Delegation bit for stream 3 MMUSECSID register
            uint32_t protns3 : 1; // Delegation bit for stream 3 PROTNS register
            uint32_t mmusecsid4 : 1; // Delegation bit for stream 4 MMUSECSID register
            uint32_t protns4 : 1; // Delegation bit for stream 4 PROTNS register
            uint32_t mmusecsid5 : 1; // Delegation bit for stream 5 MMUSECSID register
            uint32_t protns5 : 1; // Delegation bit for stream 5 PROTNS register
            uint32_t mmusecsid6 : 1; // Delegation bit for stream 6 MMUSECSID register
            uint32_t protns6 : 1; // Delegation bit for stream 6 PROTNS register
            uint32_t mmusecsid7 : 1; // Delegation bit for stream 7 MMUSECSID register
            uint32_t protns7 : 1; // Delegation bit for stream 7 PROTNS register
            uint32_t mmusecsid8 : 1; // Delegation bit for stream 8 MMUSECSID register
            uint32_t protns8 : 1; // Delegation bit for stream 8 PROTNS register
            uint32_t reserved0 : 14;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_delegation_stream_security_r(uint32_t init=0) : word(init) {}
    CONSTEXPR delegation_t get_mmusecsid0() const { delegation_t value = static_cast<delegation_t>(bits.mmusecsid0); return value;}
    CONSTEXPR void set_mmusecsid0(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmusecsid0 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_protns0() const { delegation_t value = static_cast<delegation_t>(bits.protns0); return value;}
    CONSTEXPR void set_protns0(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.protns0 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_mmusecsid1() const { delegation_t value = static_cast<delegation_t>(bits.mmusecsid1); return value;}
    CONSTEXPR void set_mmusecsid1(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmusecsid1 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_protns1() const { delegation_t value = static_cast<delegation_t>(bits.protns1); return value;}
    CONSTEXPR void set_protns1(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.protns1 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_mmusecsid2() const { delegation_t value = static_cast<delegation_t>(bits.mmusecsid2); return value;}
    CONSTEXPR void set_mmusecsid2(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmusecsid2 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_protns2() const { delegation_t value = static_cast<delegation_t>(bits.protns2); return value;}
    CONSTEXPR void set_protns2(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.protns2 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_mmusecsid3() const { delegation_t value = static_cast<delegation_t>(bits.mmusecsid3); return value;}
    CONSTEXPR void set_mmusecsid3(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmusecsid3 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_protns3() const { delegation_t value = static_cast<delegation_t>(bits.protns3); return value;}
    CONSTEXPR void set_protns3(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.protns3 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_mmusecsid4() const { delegation_t value = static_cast<delegation_t>(bits.mmusecsid4); return value;}
    CONSTEXPR void set_mmusecsid4(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmusecsid4 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_protns4() const { delegation_t value = static_cast<delegation_t>(bits.protns4); return value;}
    CONSTEXPR void set_protns4(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.protns4 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_mmusecsid5() const { delegation_t value = static_cast<delegation_t>(bits.mmusecsid5); return value;}
    CONSTEXPR void set_mmusecsid5(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmusecsid5 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_protns5() const { delegation_t value = static_cast<delegation_t>(bits.protns5); return value;}
    CONSTEXPR void set_protns5(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.protns5 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_mmusecsid6() const { delegation_t value = static_cast<delegation_t>(bits.mmusecsid6); return value;}
    CONSTEXPR void set_mmusecsid6(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmusecsid6 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_protns6() const { delegation_t value = static_cast<delegation_t>(bits.protns6); return value;}
    CONSTEXPR void set_protns6(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.protns6 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_mmusecsid7() const { delegation_t value = static_cast<delegation_t>(bits.mmusecsid7); return value;}
    CONSTEXPR void set_mmusecsid7(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmusecsid7 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_protns7() const { delegation_t value = static_cast<delegation_t>(bits.protns7); return value;}
    CONSTEXPR void set_protns7(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.protns7 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_mmusecsid8() const { delegation_t value = static_cast<delegation_t>(bits.mmusecsid8); return value;}
    CONSTEXPR void set_mmusecsid8(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmusecsid8 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_protns8() const { delegation_t value = static_cast<delegation_t>(bits.protns8); return value;}
    CONSTEXPR void set_protns8(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.protns8 = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_delegation_nsaid_r - Non-secure Access Identifier delegation
//
struct dl2_delegation_nsaid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t nsaid0 : 1; // Delegation bit for stream 0 NSAID register
            uint32_t reserved0 : 1;
            uint32_t nsaid1 : 1; // Delegation bit for stream 1 NSAID register
            uint32_t reserved1 : 1;
            uint32_t nsaid2 : 1; // Delegation bit for stream 2 NSAID register
            uint32_t reserved2 : 1;
            uint32_t nsaid3 : 1; // Delegation bit for stream 3 NSAID register
            uint32_t reserved3 : 1;
            uint32_t nsaid4 : 1; // Delegation bit for stream 4 NSAID register
            uint32_t reserved4 : 1;
            uint32_t nsaid5 : 1; // Delegation bit for stream 5 NSAID register
            uint32_t reserved5 : 1;
            uint32_t nsaid6 : 1; // Delegation bit for stream 6 NSAID register
            uint32_t reserved6 : 1;
            uint32_t nsaid7 : 1; // Delegation bit for stream 7 NSAID register
            uint32_t reserved7 : 1;
            uint32_t nsaid8 : 1; // Delegation bit for stream 8 NSAID register
            uint32_t reserved8 : 15;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_delegation_nsaid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR delegation_t get_nsaid0() const { delegation_t value = static_cast<delegation_t>(bits.nsaid0); return value;}
    CONSTEXPR void set_nsaid0(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.nsaid0 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_nsaid1() const { delegation_t value = static_cast<delegation_t>(bits.nsaid1); return value;}
    CONSTEXPR void set_nsaid1(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.nsaid1 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_nsaid2() const { delegation_t value = static_cast<delegation_t>(bits.nsaid2); return value;}
    CONSTEXPR void set_nsaid2(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.nsaid2 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_nsaid3() const { delegation_t value = static_cast<delegation_t>(bits.nsaid3); return value;}
    CONSTEXPR void set_nsaid3(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.nsaid3 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_nsaid4() const { delegation_t value = static_cast<delegation_t>(bits.nsaid4); return value;}
    CONSTEXPR void set_nsaid4(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.nsaid4 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_nsaid5() const { delegation_t value = static_cast<delegation_t>(bits.nsaid5); return value;}
    CONSTEXPR void set_nsaid5(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.nsaid5 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_nsaid6() const { delegation_t value = static_cast<delegation_t>(bits.nsaid6); return value;}
    CONSTEXPR void set_nsaid6(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.nsaid6 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_nsaid7() const { delegation_t value = static_cast<delegation_t>(bits.nsaid7); return value;}
    CONSTEXPR void set_nsaid7(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.nsaid7 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_nsaid8() const { delegation_t value = static_cast<delegation_t>(bits.nsaid8); return value;}
    CONSTEXPR void set_nsaid8(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.nsaid8 = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_delegation_mmusid_r - MMU Stream Identifier delegation
//
struct dl2_delegation_mmusid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t sid0 : 2; // Delegation bit for stream 0 MMUSID register
            uint32_t sid1 : 2; // Delegation bit for stream 1 MMUSID register
            uint32_t sid2 : 2; // Delegation bit for stream 2 MMUSID register
            uint32_t sid3 : 2; // Delegation bit for stream 3 MMUSID register
            uint32_t sid4 : 2; // Delegation bit for stream 4 MMUSID register
            uint32_t sid5 : 2; // Delegation bit for stream 5 MMUSID register
            uint32_t sid6 : 2; // Delegation bit for stream 6 MMUSID register
            uint32_t sid7 : 2; // Delegation bit for stream 7 MMUSID register
            uint32_t sid8 : 2; // Delegation bit for stream 8 MMUSID register
            uint32_t reserved0 : 14;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_delegation_mmusid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR streamid_delegation_t get_sid0() const { streamid_delegation_t value = static_cast<streamid_delegation_t>(bits.sid0); return value;}
    CONSTEXPR void set_sid0(streamid_delegation_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.sid0 = static_cast<uint32_t>(value); }
    CONSTEXPR streamid_delegation_t get_sid1() const { streamid_delegation_t value = static_cast<streamid_delegation_t>(bits.sid1); return value;}
    CONSTEXPR void set_sid1(streamid_delegation_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.sid1 = static_cast<uint32_t>(value); }
    CONSTEXPR streamid_delegation_t get_sid2() const { streamid_delegation_t value = static_cast<streamid_delegation_t>(bits.sid2); return value;}
    CONSTEXPR void set_sid2(streamid_delegation_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.sid2 = static_cast<uint32_t>(value); }
    CONSTEXPR streamid_delegation_t get_sid3() const { streamid_delegation_t value = static_cast<streamid_delegation_t>(bits.sid3); return value;}
    CONSTEXPR void set_sid3(streamid_delegation_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.sid3 = static_cast<uint32_t>(value); }
    CONSTEXPR streamid_delegation_t get_sid4() const { streamid_delegation_t value = static_cast<streamid_delegation_t>(bits.sid4); return value;}
    CONSTEXPR void set_sid4(streamid_delegation_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.sid4 = static_cast<uint32_t>(value); }
    CONSTEXPR streamid_delegation_t get_sid5() const { streamid_delegation_t value = static_cast<streamid_delegation_t>(bits.sid5); return value;}
    CONSTEXPR void set_sid5(streamid_delegation_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.sid5 = static_cast<uint32_t>(value); }
    CONSTEXPR streamid_delegation_t get_sid6() const { streamid_delegation_t value = static_cast<streamid_delegation_t>(bits.sid6); return value;}
    CONSTEXPR void set_sid6(streamid_delegation_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.sid6 = static_cast<uint32_t>(value); }
    CONSTEXPR streamid_delegation_t get_sid7() const { streamid_delegation_t value = static_cast<streamid_delegation_t>(bits.sid7); return value;}
    CONSTEXPR void set_sid7(streamid_delegation_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.sid7 = static_cast<uint32_t>(value); }
    CONSTEXPR streamid_delegation_t get_sid8() const { streamid_delegation_t value = static_cast<streamid_delegation_t>(bits.sid8); return value;}
    CONSTEXPR void set_sid8(streamid_delegation_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.sid8 = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_delegation_mmussid_r - MMU Sub-stream Stream ID delegation
//
struct dl2_delegation_mmussid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t ssid0 : 2; // Delegation bit for stream 0 MMUSSID register
            uint32_t ssid1 : 2; // Delegation bit for stream 1 MMUSSID register
            uint32_t ssid2 : 2; // Delegation bit for stream 2 MMUSSID register
            uint32_t ssid3 : 2; // Delegation bit for stream 3 MMUSSID register
            uint32_t ssid4 : 2; // Delegation bit for stream 4 MMUSSID register
            uint32_t ssid5 : 2; // Delegation bit for stream 5 MMUSSID register
            uint32_t ssid6 : 2; // Delegation bit for stream 6 MMUSSID register
            uint32_t ssid7 : 2; // Delegation bit for stream 7 MMUSSID register
            uint32_t ssid8 : 2; // Delegation bit for stream 8 MMUSSID register
            uint32_t reserved0 : 14;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_delegation_mmussid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR substreamid_delegation_t get_ssid0() const { substreamid_delegation_t value = static_cast<substreamid_delegation_t>(bits.ssid0); return value;}
    CONSTEXPR void set_ssid0(substreamid_delegation_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.ssid0 = static_cast<uint32_t>(value); }
    CONSTEXPR substreamid_delegation_t get_ssid1() const { substreamid_delegation_t value = static_cast<substreamid_delegation_t>(bits.ssid1); return value;}
    CONSTEXPR void set_ssid1(substreamid_delegation_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.ssid1 = static_cast<uint32_t>(value); }
    CONSTEXPR substreamid_delegation_t get_ssid2() const { substreamid_delegation_t value = static_cast<substreamid_delegation_t>(bits.ssid2); return value;}
    CONSTEXPR void set_ssid2(substreamid_delegation_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.ssid2 = static_cast<uint32_t>(value); }
    CONSTEXPR substreamid_delegation_t get_ssid3() const { substreamid_delegation_t value = static_cast<substreamid_delegation_t>(bits.ssid3); return value;}
    CONSTEXPR void set_ssid3(substreamid_delegation_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.ssid3 = static_cast<uint32_t>(value); }
    CONSTEXPR substreamid_delegation_t get_ssid4() const { substreamid_delegation_t value = static_cast<substreamid_delegation_t>(bits.ssid4); return value;}
    CONSTEXPR void set_ssid4(substreamid_delegation_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.ssid4 = static_cast<uint32_t>(value); }
    CONSTEXPR substreamid_delegation_t get_ssid5() const { substreamid_delegation_t value = static_cast<substreamid_delegation_t>(bits.ssid5); return value;}
    CONSTEXPR void set_ssid5(substreamid_delegation_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.ssid5 = static_cast<uint32_t>(value); }
    CONSTEXPR substreamid_delegation_t get_ssid6() const { substreamid_delegation_t value = static_cast<substreamid_delegation_t>(bits.ssid6); return value;}
    CONSTEXPR void set_ssid6(substreamid_delegation_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.ssid6 = static_cast<uint32_t>(value); }
    CONSTEXPR substreamid_delegation_t get_ssid7() const { substreamid_delegation_t value = static_cast<substreamid_delegation_t>(bits.ssid7); return value;}
    CONSTEXPR void set_ssid7(substreamid_delegation_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.ssid7 = static_cast<uint32_t>(value); }
    CONSTEXPR substreamid_delegation_t get_ssid8() const { substreamid_delegation_t value = static_cast<substreamid_delegation_t>(bits.ssid8); return value;}
    CONSTEXPR void set_ssid8(substreamid_delegation_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.ssid8 = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_delegation_mmussidv_r - MMU Sub-stream Stream IDV delegation
//
struct dl2_delegation_mmussidv_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t ssidv0 : 1; // Delegation bit for stream 0 MMUSSIDV register
            uint32_t ssidv1 : 1; // Delegation bit for stream 1 MMUSSIDV register
            uint32_t ssidv2 : 1; // Delegation bit for stream 2 MMUSSIDV register
            uint32_t ssidv3 : 1; // Delegation bit for stream 3 MMUSSIDV register
            uint32_t ssidv4 : 1; // Delegation bit for stream 4 MMUSSIDV register
            uint32_t ssidv5 : 1; // Delegation bit for stream 5 MMUSSIDV register
            uint32_t ssidv6 : 1; // Delegation bit for stream 6 MMUSSIDV register
            uint32_t ssidv7 : 1; // Delegation bit for stream 7 MMUSSIDV register
            uint32_t ssidv8 : 1; // Delegation bit for stream 8 MMUSSIDV register
            uint32_t reserved0 : 23;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_delegation_mmussidv_r(uint32_t init=0) : word(init) {}
    CONSTEXPR delegation_t get_ssidv0() const { delegation_t value = static_cast<delegation_t>(bits.ssidv0); return value;}
    CONSTEXPR void set_ssidv0(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ssidv0 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_ssidv1() const { delegation_t value = static_cast<delegation_t>(bits.ssidv1); return value;}
    CONSTEXPR void set_ssidv1(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ssidv1 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_ssidv2() const { delegation_t value = static_cast<delegation_t>(bits.ssidv2); return value;}
    CONSTEXPR void set_ssidv2(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ssidv2 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_ssidv3() const { delegation_t value = static_cast<delegation_t>(bits.ssidv3); return value;}
    CONSTEXPR void set_ssidv3(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ssidv3 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_ssidv4() const { delegation_t value = static_cast<delegation_t>(bits.ssidv4); return value;}
    CONSTEXPR void set_ssidv4(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ssidv4 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_ssidv5() const { delegation_t value = static_cast<delegation_t>(bits.ssidv5); return value;}
    CONSTEXPR void set_ssidv5(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ssidv5 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_ssidv6() const { delegation_t value = static_cast<delegation_t>(bits.ssidv6); return value;}
    CONSTEXPR void set_ssidv6(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ssidv6 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_ssidv7() const { delegation_t value = static_cast<delegation_t>(bits.ssidv7); return value;}
    CONSTEXPR void set_ssidv7(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ssidv7 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_ssidv8() const { delegation_t value = static_cast<delegation_t>(bits.ssidv8); return value;}
    CONSTEXPR void set_ssidv8(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ssidv8 = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_delegation_attr_control_r - Attribute Control delegation
//
struct dl2_delegation_attr_control_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t attrctrl0 : 1; // Delegation bit for stream 0 Attribute Control register
            uint32_t attrctrl1 : 1; // Delegation bit for stream 1 Attribute Control register
            uint32_t attrctrl2 : 1; // Delegation bit for stream 2 Attribute Control register
            uint32_t attrctrl3 : 1; // Delegation bit for stream 3 Attribute Control register
            uint32_t attrctrl4 : 1; // Delegation bit for stream 4 Attribute Control register
            uint32_t attrctrl5 : 1; // Delegation bit for stream 5 Attribute Control register
            uint32_t attrctrl6 : 1; // Delegation bit for stream 6 Attribute Control register
            uint32_t attrctrl7 : 1; // Delegation bit for stream 7 Attribute Control register
            uint32_t attrctrl8 : 1; // Delegation bit for stream 8 Attribute Control register
            uint32_t reserved0 : 23;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_delegation_attr_control_r(uint32_t init=0) : word(init) {}
    CONSTEXPR delegation_t get_attrctrl0() const { delegation_t value = static_cast<delegation_t>(bits.attrctrl0); return value;}
    CONSTEXPR void set_attrctrl0(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.attrctrl0 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_attrctrl1() const { delegation_t value = static_cast<delegation_t>(bits.attrctrl1); return value;}
    CONSTEXPR void set_attrctrl1(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.attrctrl1 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_attrctrl2() const { delegation_t value = static_cast<delegation_t>(bits.attrctrl2); return value;}
    CONSTEXPR void set_attrctrl2(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.attrctrl2 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_attrctrl3() const { delegation_t value = static_cast<delegation_t>(bits.attrctrl3); return value;}
    CONSTEXPR void set_attrctrl3(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.attrctrl3 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_attrctrl4() const { delegation_t value = static_cast<delegation_t>(bits.attrctrl4); return value;}
    CONSTEXPR void set_attrctrl4(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.attrctrl4 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_attrctrl5() const { delegation_t value = static_cast<delegation_t>(bits.attrctrl5); return value;}
    CONSTEXPR void set_attrctrl5(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.attrctrl5 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_attrctrl6() const { delegation_t value = static_cast<delegation_t>(bits.attrctrl6); return value;}
    CONSTEXPR void set_attrctrl6(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.attrctrl6 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_attrctrl7() const { delegation_t value = static_cast<delegation_t>(bits.attrctrl7); return value;}
    CONSTEXPR void set_attrctrl7(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.attrctrl7 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_attrctrl8() const { delegation_t value = static_cast<delegation_t>(bits.attrctrl8); return value;}
    CONSTEXPR void set_attrctrl8(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.attrctrl8 = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_delegation_memattr_r - Memory Attributes delegation
//
struct dl2_delegation_memattr_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t memattr0 : 1; // Delegation bit for stream 0 Memory Attributes register
            uint32_t memattr1 : 1; // Delegation bit for stream 1 Memory Attributes register
            uint32_t memattr2 : 1; // Delegation bit for stream 2 Memory Attributes register
            uint32_t memattr3 : 1; // Delegation bit for stream 3 Memory Attributes register
            uint32_t memattr4 : 1; // Delegation bit for stream 4 Memory Attributes register
            uint32_t memattr5 : 1; // Delegation bit for stream 5 Memory Attributes register
            uint32_t memattr6 : 1; // Delegation bit for stream 6 Memory Attributes register
            uint32_t memattr7 : 1; // Delegation bit for stream 7 Memory Attributes register
            uint32_t memattr8 : 1; // Delegation bit for stream 8 Memory Attributes register
            uint32_t reserved0 : 23;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_delegation_memattr_r(uint32_t init=0) : word(init) {}
    CONSTEXPR delegation_t get_memattr0() const { delegation_t value = static_cast<delegation_t>(bits.memattr0); return value;}
    CONSTEXPR void set_memattr0(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.memattr0 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_memattr1() const { delegation_t value = static_cast<delegation_t>(bits.memattr1); return value;}
    CONSTEXPR void set_memattr1(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.memattr1 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_memattr2() const { delegation_t value = static_cast<delegation_t>(bits.memattr2); return value;}
    CONSTEXPR void set_memattr2(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.memattr2 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_memattr3() const { delegation_t value = static_cast<delegation_t>(bits.memattr3); return value;}
    CONSTEXPR void set_memattr3(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.memattr3 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_memattr4() const { delegation_t value = static_cast<delegation_t>(bits.memattr4); return value;}
    CONSTEXPR void set_memattr4(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.memattr4 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_memattr5() const { delegation_t value = static_cast<delegation_t>(bits.memattr5); return value;}
    CONSTEXPR void set_memattr5(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.memattr5 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_memattr6() const { delegation_t value = static_cast<delegation_t>(bits.memattr6); return value;}
    CONSTEXPR void set_memattr6(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.memattr6 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_memattr7() const { delegation_t value = static_cast<delegation_t>(bits.memattr7); return value;}
    CONSTEXPR void set_memattr7(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.memattr7 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_memattr8() const { delegation_t value = static_cast<delegation_t>(bits.memattr8); return value;}
    CONSTEXPR void set_memattr8(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.memattr8 = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_delegation_address_extend_r - Extended address bits control delegation
//
struct dl2_delegation_address_extend_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t addressextend0 : 1; // Delegation bit for stream 0 ADDRESSEXTEND register
            uint32_t reserved0 : 1;
            uint32_t addressextend1 : 1; // Delegation bit for stream 1 ADDRESSEXTEND register
            uint32_t reserved1 : 1;
            uint32_t addressextend2 : 1; // Delegation bit for stream 2 ADDRESSEXTEND register
            uint32_t reserved2 : 27;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_delegation_address_extend_r(uint32_t init=0) : word(init) {}
    CONSTEXPR delegation_t get_addressextend0() const { delegation_t value = static_cast<delegation_t>(bits.addressextend0); return value;}
    CONSTEXPR void set_addressextend0(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.addressextend0 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_addressextend1() const { delegation_t value = static_cast<delegation_t>(bits.addressextend1); return value;}
    CONSTEXPR void set_addressextend1(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.addressextend1 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_addressextend2() const { delegation_t value = static_cast<delegation_t>(bits.addressextend2); return value;}
    CONSTEXPR void set_addressextend2(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.addressextend2 = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_stream0_stream_security_r - Stream 0 - Security State
//
struct dl2_stream0_stream_security_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusecsid : 1; // MMU stream security state
            uint32_t protns : 1; // AXI stream security state
            uint32_t reserved0 : 30;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_stream0_stream_security_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmusecsid() const { uint32_t value = static_cast<uint32_t>(bits.mmusecsid); return value;}
    CONSTEXPR void set_mmusecsid(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmusecsid = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_protns() const { uint32_t value = static_cast<uint32_t>(bits.protns); return value;}
    CONSTEXPR void set_protns(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.protns = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_stream0_nsaid_r - Stream 0 - Non-secure Access Identifier
//
struct dl2_stream0_nsaid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t nsaid : 4; // Non-Secure Address Identifier
            uint32_t reserved0 : 28;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_stream0_nsaid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_nsaid() const { uint32_t value = static_cast<uint32_t>(bits.nsaid); return value;}
    CONSTEXPR void set_nsaid(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.nsaid = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_stream0_mmusid_r - Stream 0 - MMU Stream Identifier
//
struct dl2_stream0_mmusid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusid : 32; // MMU Stream ID (actual width is implementation defined)
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_stream0_mmusid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmusid() const { uint32_t value = static_cast<uint32_t>(bits.mmusid); return value;}
    CONSTEXPR void set_mmusid(uint32_t value) { bits.mmusid = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_stream0_mmussid_r - Stream 0 - MMU Sub-stream Stream Identifier
//
struct dl2_stream0_mmussid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmussid : 20; // MMU Sub-Stream ID (actual width is implementation defined)
            uint32_t reserved0 : 11;
            uint32_t mmussidv : 1; // MMUSSID valid bit
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_stream0_mmussid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmussid() const { uint32_t value = static_cast<uint32_t>(bits.mmussid); return value;}
    CONSTEXPR void set_mmussid(uint32_t value) { assert(static_cast<uint32_t>(value) < 1048576u); bits.mmussid = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mmussidv() const { uint32_t value = static_cast<uint32_t>(bits.mmussidv); return value;}
    CONSTEXPR void set_mmussidv(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmussidv = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_stream0_attr_control_r - Stream 0 - Attribute Control
//
struct dl2_stream0_attr_control_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t attrlocked : 1; // Stream attributes locked
            uint32_t reserved0 : 31;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_stream0_attr_control_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_attrlocked() const { uint32_t value = static_cast<uint32_t>(bits.attrlocked); return value;}
    CONSTEXPR void set_attrlocked(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.attrlocked = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_stream0_memattr_r - Stream 0 - Memory Attributes
//
struct dl2_stream0_memattr_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t memattr : 4; // Memory attributes
            uint32_t reserved0 : 28;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_stream0_memattr_r(uint32_t init=0) : word(init) {}
    CONSTEXPR memory_attributes_t get_memattr() const { memory_attributes_t value = static_cast<memory_attributes_t>(bits.memattr); return value;}
    CONSTEXPR void set_memattr(memory_attributes_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.memattr = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_stream0_address_extend_r - Stream 0 - Extended address bits per stream
//
struct dl2_stream0_address_extend_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t reserved0 : 9;
            uint32_t addrextend : 20; // Address extension bits [48:29]
            uint32_t reserved1 : 3;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_stream0_address_extend_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_addrextend() const { uint32_t value = static_cast<uint32_t>(bits.addrextend); return value;}
    CONSTEXPR void set_addrextend(uint32_t value) { assert(static_cast<uint32_t>(value) < 1048576u); bits.addrextend = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_stream1_stream_security_r - Stream 1 - Security State
//
struct dl2_stream1_stream_security_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusecsid : 1; // MMU stream security state
            uint32_t protns : 1; // AXI stream security state
            uint32_t reserved0 : 30;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_stream1_stream_security_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmusecsid() const { uint32_t value = static_cast<uint32_t>(bits.mmusecsid); return value;}
    CONSTEXPR void set_mmusecsid(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmusecsid = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_protns() const { uint32_t value = static_cast<uint32_t>(bits.protns); return value;}
    CONSTEXPR void set_protns(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.protns = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_stream1_nsaid_r - Stream 1 - Non-secure Access Identifier
//
struct dl2_stream1_nsaid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t nsaid : 4; // Non-Secure Address Identifier
            uint32_t reserved0 : 28;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_stream1_nsaid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_nsaid() const { uint32_t value = static_cast<uint32_t>(bits.nsaid); return value;}
    CONSTEXPR void set_nsaid(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.nsaid = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_stream1_mmusid_r - Stream 1 - MMU Stream Identifier
//
struct dl2_stream1_mmusid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusid : 32; // MMU Stream ID (actual width is implementation defined)
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_stream1_mmusid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmusid() const { uint32_t value = static_cast<uint32_t>(bits.mmusid); return value;}
    CONSTEXPR void set_mmusid(uint32_t value) { bits.mmusid = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_stream1_mmussid_r - Stream 1 - MMU Sub-stream Stream Identifier
//
struct dl2_stream1_mmussid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmussid : 20; // MMU Sub-Stream ID (actual width is implementation defined)
            uint32_t reserved0 : 11;
            uint32_t mmussidv : 1; // MMUSSID valid bit
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_stream1_mmussid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmussid() const { uint32_t value = static_cast<uint32_t>(bits.mmussid); return value;}
    CONSTEXPR void set_mmussid(uint32_t value) { assert(static_cast<uint32_t>(value) < 1048576u); bits.mmussid = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mmussidv() const { uint32_t value = static_cast<uint32_t>(bits.mmussidv); return value;}
    CONSTEXPR void set_mmussidv(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmussidv = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_stream1_attr_control_r - Stream 1 - Attribute Control
//
struct dl2_stream1_attr_control_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t attrlocked : 1; // Stream attributes locked
            uint32_t reserved0 : 31;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_stream1_attr_control_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_attrlocked() const { uint32_t value = static_cast<uint32_t>(bits.attrlocked); return value;}
    CONSTEXPR void set_attrlocked(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.attrlocked = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_stream1_memattr_r - Stream 1 - Memory Attributes
//
struct dl2_stream1_memattr_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t memattr : 4; // Memory attributes
            uint32_t reserved0 : 28;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_stream1_memattr_r(uint32_t init=0) : word(init) {}
    CONSTEXPR memory_attributes_t get_memattr() const { memory_attributes_t value = static_cast<memory_attributes_t>(bits.memattr); return value;}
    CONSTEXPR void set_memattr(memory_attributes_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.memattr = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_stream1_address_extend_r - Stream 1 - Extended address bits per stream
//
struct dl2_stream1_address_extend_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t reserved0 : 9;
            uint32_t addrextend : 20; // Address extension bits [48:29]
            uint32_t reserved1 : 3;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_stream1_address_extend_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_addrextend() const { uint32_t value = static_cast<uint32_t>(bits.addrextend); return value;}
    CONSTEXPR void set_addrextend(uint32_t value) { assert(static_cast<uint32_t>(value) < 1048576u); bits.addrextend = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_stream2_stream_security_r - Stream 2 - Security State
//
struct dl2_stream2_stream_security_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusecsid : 1; // MMU stream security state
            uint32_t protns : 1; // AXI stream security state
            uint32_t reserved0 : 30;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_stream2_stream_security_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmusecsid() const { uint32_t value = static_cast<uint32_t>(bits.mmusecsid); return value;}
    CONSTEXPR void set_mmusecsid(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmusecsid = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_protns() const { uint32_t value = static_cast<uint32_t>(bits.protns); return value;}
    CONSTEXPR void set_protns(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.protns = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_stream2_nsaid_r - Stream 2 - Non-secure Access Identifier
//
struct dl2_stream2_nsaid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t nsaid : 4; // Non-Secure Address Identifier
            uint32_t reserved0 : 28;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_stream2_nsaid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_nsaid() const { uint32_t value = static_cast<uint32_t>(bits.nsaid); return value;}
    CONSTEXPR void set_nsaid(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.nsaid = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_stream2_mmusid_r - Stream 2 - MMU Stream Identifier
//
struct dl2_stream2_mmusid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusid : 32; // MMU Stream ID (actual width is implementation defined)
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_stream2_mmusid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmusid() const { uint32_t value = static_cast<uint32_t>(bits.mmusid); return value;}
    CONSTEXPR void set_mmusid(uint32_t value) { bits.mmusid = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_stream2_mmussid_r - Stream 2 - MMU Sub-stream Stream Identifier
//
struct dl2_stream2_mmussid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmussid : 20; // MMU Sub-Stream ID (actual width is implementation defined)
            uint32_t reserved0 : 11;
            uint32_t mmussidv : 1; // MMUSSID valid bit
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_stream2_mmussid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmussid() const { uint32_t value = static_cast<uint32_t>(bits.mmussid); return value;}
    CONSTEXPR void set_mmussid(uint32_t value) { assert(static_cast<uint32_t>(value) < 1048576u); bits.mmussid = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mmussidv() const { uint32_t value = static_cast<uint32_t>(bits.mmussidv); return value;}
    CONSTEXPR void set_mmussidv(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmussidv = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_stream2_attr_control_r - Stream 2 - Attribute Control
//
struct dl2_stream2_attr_control_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t attrlocked : 1; // Stream attributes locked
            uint32_t reserved0 : 31;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_stream2_attr_control_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_attrlocked() const { uint32_t value = static_cast<uint32_t>(bits.attrlocked); return value;}
    CONSTEXPR void set_attrlocked(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.attrlocked = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_stream2_memattr_r - Stream 2 - Memory Attributes
//
struct dl2_stream2_memattr_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t memattr : 4; // Memory attributes
            uint32_t reserved0 : 28;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_stream2_memattr_r(uint32_t init=0) : word(init) {}
    CONSTEXPR memory_attributes_t get_memattr() const { memory_attributes_t value = static_cast<memory_attributes_t>(bits.memattr); return value;}
    CONSTEXPR void set_memattr(memory_attributes_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.memattr = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_stream2_address_extend_r - Stream 2 - Extended address bits per stream
//
struct dl2_stream2_address_extend_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t reserved0 : 9;
            uint32_t addrextend : 20; // Address extension bits [48:29]
            uint32_t reserved1 : 3;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_stream2_address_extend_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_addrextend() const { uint32_t value = static_cast<uint32_t>(bits.addrextend); return value;}
    CONSTEXPR void set_addrextend(uint32_t value) { assert(static_cast<uint32_t>(value) < 1048576u); bits.addrextend = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_stream3_stream_security_r - Stream 3 - Security State
//
struct dl2_stream3_stream_security_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusecsid : 1; // MMU stream security state
            uint32_t protns : 1; // AXI stream security state
            uint32_t reserved0 : 30;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_stream3_stream_security_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmusecsid() const { uint32_t value = static_cast<uint32_t>(bits.mmusecsid); return value;}
    CONSTEXPR void set_mmusecsid(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmusecsid = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_protns() const { uint32_t value = static_cast<uint32_t>(bits.protns); return value;}
    CONSTEXPR void set_protns(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.protns = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_stream3_nsaid_r - Stream 3 - Non-secure Access Identifier
//
struct dl2_stream3_nsaid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t nsaid : 4; // Non-Secure Address Identifier
            uint32_t reserved0 : 28;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_stream3_nsaid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_nsaid() const { uint32_t value = static_cast<uint32_t>(bits.nsaid); return value;}
    CONSTEXPR void set_nsaid(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.nsaid = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_stream3_mmusid_r - Stream 3 - MMU Stream Identifier
//
struct dl2_stream3_mmusid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusid : 32; // MMU Stream ID (actual width is implementation defined)
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_stream3_mmusid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmusid() const { uint32_t value = static_cast<uint32_t>(bits.mmusid); return value;}
    CONSTEXPR void set_mmusid(uint32_t value) { bits.mmusid = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_stream3_mmussid_r - Stream 3 - MMU Sub-stream Stream Identifier
//
struct dl2_stream3_mmussid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmussid : 20; // MMU Sub-Stream ID (actual width is implementation defined)
            uint32_t reserved0 : 11;
            uint32_t mmussidv : 1; // MMUSSID valid bit
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_stream3_mmussid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmussid() const { uint32_t value = static_cast<uint32_t>(bits.mmussid); return value;}
    CONSTEXPR void set_mmussid(uint32_t value) { assert(static_cast<uint32_t>(value) < 1048576u); bits.mmussid = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mmussidv() const { uint32_t value = static_cast<uint32_t>(bits.mmussidv); return value;}
    CONSTEXPR void set_mmussidv(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmussidv = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_stream3_attr_control_r - Stream 3 - Attribute Control
//
struct dl2_stream3_attr_control_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t attrlocked : 1; // Stream attributes locked
            uint32_t reserved0 : 31;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_stream3_attr_control_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_attrlocked() const { uint32_t value = static_cast<uint32_t>(bits.attrlocked); return value;}
    CONSTEXPR void set_attrlocked(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.attrlocked = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_stream3_memattr_r - Stream 3 - Memory Attributes
//
struct dl2_stream3_memattr_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t memattr : 4; // Memory attributes
            uint32_t reserved0 : 28;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_stream3_memattr_r(uint32_t init=0) : word(init) {}
    CONSTEXPR memory_attributes_t get_memattr() const { memory_attributes_t value = static_cast<memory_attributes_t>(bits.memattr); return value;}
    CONSTEXPR void set_memattr(memory_attributes_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.memattr = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_stream4_stream_security_r - Stream 4 - Security State
//
struct dl2_stream4_stream_security_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusecsid : 1; // MMU stream security state
            uint32_t protns : 1; // AXI stream security state
            uint32_t reserved0 : 30;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_stream4_stream_security_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmusecsid() const { uint32_t value = static_cast<uint32_t>(bits.mmusecsid); return value;}
    CONSTEXPR void set_mmusecsid(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmusecsid = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_protns() const { uint32_t value = static_cast<uint32_t>(bits.protns); return value;}
    CONSTEXPR void set_protns(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.protns = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_stream4_nsaid_r - Stream 4 - Non-secure Access Identifier
//
struct dl2_stream4_nsaid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t nsaid : 4; // Non-Secure Address Identifier
            uint32_t reserved0 : 28;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_stream4_nsaid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_nsaid() const { uint32_t value = static_cast<uint32_t>(bits.nsaid); return value;}
    CONSTEXPR void set_nsaid(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.nsaid = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_stream4_mmusid_r - Stream 4 - MMU Stream Identifier
//
struct dl2_stream4_mmusid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusid : 32; // MMU Stream ID (actual width is implementation defined)
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_stream4_mmusid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmusid() const { uint32_t value = static_cast<uint32_t>(bits.mmusid); return value;}
    CONSTEXPR void set_mmusid(uint32_t value) { bits.mmusid = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_stream4_mmussid_r - Stream 4 - MMU Sub-stream Stream Identifier
//
struct dl2_stream4_mmussid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmussid : 20; // MMU Sub-Stream ID (actual width is implementation defined)
            uint32_t reserved0 : 11;
            uint32_t mmussidv : 1; // MMUSSID valid bit
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_stream4_mmussid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmussid() const { uint32_t value = static_cast<uint32_t>(bits.mmussid); return value;}
    CONSTEXPR void set_mmussid(uint32_t value) { assert(static_cast<uint32_t>(value) < 1048576u); bits.mmussid = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mmussidv() const { uint32_t value = static_cast<uint32_t>(bits.mmussidv); return value;}
    CONSTEXPR void set_mmussidv(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmussidv = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_stream4_attr_control_r - Stream 4 - Attribute Control
//
struct dl2_stream4_attr_control_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t attrlocked : 1; // Stream attributes locked
            uint32_t reserved0 : 31;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_stream4_attr_control_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_attrlocked() const { uint32_t value = static_cast<uint32_t>(bits.attrlocked); return value;}
    CONSTEXPR void set_attrlocked(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.attrlocked = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_stream4_memattr_r - Stream 4 - Memory Attributes
//
struct dl2_stream4_memattr_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t memattr : 4; // Memory attributes
            uint32_t reserved0 : 28;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_stream4_memattr_r(uint32_t init=0) : word(init) {}
    CONSTEXPR memory_attributes_t get_memattr() const { memory_attributes_t value = static_cast<memory_attributes_t>(bits.memattr); return value;}
    CONSTEXPR void set_memattr(memory_attributes_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.memattr = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_stream5_stream_security_r - Stream 5 - Security State
//
struct dl2_stream5_stream_security_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusecsid : 1; // MMU stream security state
            uint32_t protns : 1; // AXI stream security state
            uint32_t reserved0 : 30;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_stream5_stream_security_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmusecsid() const { uint32_t value = static_cast<uint32_t>(bits.mmusecsid); return value;}
    CONSTEXPR void set_mmusecsid(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmusecsid = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_protns() const { uint32_t value = static_cast<uint32_t>(bits.protns); return value;}
    CONSTEXPR void set_protns(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.protns = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_stream5_nsaid_r - Stream 5 - Non-secure Access Identifier
//
struct dl2_stream5_nsaid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t nsaid : 4; // Non-Secure Address Identifier
            uint32_t reserved0 : 28;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_stream5_nsaid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_nsaid() const { uint32_t value = static_cast<uint32_t>(bits.nsaid); return value;}
    CONSTEXPR void set_nsaid(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.nsaid = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_stream5_mmusid_r - Stream 5 - MMU Stream Identifier
//
struct dl2_stream5_mmusid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusid : 32; // MMU Stream ID (actual width is implementation defined)
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_stream5_mmusid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmusid() const { uint32_t value = static_cast<uint32_t>(bits.mmusid); return value;}
    CONSTEXPR void set_mmusid(uint32_t value) { bits.mmusid = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_stream5_mmussid_r - Stream 5 - MMU Sub-stream Stream Identifier
//
struct dl2_stream5_mmussid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmussid : 20; // MMU Sub-Stream ID (actual width is implementation defined)
            uint32_t reserved0 : 11;
            uint32_t mmussidv : 1; // MMUSSID valid bit
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_stream5_mmussid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmussid() const { uint32_t value = static_cast<uint32_t>(bits.mmussid); return value;}
    CONSTEXPR void set_mmussid(uint32_t value) { assert(static_cast<uint32_t>(value) < 1048576u); bits.mmussid = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mmussidv() const { uint32_t value = static_cast<uint32_t>(bits.mmussidv); return value;}
    CONSTEXPR void set_mmussidv(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmussidv = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_stream5_attr_control_r - Stream 5 - Attribute Control
//
struct dl2_stream5_attr_control_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t attrlocked : 1; // Stream attributes locked
            uint32_t reserved0 : 31;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_stream5_attr_control_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_attrlocked() const { uint32_t value = static_cast<uint32_t>(bits.attrlocked); return value;}
    CONSTEXPR void set_attrlocked(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.attrlocked = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_stream5_memattr_r - Stream 5 - Memory Attributes
//
struct dl2_stream5_memattr_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t memattr : 4; // Memory attributes
            uint32_t reserved0 : 28;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_stream5_memattr_r(uint32_t init=0) : word(init) {}
    CONSTEXPR memory_attributes_t get_memattr() const { memory_attributes_t value = static_cast<memory_attributes_t>(bits.memattr); return value;}
    CONSTEXPR void set_memattr(memory_attributes_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.memattr = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_stream6_stream_security_r - Stream 6 - Security State
//
struct dl2_stream6_stream_security_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusecsid : 1; // MMU stream security state
            uint32_t protns : 1; // AXI stream security state
            uint32_t reserved0 : 30;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_stream6_stream_security_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmusecsid() const { uint32_t value = static_cast<uint32_t>(bits.mmusecsid); return value;}
    CONSTEXPR void set_mmusecsid(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmusecsid = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_protns() const { uint32_t value = static_cast<uint32_t>(bits.protns); return value;}
    CONSTEXPR void set_protns(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.protns = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_stream6_nsaid_r - Stream 6 - Non-secure Access Identifier
//
struct dl2_stream6_nsaid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t nsaid : 4; // Non-Secure Address Identifier
            uint32_t reserved0 : 28;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_stream6_nsaid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_nsaid() const { uint32_t value = static_cast<uint32_t>(bits.nsaid); return value;}
    CONSTEXPR void set_nsaid(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.nsaid = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_stream6_mmusid_r - Stream 6 - MMU Stream Identifier
//
struct dl2_stream6_mmusid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusid : 32; // MMU Stream ID (actual width is implementation defined)
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_stream6_mmusid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmusid() const { uint32_t value = static_cast<uint32_t>(bits.mmusid); return value;}
    CONSTEXPR void set_mmusid(uint32_t value) { bits.mmusid = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_stream6_mmussid_r - Stream 6 - MMU Sub-stream Stream Identifier
//
struct dl2_stream6_mmussid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmussid : 20; // MMU Sub-Stream ID (actual width is implementation defined)
            uint32_t reserved0 : 11;
            uint32_t mmussidv : 1; // MMUSSID valid bit
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_stream6_mmussid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmussid() const { uint32_t value = static_cast<uint32_t>(bits.mmussid); return value;}
    CONSTEXPR void set_mmussid(uint32_t value) { assert(static_cast<uint32_t>(value) < 1048576u); bits.mmussid = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mmussidv() const { uint32_t value = static_cast<uint32_t>(bits.mmussidv); return value;}
    CONSTEXPR void set_mmussidv(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmussidv = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_stream6_attr_control_r - Stream 6 - Attribute Control
//
struct dl2_stream6_attr_control_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t attrlocked : 1; // Stream attributes locked
            uint32_t reserved0 : 31;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_stream6_attr_control_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_attrlocked() const { uint32_t value = static_cast<uint32_t>(bits.attrlocked); return value;}
    CONSTEXPR void set_attrlocked(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.attrlocked = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_stream6_memattr_r - Stream 6 - Memory Attributes
//
struct dl2_stream6_memattr_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t memattr : 4; // Memory attributes
            uint32_t reserved0 : 28;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_stream6_memattr_r(uint32_t init=0) : word(init) {}
    CONSTEXPR memory_attributes_t get_memattr() const { memory_attributes_t value = static_cast<memory_attributes_t>(bits.memattr); return value;}
    CONSTEXPR void set_memattr(memory_attributes_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.memattr = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_stream7_stream_security_r - Stream 7 - Security State
//
struct dl2_stream7_stream_security_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusecsid : 1; // MMU stream security state
            uint32_t protns : 1; // AXI stream security state
            uint32_t reserved0 : 30;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_stream7_stream_security_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmusecsid() const { uint32_t value = static_cast<uint32_t>(bits.mmusecsid); return value;}
    CONSTEXPR void set_mmusecsid(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmusecsid = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_protns() const { uint32_t value = static_cast<uint32_t>(bits.protns); return value;}
    CONSTEXPR void set_protns(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.protns = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_stream7_nsaid_r - Stream 7 - Non-secure Access Identifier
//
struct dl2_stream7_nsaid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t nsaid : 4; // Non-Secure Address Identifier
            uint32_t reserved0 : 28;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_stream7_nsaid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_nsaid() const { uint32_t value = static_cast<uint32_t>(bits.nsaid); return value;}
    CONSTEXPR void set_nsaid(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.nsaid = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_stream7_mmusid_r - Stream 7 - MMU Stream Identifier
//
struct dl2_stream7_mmusid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusid : 32; // MMU Stream ID (actual width is implementation defined)
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_stream7_mmusid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmusid() const { uint32_t value = static_cast<uint32_t>(bits.mmusid); return value;}
    CONSTEXPR void set_mmusid(uint32_t value) { bits.mmusid = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_stream7_mmussid_r - Stream 7 - MMU Sub-stream Stream Identifier
//
struct dl2_stream7_mmussid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmussid : 20; // MMU Sub-Stream ID (actual width is implementation defined)
            uint32_t reserved0 : 11;
            uint32_t mmussidv : 1; // MMUSSID valid bit
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_stream7_mmussid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmussid() const { uint32_t value = static_cast<uint32_t>(bits.mmussid); return value;}
    CONSTEXPR void set_mmussid(uint32_t value) { assert(static_cast<uint32_t>(value) < 1048576u); bits.mmussid = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mmussidv() const { uint32_t value = static_cast<uint32_t>(bits.mmussidv); return value;}
    CONSTEXPR void set_mmussidv(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmussidv = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_stream7_attr_control_r - Stream 7 - Attribute Control
//
struct dl2_stream7_attr_control_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t attrlocked : 1; // Stream attributes locked
            uint32_t reserved0 : 31;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_stream7_attr_control_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_attrlocked() const { uint32_t value = static_cast<uint32_t>(bits.attrlocked); return value;}
    CONSTEXPR void set_attrlocked(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.attrlocked = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_stream7_memattr_r - Stream 7 - Memory Attributes
//
struct dl2_stream7_memattr_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t memattr : 4; // Memory attributes
            uint32_t reserved0 : 28;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_stream7_memattr_r(uint32_t init=0) : word(init) {}
    CONSTEXPR memory_attributes_t get_memattr() const { memory_attributes_t value = static_cast<memory_attributes_t>(bits.memattr); return value;}
    CONSTEXPR void set_memattr(memory_attributes_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.memattr = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_stream8_stream_security_r - Stream 8 - Security State
//
struct dl2_stream8_stream_security_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusecsid : 1; // MMU stream security state
            uint32_t protns : 1; // AXI stream security state
            uint32_t reserved0 : 30;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_stream8_stream_security_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmusecsid() const { uint32_t value = static_cast<uint32_t>(bits.mmusecsid); return value;}
    CONSTEXPR void set_mmusecsid(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmusecsid = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_protns() const { uint32_t value = static_cast<uint32_t>(bits.protns); return value;}
    CONSTEXPR void set_protns(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.protns = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_stream8_nsaid_r - Stream 8 - Non-secure Access Identifier
//
struct dl2_stream8_nsaid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t nsaid : 4; // Non-Secure Address Identifier
            uint32_t reserved0 : 28;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_stream8_nsaid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_nsaid() const { uint32_t value = static_cast<uint32_t>(bits.nsaid); return value;}
    CONSTEXPR void set_nsaid(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.nsaid = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_stream8_mmusid_r - Stream 8 - MMU Stream Identifier
//
struct dl2_stream8_mmusid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusid : 32; // MMU Stream ID (actual width is implementation defined)
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_stream8_mmusid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmusid() const { uint32_t value = static_cast<uint32_t>(bits.mmusid); return value;}
    CONSTEXPR void set_mmusid(uint32_t value) { bits.mmusid = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_stream8_mmussid_r - Stream 8 - MMU Sub-stream Stream Identifier
//
struct dl2_stream8_mmussid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmussid : 20; // MMU Sub-Stream ID (actual width is implementation defined)
            uint32_t reserved0 : 11;
            uint32_t mmussidv : 1; // MMUSSID valid bit
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_stream8_mmussid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmussid() const { uint32_t value = static_cast<uint32_t>(bits.mmussid); return value;}
    CONSTEXPR void set_mmussid(uint32_t value) { assert(static_cast<uint32_t>(value) < 1048576u); bits.mmussid = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mmussidv() const { uint32_t value = static_cast<uint32_t>(bits.mmussidv); return value;}
    CONSTEXPR void set_mmussidv(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmussidv = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_stream8_attr_control_r - Stream 8 - Attribute Control
//
struct dl2_stream8_attr_control_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t attrlocked : 1; // Stream attributes locked
            uint32_t reserved0 : 31;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_stream8_attr_control_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_attrlocked() const { uint32_t value = static_cast<uint32_t>(bits.attrlocked); return value;}
    CONSTEXPR void set_attrlocked(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.attrlocked = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_stream8_memattr_r - Stream 8 - Memory Attributes
//
struct dl2_stream8_memattr_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t memattr : 4; // Memory attributes
            uint32_t reserved0 : 28;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_stream8_memattr_r(uint32_t init=0) : word(init) {}
    CONSTEXPR memory_attributes_t get_memattr() const { memory_attributes_t value = static_cast<memory_attributes_t>(bits.memattr); return value;}
    CONSTEXPR void set_memattr(memory_attributes_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.memattr = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_npu_id_r - NPU ID register
//
struct dl2_npu_id_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t version_status : 4; // Status of the NPU release
            uint32_t version_minor : 4; // Minor release version number
            uint32_t version_major : 4; // Major release version number
            uint32_t product_major : 4; // Product identifier
            uint32_t arch_rev : 8; // Architecture patch revision
            uint32_t arch_minor : 4; // Architecture minor revision
            uint32_t arch_major : 4; // Architecture major revision
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_npu_id_r(uint32_t init=0) : word(init) {}
    CONSTEXPR npu_version_status_t get_version_status() const { npu_version_status_t value = static_cast<npu_version_status_t>(bits.version_status); return value;}
    CONSTEXPR void set_version_status(npu_version_status_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.version_status = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_version_minor() const { uint32_t value = static_cast<uint32_t>(bits.version_minor); return value;}
    CONSTEXPR void set_version_minor(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.version_minor = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_version_major() const { uint32_t value = static_cast<uint32_t>(bits.version_major); return value;}
    CONSTEXPR void set_version_major(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.version_major = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_product_major() const { uint32_t value = static_cast<uint32_t>(bits.product_major); return value;}
    CONSTEXPR void set_product_major(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.product_major = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_arch_rev() const { uint32_t value = static_cast<uint32_t>(bits.arch_rev); return value;}
    CONSTEXPR void set_arch_rev(uint32_t value) { assert(static_cast<uint32_t>(value) < 256u); bits.arch_rev = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_arch_minor() const { uint32_t value = static_cast<uint32_t>(bits.arch_minor); return value;}
    CONSTEXPR void set_arch_minor(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.arch_minor = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_arch_major() const { uint32_t value = static_cast<uint32_t>(bits.arch_major); return value;}
    CONSTEXPR void set_arch_major(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.arch_major = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_unit_count_r - Units present count
//
struct dl2_unit_count_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t quad_count : 8; // Number of quads
            uint32_t engines_per_quad : 8; // Number of engines per quad
            uint32_t dfc_emc_per_engine : 4; // Number of memory controllers per engine
            uint32_t reserved0 : 12;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_unit_count_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_quad_count() const { uint32_t value = static_cast<uint32_t>(bits.quad_count); return value;}
    CONSTEXPR void set_quad_count(uint32_t value) { assert(static_cast<uint32_t>(value) < 256u); bits.quad_count = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_engines_per_quad() const { uint32_t value = static_cast<uint32_t>(bits.engines_per_quad); return value;}
    CONSTEXPR void set_engines_per_quad(uint32_t value) { assert(static_cast<uint32_t>(value) < 256u); bits.engines_per_quad = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_dfc_emc_per_engine() const { uint32_t value = static_cast<uint32_t>(bits.dfc_emc_per_engine); return value;}
    CONSTEXPR void set_dfc_emc_per_engine(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.dfc_emc_per_engine = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_mce_features_r - MCE features
//
struct dl2_mce_features_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t ifm_generated_per_engine : 4; // IFMs sent to broadcast network per engine
            uint32_t reserved0 : 4;
            uint32_t ofm_generated_per_engine : 4; // OFMs generated per Engine
            uint32_t mce_num_macs : 8; // Number of MAC units per MCE
            uint32_t mce_num_acc : 8; // Number of accumulators per MAC unit
            uint32_t winograd_support : 1; // Winograd funcationality present
            uint32_t tsu_16bit_sequence_support : 1; // TSU support for automatically sequencing 16 bit IFM and weights
            uint32_t ofm_scaling_16bit_support : 1; // Hardware support for scaling results from 16-bit operations
            uint32_t reserved1 : 1;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_mce_features_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_ifm_generated_per_engine() const { uint32_t value = static_cast<uint32_t>(bits.ifm_generated_per_engine); return value;}
    CONSTEXPR void set_ifm_generated_per_engine(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.ifm_generated_per_engine = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ofm_generated_per_engine() const { uint32_t value = static_cast<uint32_t>(bits.ofm_generated_per_engine); return value;}
    CONSTEXPR void set_ofm_generated_per_engine(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.ofm_generated_per_engine = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mce_num_macs() const { uint32_t value = static_cast<uint32_t>(bits.mce_num_macs); return value;}
    CONSTEXPR void set_mce_num_macs(uint32_t value) { assert(static_cast<uint32_t>(value) < 256u); bits.mce_num_macs = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mce_num_acc() const { uint32_t value = static_cast<uint32_t>(bits.mce_num_acc); return value;}
    CONSTEXPR void set_mce_num_acc(uint32_t value) { assert(static_cast<uint32_t>(value) < 256u); bits.mce_num_acc = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_winograd_support() const { uint32_t value = static_cast<uint32_t>(bits.winograd_support); return value;}
    CONSTEXPR void set_winograd_support(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.winograd_support = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_tsu_16bit_sequence_support() const { uint32_t value = static_cast<uint32_t>(bits.tsu_16bit_sequence_support); return value;}
    CONSTEXPR void set_tsu_16bit_sequence_support(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.tsu_16bit_sequence_support = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ofm_scaling_16bit_support() const { uint32_t value = static_cast<uint32_t>(bits.ofm_scaling_16bit_support); return value;}
    CONSTEXPR void set_ofm_scaling_16bit_support(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ofm_scaling_16bit_support = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_dfc_features_r - DFC features
//
struct dl2_dfc_features_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t dfc_mem_size_per_emc : 16; // DFC memory size per EMC
            uint32_t bank_count : 6; // Number of banks in DFC memory
            uint32_t activation_compression : 4; // Version of activation compression supported
            uint32_t reserved0 : 6;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_dfc_features_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_dfc_mem_size_per_emc() const { uint32_t value = static_cast<uint32_t>(bits.dfc_mem_size_per_emc); return (value << 12);}
    CONSTEXPR void set_dfc_mem_size_per_emc(uint32_t value) { assert(static_cast<uint32_t>((value >> 12)) < 65536u); bits.dfc_mem_size_per_emc = static_cast<uint32_t>((value >> 12)); }
    CONSTEXPR uint32_t get_bank_count() const { uint32_t value = static_cast<uint32_t>(bits.bank_count); return value;}
    CONSTEXPR void set_bank_count(uint32_t value) { assert(static_cast<uint32_t>(value) < 64u); bits.bank_count = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_activation_compression() const { uint32_t value = static_cast<uint32_t>(bits.activation_compression); return value;}
    CONSTEXPR void set_activation_compression(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.activation_compression = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_ple_features_r - PLE features
//
struct dl2_ple_features_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t ple_input_mem_size : 8; // PLE input memory size
            uint32_t ple_output_mem_size : 8; // PLE output memory size
            uint32_t ple_vrf_mem_size : 8; // PLE vector register file memory size
            uint32_t ple_mem_size : 8; // PLE base memory size
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_ple_features_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_ple_input_mem_size() const { uint32_t value = static_cast<uint32_t>(bits.ple_input_mem_size); return (value << 8);}
    CONSTEXPR void set_ple_input_mem_size(uint32_t value) { assert(static_cast<uint32_t>((value >> 8)) < 256u); bits.ple_input_mem_size = static_cast<uint32_t>((value >> 8)); }
    CONSTEXPR uint32_t get_ple_output_mem_size() const { uint32_t value = static_cast<uint32_t>(bits.ple_output_mem_size); return (value << 8);}
    CONSTEXPR void set_ple_output_mem_size(uint32_t value) { assert(static_cast<uint32_t>((value >> 8)) < 256u); bits.ple_output_mem_size = static_cast<uint32_t>((value >> 8)); }
    CONSTEXPR uint32_t get_ple_vrf_mem_size() const { uint32_t value = static_cast<uint32_t>(bits.ple_vrf_mem_size); return (value << 4);}
    CONSTEXPR void set_ple_vrf_mem_size(uint32_t value) { assert(static_cast<uint32_t>((value >> 4)) < 256u); bits.ple_vrf_mem_size = static_cast<uint32_t>((value >> 4)); }
    CONSTEXPR uint32_t get_ple_mem_size() const { uint32_t value = static_cast<uint32_t>(bits.ple_mem_size); return (value << 8);}
    CONSTEXPR void set_ple_mem_size(uint32_t value) { assert(static_cast<uint32_t>((value >> 8)) < 256u); bits.ple_mem_size = static_cast<uint32_t>((value >> 8)); }
#endif
};


//
// dl2_wd_features_r - Weight Decoder features
//
struct dl2_wd_features_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t buffer_size : 8; // Weight decoder buffer size
            uint32_t max_dim : 8; // Weight decoder max dimension
            uint32_t compression_version : 4; // Version of weight compression implemented
            uint32_t reserved0 : 12;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_wd_features_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_buffer_size() const { uint32_t value = static_cast<uint32_t>(bits.buffer_size); return value;}
    CONSTEXPR void set_buffer_size(uint32_t value) { assert(static_cast<uint32_t>(value) < 256u); bits.buffer_size = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_max_dim() const { uint32_t value = static_cast<uint32_t>(bits.max_dim); return value;}
    CONSTEXPR void set_max_dim(uint32_t value) { assert(static_cast<uint32_t>(value) < 256u); bits.max_dim = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_compression_version() const { uint32_t value = static_cast<uint32_t>(bits.compression_version); return value;}
    CONSTEXPR void set_compression_version(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.compression_version = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_vector_engine_features_r - PLE VE features
//
struct dl2_vector_engine_features_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t vector_engine_version : 4; // Version of the vector engine implemented
            uint32_t ple_lanes : 2; // Number of lanes in the PLE
            uint32_t reserved0 : 26;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_vector_engine_features_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_vector_engine_version() const { uint32_t value = static_cast<uint32_t>(bits.vector_engine_version); return value;}
    CONSTEXPR void set_vector_engine_version(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.vector_engine_version = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ple_lanes() const { uint32_t value = static_cast<uint32_t>(bits.ple_lanes); return (value + 1);}
    CONSTEXPR void set_ple_lanes(uint32_t value) { assert(static_cast<uint32_t>((value - 1)) < 4u); bits.ple_lanes = static_cast<uint32_t>((value - 1)); }
#endif
};


//
// dl2_ecoid_r - Encoding describing ECOs implemented
//
struct dl2_ecoid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t ecoid : 12; // Field for describing ECOs implemented
            uint32_t reserved0 : 20;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_ecoid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_ecoid() const { uint32_t value = static_cast<uint32_t>(bits.ecoid); return value;}
    CONSTEXPR void set_ecoid(uint32_t value) { assert(static_cast<uint32_t>(value) < 4096u); bits.ecoid = static_cast<uint32_t>(value); }
#endif
};


//
// dl2_streamid_width_r - Configured StreamID widths
//
struct dl2_streamid_width_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusid_w : 5; // Configured width of StreamID (AxMMUSID)
            uint32_t reserved0 : 3;
            uint32_t mmussid_w : 5; // Configured width of SubstreamID (AxMMUSSID)
            uint32_t reserved1 : 19;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl2_streamid_width_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmusid_w() const { uint32_t value = static_cast<uint32_t>(bits.mmusid_w); return (value + 1);}
    CONSTEXPR void set_mmusid_w(uint32_t value) { assert(static_cast<uint32_t>((value - 1)) < 32u); bits.mmusid_w = static_cast<uint32_t>((value - 1)); }
    CONSTEXPR uint32_t get_mmussid_w() const { uint32_t value = static_cast<uint32_t>(bits.mmussid_w); return (value + 1);}
    CONSTEXPR void set_mmussid_w(uint32_t value) { assert(static_cast<uint32_t>((value - 1)) < 32u); bits.mmussid_w = static_cast<uint32_t>((value - 1)); }
#endif
};


//
// dl3_ext_access_control_r - External Access Control
//
struct dl3_ext_access_control_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t excctlr : 1; // Execution control pages access control
            uint32_t ramctlr : 1; // Memory mapped RAMs access control
            uint32_t dbgctlr : 1; // PMU and DBG pages access control
            uint32_t reserved0 : 5;
            uint32_t reserved1 : 8;
            uint32_t reserved2 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_ext_access_control_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_excctlr() const { uint32_t value = static_cast<uint32_t>(bits.excctlr); return value;}
    CONSTEXPR void set_excctlr(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.excctlr = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ramctlr() const { uint32_t value = static_cast<uint32_t>(bits.ramctlr); return value;}
    CONSTEXPR void set_ramctlr(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ramctlr = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_dbgctlr() const { uint32_t value = static_cast<uint32_t>(bits.dbgctlr); return value;}
    CONSTEXPR void set_dbgctlr(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.dbgctlr = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_delegation_r - Control Access Delegation
//
struct dl3_delegation_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t secctlr : 1; // SECCTLR register delegation bit
            uint32_t secmcuctlr : 1; // SECMCUCTLR register delegation bit
            uint32_t sysctlr : 1; // SYSCTLR register delegation bit
            uint32_t pwrctlr : 1; // PWRCTLR register delegation bit
            uint32_t auxctlr : 1; // AUXCTLR register delegation bit
            uint32_t excctlr : 1; // EXCCTLR delegation bit
            uint32_t ramctlr : 1; // RAMCTLR delegation bit
            uint32_t dbgctlr : 1; // DBGCTLR delegation bit
            uint32_t err : 1; // Error register delegation bit
            uint32_t debug : 1; // Debug register delegation bit
            uint32_t job : 1; // Job register delegation bit
            uint32_t event : 1; // Event register delegation bit
            uint32_t interrupt : 1; // Interrupt register delegation bit
            uint32_t nmi : 1; // NMI register delegation bit
            uint32_t irq : 1; // IRQ_STATUS register delegation bit
            uint32_t intext : 1; // INT_STATUS and EXT_STATUS registers delegation bit (shared)
            uint32_t gp0 : 1; // GP0 register delegation bit
            uint32_t gp1 : 1; // GP1 register delegation bit
            uint32_t gp2 : 1; // GP2 register delegation bit
            uint32_t gp3 : 1; // GP3 register delegation bit
            uint32_t gp4 : 1; // GP4 register delegation bit
            uint32_t gp5 : 1; // GP5 register delegation bit
            uint32_t gp6 : 1; // GP6 register delegation bit
            uint32_t gp7 : 1; // GP7 register delegation bit
            uint32_t dfcot : 1; // DFC outstanding transaction registers delegation bit
            uint32_t reserved0 : 7;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_delegation_r(uint32_t init=0) : word(init) {}
    CONSTEXPR delegation_t get_secctlr() const { delegation_t value = static_cast<delegation_t>(bits.secctlr); return value;}
    CONSTEXPR void set_secctlr(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.secctlr = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_secmcuctlr() const { delegation_t value = static_cast<delegation_t>(bits.secmcuctlr); return value;}
    CONSTEXPR void set_secmcuctlr(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.secmcuctlr = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_sysctlr() const { delegation_t value = static_cast<delegation_t>(bits.sysctlr); return value;}
    CONSTEXPR void set_sysctlr(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.sysctlr = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_pwrctlr() const { delegation_t value = static_cast<delegation_t>(bits.pwrctlr); return value;}
    CONSTEXPR void set_pwrctlr(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.pwrctlr = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_auxctlr() const { delegation_t value = static_cast<delegation_t>(bits.auxctlr); return value;}
    CONSTEXPR void set_auxctlr(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.auxctlr = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_excctlr() const { delegation_t value = static_cast<delegation_t>(bits.excctlr); return value;}
    CONSTEXPR void set_excctlr(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.excctlr = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_ramctlr() const { delegation_t value = static_cast<delegation_t>(bits.ramctlr); return value;}
    CONSTEXPR void set_ramctlr(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ramctlr = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_dbgctlr() const { delegation_t value = static_cast<delegation_t>(bits.dbgctlr); return value;}
    CONSTEXPR void set_dbgctlr(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.dbgctlr = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_err() const { delegation_t value = static_cast<delegation_t>(bits.err); return value;}
    CONSTEXPR void set_err(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.err = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_debug() const { delegation_t value = static_cast<delegation_t>(bits.debug); return value;}
    CONSTEXPR void set_debug(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.debug = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_job() const { delegation_t value = static_cast<delegation_t>(bits.job); return value;}
    CONSTEXPR void set_job(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.job = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_event() const { delegation_t value = static_cast<delegation_t>(bits.event); return value;}
    CONSTEXPR void set_event(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.event = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_interrupt() const { delegation_t value = static_cast<delegation_t>(bits.interrupt); return value;}
    CONSTEXPR void set_interrupt(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.interrupt = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_nmi() const { delegation_t value = static_cast<delegation_t>(bits.nmi); return value;}
    CONSTEXPR void set_nmi(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.nmi = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_irq() const { delegation_t value = static_cast<delegation_t>(bits.irq); return value;}
    CONSTEXPR void set_irq(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.irq = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_intext() const { delegation_t value = static_cast<delegation_t>(bits.intext); return value;}
    CONSTEXPR void set_intext(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.intext = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_gp0() const { delegation_t value = static_cast<delegation_t>(bits.gp0); return value;}
    CONSTEXPR void set_gp0(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.gp0 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_gp1() const { delegation_t value = static_cast<delegation_t>(bits.gp1); return value;}
    CONSTEXPR void set_gp1(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.gp1 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_gp2() const { delegation_t value = static_cast<delegation_t>(bits.gp2); return value;}
    CONSTEXPR void set_gp2(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.gp2 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_gp3() const { delegation_t value = static_cast<delegation_t>(bits.gp3); return value;}
    CONSTEXPR void set_gp3(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.gp3 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_gp4() const { delegation_t value = static_cast<delegation_t>(bits.gp4); return value;}
    CONSTEXPR void set_gp4(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.gp4 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_gp5() const { delegation_t value = static_cast<delegation_t>(bits.gp5); return value;}
    CONSTEXPR void set_gp5(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.gp5 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_gp6() const { delegation_t value = static_cast<delegation_t>(bits.gp6); return value;}
    CONSTEXPR void set_gp6(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.gp6 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_gp7() const { delegation_t value = static_cast<delegation_t>(bits.gp7); return value;}
    CONSTEXPR void set_gp7(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.gp7 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_dfcot() const { delegation_t value = static_cast<delegation_t>(bits.dfcot); return value;}
    CONSTEXPR void set_dfcot(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.dfcot = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_secctlr_r - NPU security controls
//
struct dl3_secctlr_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t ns_allowed : 1; // Allow Non-secure transactions
            uint32_t npu_ns_mode : 1; // NPU Non-secure mode
            uint32_t reserved0 : 6;
            uint32_t ext_ns_evnt_to_s_evnt : 1; // NCU MCU S x NS Event
            uint32_t ext_ns_irq_to_s_irq : 1; // NCU MCU S x NS Interrupt
            uint32_t ext_s_evnt_to_ns_evnt : 1; // NCU MCU NS x S Event
            uint32_t ext_s_evnt_to_ns_irq : 1; // NCU MCU NS x S Event interrupt upgrade
            uint32_t reserved1 : 20;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_secctlr_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_ns_allowed() const { uint32_t value = static_cast<uint32_t>(bits.ns_allowed); return value;}
    CONSTEXPR void set_ns_allowed(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ns_allowed = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_npu_ns_mode() const { uint32_t value = static_cast<uint32_t>(bits.npu_ns_mode); return value;}
    CONSTEXPR void set_npu_ns_mode(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.npu_ns_mode = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ext_ns_evnt_to_s_evnt() const { uint32_t value = static_cast<uint32_t>(bits.ext_ns_evnt_to_s_evnt); return value;}
    CONSTEXPR void set_ext_ns_evnt_to_s_evnt(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ext_ns_evnt_to_s_evnt = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ext_ns_irq_to_s_irq() const { uint32_t value = static_cast<uint32_t>(bits.ext_ns_irq_to_s_irq); return value;}
    CONSTEXPR void set_ext_ns_irq_to_s_irq(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ext_ns_irq_to_s_irq = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ext_s_evnt_to_ns_evnt() const { uint32_t value = static_cast<uint32_t>(bits.ext_s_evnt_to_ns_evnt); return value;}
    CONSTEXPR void set_ext_s_evnt_to_ns_evnt(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ext_s_evnt_to_ns_evnt = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ext_s_evnt_to_ns_irq() const { uint32_t value = static_cast<uint32_t>(bits.ext_s_evnt_to_ns_irq); return value;}
    CONSTEXPR void set_ext_s_evnt_to_ns_irq(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ext_s_evnt_to_ns_irq = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_secmcuctlr_r - NCU MCU security state control
//
struct dl3_secmcuctlr_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mcu_state : 1; // NCU MCU security state
            uint32_t reserved0 : 31;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_secmcuctlr_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mcu_state() const { uint32_t value = static_cast<uint32_t>(bits.mcu_state); return value;}
    CONSTEXPR void set_mcu_state(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mcu_state = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_sysctlr0_r - System control 0 - MCU Control and Status
//
struct dl3_sysctlr0_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t cpuwait : 1; // MCU CPUWAIT input
            uint32_t lockup : 1; // MCU LOCKUP output
            uint32_t halted : 1; // MCU HALTED output
            uint32_t rstreq : 1; // MCU SYSRESETREQ output
            uint32_t sleeping : 1; // MCU SLEEPING and TRCENA output
            uint32_t reserved0 : 2;
            uint32_t initvtor : 22; // MCU Vector Table address
            uint32_t soft_rstreq : 2; // Soft reset request
            uint32_t hard_rstreq : 1; // Hard reset request
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_sysctlr0_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_cpuwait() const { uint32_t value = static_cast<uint32_t>(bits.cpuwait); return value;}
    CONSTEXPR void set_cpuwait(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.cpuwait = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_lockup() const { uint32_t value = static_cast<uint32_t>(bits.lockup); return value;}
    CONSTEXPR void set_lockup(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.lockup = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_halted() const { uint32_t value = static_cast<uint32_t>(bits.halted); return value;}
    CONSTEXPR void set_halted(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.halted = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_rstreq() const { uint32_t value = static_cast<uint32_t>(bits.rstreq); return value;}
    CONSTEXPR void set_rstreq(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.rstreq = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_sleeping() const { uint32_t value = static_cast<uint32_t>(bits.sleeping); return value;}
    CONSTEXPR void set_sleeping(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.sleeping = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_initvtor() const { uint32_t value = static_cast<uint32_t>(bits.initvtor); return value;}
    CONSTEXPR void set_initvtor(uint32_t value) { assert(static_cast<uint32_t>(value) < 4194304u); bits.initvtor = static_cast<uint32_t>(value); }
    CONSTEXPR soft_reset_t get_soft_rstreq() const { soft_reset_t value = static_cast<soft_reset_t>(bits.soft_rstreq); return value;}
    CONSTEXPR void set_soft_rstreq(soft_reset_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.soft_rstreq = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_hard_rstreq() const { uint32_t value = static_cast<uint32_t>(bits.hard_rstreq); return value;}
    CONSTEXPR void set_hard_rstreq(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.hard_rstreq = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_sysctlr1_r - System control 1 - Event Control
//
struct dl3_sysctlr1_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t reserved0 : 4;
            uint32_t mcu_setevnt : 1; // MCU SET event
            uint32_t mcu_setirq : 1; // MCU SET interrupt
            uint32_t mcu_gpevnt : 1; // MCU GP event
            uint32_t reserved1 : 1;
            uint32_t tsu_evnt : 1; // TSU event
            uint32_t tsu_irq : 1; // TSU interrupt
            uint32_t tsu_dbg : 1; // TSU debug request
            uint32_t reserved2 : 5;
            uint32_t txev_ple : 1; // MCU TXEV sent to PLE
            uint32_t reserved3 : 1;
            uint32_t txev_dbg : 1; // MCU TXEV sent to Host
            uint32_t rxev_degroup : 1; // Degroup PLE TXEV sent to MCU
            uint32_t rxev_evnt : 1; // PLE TXEV sent to MCU
            uint32_t rxev_irq : 1; // PLE TXEV triggers MCU interrupt
            uint32_t reserved4 : 2;
            uint32_t pmu_evnt : 1; // PMU counter overflow event
            uint32_t pmu_irq : 1; // PMU counter overflow interrupt
            uint32_t pmu_dbg : 1; // PMU counter overflow debug request
            uint32_t pmu_eng : 1; // PMU engine counter overflow request
            uint32_t err_tolr_evnt : 1; // Tolerable error triggers MCU event
            uint32_t err_tolr_irq : 1; // Tolerable error triggers MCU interrupt
            uint32_t err_func_irq : 1; // Functional error triggers MCU interrupt
            uint32_t err_recv_irq : 1; // Recoverable error triggers MCU interrupt
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_sysctlr1_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mcu_setevnt() const { uint32_t value = static_cast<uint32_t>(bits.mcu_setevnt); return value;}
    CONSTEXPR void set_mcu_setevnt(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mcu_setevnt = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mcu_setirq() const { uint32_t value = static_cast<uint32_t>(bits.mcu_setirq); return value;}
    CONSTEXPR void set_mcu_setirq(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mcu_setirq = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mcu_gpevnt() const { uint32_t value = static_cast<uint32_t>(bits.mcu_gpevnt); return value;}
    CONSTEXPR void set_mcu_gpevnt(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mcu_gpevnt = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_tsu_evnt() const { uint32_t value = static_cast<uint32_t>(bits.tsu_evnt); return value;}
    CONSTEXPR void set_tsu_evnt(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.tsu_evnt = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_tsu_irq() const { uint32_t value = static_cast<uint32_t>(bits.tsu_irq); return value;}
    CONSTEXPR void set_tsu_irq(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.tsu_irq = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_tsu_dbg() const { uint32_t value = static_cast<uint32_t>(bits.tsu_dbg); return value;}
    CONSTEXPR void set_tsu_dbg(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.tsu_dbg = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_txev_ple() const { uint32_t value = static_cast<uint32_t>(bits.txev_ple); return value;}
    CONSTEXPR void set_txev_ple(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.txev_ple = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_txev_dbg() const { uint32_t value = static_cast<uint32_t>(bits.txev_dbg); return value;}
    CONSTEXPR void set_txev_dbg(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.txev_dbg = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_rxev_degroup() const { uint32_t value = static_cast<uint32_t>(bits.rxev_degroup); return value;}
    CONSTEXPR void set_rxev_degroup(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.rxev_degroup = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_rxev_evnt() const { uint32_t value = static_cast<uint32_t>(bits.rxev_evnt); return value;}
    CONSTEXPR void set_rxev_evnt(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.rxev_evnt = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_rxev_irq() const { uint32_t value = static_cast<uint32_t>(bits.rxev_irq); return value;}
    CONSTEXPR void set_rxev_irq(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.rxev_irq = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_pmu_evnt() const { uint32_t value = static_cast<uint32_t>(bits.pmu_evnt); return value;}
    CONSTEXPR void set_pmu_evnt(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.pmu_evnt = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_pmu_irq() const { uint32_t value = static_cast<uint32_t>(bits.pmu_irq); return value;}
    CONSTEXPR void set_pmu_irq(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.pmu_irq = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_pmu_dbg() const { uint32_t value = static_cast<uint32_t>(bits.pmu_dbg); return value;}
    CONSTEXPR void set_pmu_dbg(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.pmu_dbg = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_pmu_eng() const { uint32_t value = static_cast<uint32_t>(bits.pmu_eng); return value;}
    CONSTEXPR void set_pmu_eng(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.pmu_eng = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_err_tolr_evnt() const { uint32_t value = static_cast<uint32_t>(bits.err_tolr_evnt); return value;}
    CONSTEXPR void set_err_tolr_evnt(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.err_tolr_evnt = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_err_tolr_irq() const { uint32_t value = static_cast<uint32_t>(bits.err_tolr_irq); return value;}
    CONSTEXPR void set_err_tolr_irq(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.err_tolr_irq = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_err_func_irq() const { uint32_t value = static_cast<uint32_t>(bits.err_func_irq); return value;}
    CONSTEXPR void set_err_func_irq(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.err_func_irq = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_err_recv_irq() const { uint32_t value = static_cast<uint32_t>(bits.err_recv_irq); return value;}
    CONSTEXPR void set_err_recv_irq(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.err_recv_irq = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_pwrctlr_r - Power Control
//
struct dl3_pwrctlr_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t active : 1; // NPU activity state
            uint32_t qreqn : 1; // Value of CLK Q-channel QREQn
            uint32_t reserved0 : 30;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_pwrctlr_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_active() const { uint32_t value = static_cast<uint32_t>(bits.active); return value;}
    CONSTEXPR void set_active(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.active = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_qreqn() const { uint32_t value = static_cast<uint32_t>(bits.qreqn); return value;}
    CONSTEXPR void set_qreqn(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.qreqn = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_auxctlr_r - Auxiliary Control
//
struct dl3_auxctlr_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t dis_clkgate : 1; // Disable clock gating
            uint32_t dis_qdeny : 1; // Q-channel FSM deny control
            uint32_t dis_edgeirq : 1; // Change sensitivity of DEBUG and JOB IRQs
            uint32_t dis_mcu_unique_rid : 1; // Disable MCU logic enforcing unique RIDs
            uint32_t dis_stshtrnsltn : 1; // Disable StashTranslation transactions
            uint32_t reserved0 : 2;
            uint32_t increase_outstanding_writes : 1; // Increase outstanding master write transactions
            uint32_t dbgen : 1; // Invasive debug enable
            uint32_t niden : 1; // Non-invasive debug enable
            uint32_t reserved1 : 2;
            uint32_t dis_ext_err_unrecoverable : 1; // Disable ext err irq for unrecoverable errors
            uint32_t dis_ext_err_recoverable : 1; // Disable ext err irq for recoverable errors
            uint32_t dis_ext_err_functional : 1; // Disable ext err irq for functional errors
            uint32_t dis_ext_err_tolerable : 1; // Disable ext debug irq for tolerable errors
            uint32_t dis_non_broadcast_global_err : 1; // Disable non broadcast global errors
            uint32_t en_ple_block_done : 1; // Enable detection in TSU of PLE_BLOCK_DONE events indicated by engines.
            uint32_t mac_ramp_cycles : 2; // Number of ramp cycles when the MAC units transition between idle and active states.
            uint32_t snoop_dis : 1; // Disable external snooping of internal signals
            uint32_t wd_ramp_dis : 1; // Disable weight decoder ramping
            uint32_t reserved2 : 2;
            uint32_t stash_ahead : 4; // Number of 4kB pages to automatically read ahead for each of read and write before the corresponding DMA accesses
            uint32_t stash_issue : 4; // Issuing capacity for StashTranslation transactions
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_auxctlr_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_dis_clkgate() const { uint32_t value = static_cast<uint32_t>(bits.dis_clkgate); return value;}
    CONSTEXPR void set_dis_clkgate(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.dis_clkgate = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_dis_qdeny() const { uint32_t value = static_cast<uint32_t>(bits.dis_qdeny); return value;}
    CONSTEXPR void set_dis_qdeny(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.dis_qdeny = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_dis_edgeirq() const { uint32_t value = static_cast<uint32_t>(bits.dis_edgeirq); return value;}
    CONSTEXPR void set_dis_edgeirq(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.dis_edgeirq = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_dis_mcu_unique_rid() const { uint32_t value = static_cast<uint32_t>(bits.dis_mcu_unique_rid); return value;}
    CONSTEXPR void set_dis_mcu_unique_rid(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.dis_mcu_unique_rid = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_dis_stshtrnsltn() const { uint32_t value = static_cast<uint32_t>(bits.dis_stshtrnsltn); return value;}
    CONSTEXPR void set_dis_stshtrnsltn(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.dis_stshtrnsltn = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_increase_outstanding_writes() const { uint32_t value = static_cast<uint32_t>(bits.increase_outstanding_writes); return value;}
    CONSTEXPR void set_increase_outstanding_writes(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.increase_outstanding_writes = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_dbgen() const { uint32_t value = static_cast<uint32_t>(bits.dbgen); return value;}
    CONSTEXPR void set_dbgen(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.dbgen = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_niden() const { uint32_t value = static_cast<uint32_t>(bits.niden); return value;}
    CONSTEXPR void set_niden(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.niden = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_dis_ext_err_unrecoverable() const { uint32_t value = static_cast<uint32_t>(bits.dis_ext_err_unrecoverable); return value;}
    CONSTEXPR void set_dis_ext_err_unrecoverable(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.dis_ext_err_unrecoverable = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_dis_ext_err_recoverable() const { uint32_t value = static_cast<uint32_t>(bits.dis_ext_err_recoverable); return value;}
    CONSTEXPR void set_dis_ext_err_recoverable(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.dis_ext_err_recoverable = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_dis_ext_err_functional() const { uint32_t value = static_cast<uint32_t>(bits.dis_ext_err_functional); return value;}
    CONSTEXPR void set_dis_ext_err_functional(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.dis_ext_err_functional = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_dis_ext_err_tolerable() const { uint32_t value = static_cast<uint32_t>(bits.dis_ext_err_tolerable); return value;}
    CONSTEXPR void set_dis_ext_err_tolerable(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.dis_ext_err_tolerable = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_dis_non_broadcast_global_err() const { uint32_t value = static_cast<uint32_t>(bits.dis_non_broadcast_global_err); return value;}
    CONSTEXPR void set_dis_non_broadcast_global_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.dis_non_broadcast_global_err = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_en_ple_block_done() const { uint32_t value = static_cast<uint32_t>(bits.en_ple_block_done); return value;}
    CONSTEXPR void set_en_ple_block_done(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.en_ple_block_done = static_cast<uint32_t>(value); }
    CONSTEXPR mac_ramp_t get_mac_ramp_cycles() const { mac_ramp_t value = static_cast<mac_ramp_t>(bits.mac_ramp_cycles); return value;}
    CONSTEXPR void set_mac_ramp_cycles(mac_ramp_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.mac_ramp_cycles = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_snoop_dis() const { uint32_t value = static_cast<uint32_t>(bits.snoop_dis); return value;}
    CONSTEXPR void set_snoop_dis(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.snoop_dis = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_wd_ramp_dis() const { uint32_t value = static_cast<uint32_t>(bits.wd_ramp_dis); return value;}
    CONSTEXPR void set_wd_ramp_dis(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.wd_ramp_dis = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_stash_ahead() const { uint32_t value = static_cast<uint32_t>(bits.stash_ahead); return value;}
    CONSTEXPR void set_stash_ahead(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.stash_ahead = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_stash_issue() const { uint32_t value = static_cast<uint32_t>(bits.stash_issue); return value;}
    CONSTEXPR void set_stash_issue(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.stash_issue = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_setirq_ext_r - Set external interrupts (to host)
//
struct dl3_setirq_ext_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t err : 1; // Host error interrupt set request (level-sensitive to host)
            uint32_t debug : 1; // Host debug interrupt set request
            uint32_t job : 1; // Host job interrupt set request
            uint32_t reserved0 : 29;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_setirq_ext_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_err() const { uint32_t value = static_cast<uint32_t>(bits.err); return value;}
    CONSTEXPR void set_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.err = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_debug() const { uint32_t value = static_cast<uint32_t>(bits.debug); return value;}
    CONSTEXPR void set_debug(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.debug = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_job() const { uint32_t value = static_cast<uint32_t>(bits.job); return value;}
    CONSTEXPR void set_job(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.job = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_clrirq_ext_r - Clear external interrupts (to host)
//
struct dl3_clrirq_ext_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t err : 1; // Host error interrupt clear request
            uint32_t debug : 1; // Host debug interrupt clear request
            uint32_t job : 1; // Host job interrupt clear request
            uint32_t reserved0 : 29;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_clrirq_ext_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_err() const { uint32_t value = static_cast<uint32_t>(bits.err); return value;}
    CONSTEXPR void set_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.err = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_debug() const { uint32_t value = static_cast<uint32_t>(bits.debug); return value;}
    CONSTEXPR void set_debug(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.debug = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_job() const { uint32_t value = static_cast<uint32_t>(bits.job); return value;}
    CONSTEXPR void set_job(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.job = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_setirq_int_r - Raise internal interrupts and events
//
struct dl3_setirq_int_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t reserved0 : 4;
            uint32_t event : 1; // MCU event (edge-sensitive to MCU'S RXEV pin)
            uint32_t interrupt : 1; // MCU interrupt (edge-sensitive to MCU's IRQ pin)
            uint32_t reserved1 : 1;
            uint32_t nmi : 1; // MCU interrupt (edge-sensitive to MCU's NMI pin)
            uint32_t reserved2 : 24;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_setirq_int_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_event() const { uint32_t value = static_cast<uint32_t>(bits.event); return value;}
    CONSTEXPR void set_event(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.event = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_interrupt() const { uint32_t value = static_cast<uint32_t>(bits.interrupt); return value;}
    CONSTEXPR void set_interrupt(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.interrupt = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_nmi() const { uint32_t value = static_cast<uint32_t>(bits.nmi); return value;}
    CONSTEXPR void set_nmi(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.nmi = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_dfc_slv_ord_r - DFC Slave Outstanding Reads
//
struct dl3_dfc_slv_ord_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t out_reads : 8; // Outstanding read transaction count
            uint32_t reserved0 : 24;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_dfc_slv_ord_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_out_reads() const { uint32_t value = static_cast<uint32_t>(bits.out_reads); return value;}
    CONSTEXPR void set_out_reads(uint32_t value) { assert(static_cast<uint32_t>(value) < 256u); bits.out_reads = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_dfc_slv_owr_r - DFC Slave Outstanding Writes
//
struct dl3_dfc_slv_owr_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t out_writes : 8; // Outstanding write transaction count
            uint32_t reserved0 : 24;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_dfc_slv_owr_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_out_writes() const { uint32_t value = static_cast<uint32_t>(bits.out_writes); return value;}
    CONSTEXPR void set_out_writes(uint32_t value) { assert(static_cast<uint32_t>(value) < 256u); bits.out_writes = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_dfc_mst_ord_r - DFC Master Outstanding Reads
//
struct dl3_dfc_mst_ord_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t out_reads : 8; // Outstanding read transaction count
            uint32_t reserved0 : 24;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_dfc_mst_ord_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_out_reads() const { uint32_t value = static_cast<uint32_t>(bits.out_reads); return value;}
    CONSTEXPR void set_out_reads(uint32_t value) { assert(static_cast<uint32_t>(value) < 256u); bits.out_reads = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_dfc_mst_owr_r - DFC Master Outstanding Writes
//
struct dl3_dfc_mst_owr_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t out_writes : 8; // Outstanding write transaction count
            uint32_t reserved0 : 24;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_dfc_mst_owr_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_out_writes() const { uint32_t value = static_cast<uint32_t>(bits.out_writes); return value;}
    CONSTEXPR void set_out_writes(uint32_t value) { assert(static_cast<uint32_t>(value) < 256u); bits.out_writes = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_irq_status_r - Status register used by the Host system
//
struct dl3_irq_status_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t setirq_err : 1; // ERR interrupt caused by SETIRQ
            uint32_t setirq_dbg : 1; // DEBUG interrupt caused by SETIRQ
            uint32_t setirq_job : 1; // JOB interrupt caused by SETIRQ
            uint32_t reserved0 : 7;
            uint32_t tsu_dbg : 1; // DEBUG interrupt caused by TSU
            uint32_t reserved1 : 15;
            uint32_t pmu_dbg : 1; // DEBUG interrupt caused by top-level PMU
            uint32_t pmu_eng : 1; // DEBUG interrupt caused by engine-level PMU
            uint32_t tol_err : 1; // Tolerable error
            uint32_t func_err : 1; // Functional error
            uint32_t rec_err : 1; // Recoverable error
            uint32_t unrec_err : 1; // Unrecoverable error
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_irq_status_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_setirq_err() const { uint32_t value = static_cast<uint32_t>(bits.setirq_err); return value;}
    CONSTEXPR void set_setirq_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.setirq_err = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_setirq_dbg() const { uint32_t value = static_cast<uint32_t>(bits.setirq_dbg); return value;}
    CONSTEXPR void set_setirq_dbg(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.setirq_dbg = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_setirq_job() const { uint32_t value = static_cast<uint32_t>(bits.setirq_job); return value;}
    CONSTEXPR void set_setirq_job(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.setirq_job = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_tsu_dbg() const { uint32_t value = static_cast<uint32_t>(bits.tsu_dbg); return value;}
    CONSTEXPR void set_tsu_dbg(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.tsu_dbg = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_pmu_dbg() const { uint32_t value = static_cast<uint32_t>(bits.pmu_dbg); return value;}
    CONSTEXPR void set_pmu_dbg(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.pmu_dbg = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_pmu_eng() const { uint32_t value = static_cast<uint32_t>(bits.pmu_eng); return value;}
    CONSTEXPR void set_pmu_eng(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.pmu_eng = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_tol_err() const { uint32_t value = static_cast<uint32_t>(bits.tol_err); return value;}
    CONSTEXPR void set_tol_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.tol_err = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_func_err() const { uint32_t value = static_cast<uint32_t>(bits.func_err); return value;}
    CONSTEXPR void set_func_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.func_err = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_rec_err() const { uint32_t value = static_cast<uint32_t>(bits.rec_err); return value;}
    CONSTEXPR void set_rec_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.rec_err = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_unrec_err() const { uint32_t value = static_cast<uint32_t>(bits.unrec_err); return value;}
    CONSTEXPR void set_unrec_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.unrec_err = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_int_status_r - Internal status register used by the NCU's MCU
//
struct dl3_int_status_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t reserved0 : 8;
            uint32_t tsu_evnt : 1; // Event caused by TSU
            uint32_t tsu_irq : 1; // Interrupt caused by TSU
            uint32_t reserved1 : 10;
            uint32_t rxev_evnt : 1; // Event caused by PLE's SEV
            uint32_t rxev_irq : 1; // Interrupt caused by PLE's SEV
            uint32_t reserved2 : 2;
            uint32_t pmu_evnt : 1; // Event caused by PMU overflow
            uint32_t pmu_irq : 1; // Interrupt caused by PMU overflow
            uint32_t reserved3 : 1;
            uint32_t pmu_eng : 1; // Event or interrupt caused by engine PMU
            uint32_t tol_err : 1; // Tolerable error
            uint32_t func_err : 1; // Functional error
            uint32_t rec_err : 1; // Recoverable error
            uint32_t unrec_err : 1; // Unrecoverable error
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_int_status_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_tsu_evnt() const { uint32_t value = static_cast<uint32_t>(bits.tsu_evnt); return value;}
    CONSTEXPR void set_tsu_evnt(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.tsu_evnt = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_tsu_irq() const { uint32_t value = static_cast<uint32_t>(bits.tsu_irq); return value;}
    CONSTEXPR void set_tsu_irq(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.tsu_irq = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_rxev_evnt() const { uint32_t value = static_cast<uint32_t>(bits.rxev_evnt); return value;}
    CONSTEXPR void set_rxev_evnt(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.rxev_evnt = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_rxev_irq() const { uint32_t value = static_cast<uint32_t>(bits.rxev_irq); return value;}
    CONSTEXPR void set_rxev_irq(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.rxev_irq = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_pmu_evnt() const { uint32_t value = static_cast<uint32_t>(bits.pmu_evnt); return value;}
    CONSTEXPR void set_pmu_evnt(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.pmu_evnt = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_pmu_irq() const { uint32_t value = static_cast<uint32_t>(bits.pmu_irq); return value;}
    CONSTEXPR void set_pmu_irq(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.pmu_irq = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_pmu_eng() const { uint32_t value = static_cast<uint32_t>(bits.pmu_eng); return value;}
    CONSTEXPR void set_pmu_eng(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.pmu_eng = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_tol_err() const { uint32_t value = static_cast<uint32_t>(bits.tol_err); return value;}
    CONSTEXPR void set_tol_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.tol_err = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_func_err() const { uint32_t value = static_cast<uint32_t>(bits.func_err); return value;}
    CONSTEXPR void set_func_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.func_err = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_rec_err() const { uint32_t value = static_cast<uint32_t>(bits.rec_err); return value;}
    CONSTEXPR void set_rec_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.rec_err = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_unrec_err() const { uint32_t value = static_cast<uint32_t>(bits.unrec_err); return value;}
    CONSTEXPR void set_unrec_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.unrec_err = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_ext_status_r - External status register used by the NCU's MCU
//
struct dl3_ext_status_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t reserved0 : 4;
            uint32_t setirq_evnt : 1; // Event caused by SETIRQ_INT
            uint32_t setirq_irq : 1; // Interrupt caused by SETIRQ_INT
            uint32_t gp_evnt : 1; // Event caused by host write to GPreg
            uint32_t reserved1 : 25;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_ext_status_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_setirq_evnt() const { uint32_t value = static_cast<uint32_t>(bits.setirq_evnt); return value;}
    CONSTEXPR void set_setirq_evnt(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.setirq_evnt = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_setirq_irq() const { uint32_t value = static_cast<uint32_t>(bits.setirq_irq); return value;}
    CONSTEXPR void set_setirq_irq(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.setirq_irq = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_gp_evnt() const { uint32_t value = static_cast<uint32_t>(bits.gp_evnt); return value;}
    CONSTEXPR void set_gp_evnt(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.gp_evnt = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_gp0_r - General purpose register 0
//
struct dl3_gp0_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t gp0 : 32; // General purpose register 0
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_gp0_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_gp0() const { uint32_t value = static_cast<uint32_t>(bits.gp0); return value;}
    CONSTEXPR void set_gp0(uint32_t value) { bits.gp0 = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_gp1_r - General purpose register 1
//
struct dl3_gp1_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t gp1 : 32; // General purpose register 1
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_gp1_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_gp1() const { uint32_t value = static_cast<uint32_t>(bits.gp1); return value;}
    CONSTEXPR void set_gp1(uint32_t value) { bits.gp1 = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_gp2_r - General purpose register 2
//
struct dl3_gp2_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t gp2 : 32; // General purpose register 2
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_gp2_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_gp2() const { uint32_t value = static_cast<uint32_t>(bits.gp2); return value;}
    CONSTEXPR void set_gp2(uint32_t value) { bits.gp2 = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_gp3_r - General purpose register 3
//
struct dl3_gp3_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t gp3 : 32; // General purpose register 3
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_gp3_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_gp3() const { uint32_t value = static_cast<uint32_t>(bits.gp3); return value;}
    CONSTEXPR void set_gp3(uint32_t value) { bits.gp3 = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_gp4_r - General purpose register 4
//
struct dl3_gp4_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t gp4 : 32; // General purpose register 4
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_gp4_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_gp4() const { uint32_t value = static_cast<uint32_t>(bits.gp4); return value;}
    CONSTEXPR void set_gp4(uint32_t value) { bits.gp4 = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_gp5_r - General purpose register 5
//
struct dl3_gp5_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t gp5 : 32; // General purpose register 5
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_gp5_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_gp5() const { uint32_t value = static_cast<uint32_t>(bits.gp5); return value;}
    CONSTEXPR void set_gp5(uint32_t value) { bits.gp5 = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_gp6_r - General purpose register 6
//
struct dl3_gp6_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t gp6 : 32; // General purpose register 6
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_gp6_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_gp6() const { uint32_t value = static_cast<uint32_t>(bits.gp6); return value;}
    CONSTEXPR void set_gp6(uint32_t value) { bits.gp6 = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_gp7_r - General purpose register 7
//
struct dl3_gp7_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t gp7 : 32; // General purpose register 7
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_gp7_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_gp7() const { uint32_t value = static_cast<uint32_t>(bits.gp7); return value;}
    CONSTEXPR void set_gp7(uint32_t value) { bits.gp7 = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_delegation_stream_security_r - Stream security state control delegation
//
struct dl3_delegation_stream_security_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusecsid0 : 1; // Delegation bit for stream 0 MMUSECSID register
            uint32_t protns0 : 1; // Delegation bit for stream 0 PROTNS register
            uint32_t mmusecsid1 : 1; // Delegation bit for stream 1 MMUSECSID register
            uint32_t protns1 : 1; // Delegation bit for stream 1 PROTNS register
            uint32_t mmusecsid2 : 1; // Delegation bit for stream 2 MMUSECSID register
            uint32_t protns2 : 1; // Delegation bit for stream 2 PROTNS register
            uint32_t mmusecsid3 : 1; // Delegation bit for stream 3 MMUSECSID register
            uint32_t protns3 : 1; // Delegation bit for stream 3 PROTNS register
            uint32_t mmusecsid4 : 1; // Delegation bit for stream 4 MMUSECSID register
            uint32_t protns4 : 1; // Delegation bit for stream 4 PROTNS register
            uint32_t mmusecsid5 : 1; // Delegation bit for stream 5 MMUSECSID register
            uint32_t protns5 : 1; // Delegation bit for stream 5 PROTNS register
            uint32_t mmusecsid6 : 1; // Delegation bit for stream 6 MMUSECSID register
            uint32_t protns6 : 1; // Delegation bit for stream 6 PROTNS register
            uint32_t mmusecsid7 : 1; // Delegation bit for stream 7 MMUSECSID register
            uint32_t protns7 : 1; // Delegation bit for stream 7 PROTNS register
            uint32_t mmusecsid8 : 1; // Delegation bit for stream 8 MMUSECSID register
            uint32_t protns8 : 1; // Delegation bit for stream 8 PROTNS register
            uint32_t reserved0 : 14;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_delegation_stream_security_r(uint32_t init=0) : word(init) {}
    CONSTEXPR delegation_t get_mmusecsid0() const { delegation_t value = static_cast<delegation_t>(bits.mmusecsid0); return value;}
    CONSTEXPR void set_mmusecsid0(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmusecsid0 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_protns0() const { delegation_t value = static_cast<delegation_t>(bits.protns0); return value;}
    CONSTEXPR void set_protns0(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.protns0 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_mmusecsid1() const { delegation_t value = static_cast<delegation_t>(bits.mmusecsid1); return value;}
    CONSTEXPR void set_mmusecsid1(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmusecsid1 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_protns1() const { delegation_t value = static_cast<delegation_t>(bits.protns1); return value;}
    CONSTEXPR void set_protns1(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.protns1 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_mmusecsid2() const { delegation_t value = static_cast<delegation_t>(bits.mmusecsid2); return value;}
    CONSTEXPR void set_mmusecsid2(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmusecsid2 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_protns2() const { delegation_t value = static_cast<delegation_t>(bits.protns2); return value;}
    CONSTEXPR void set_protns2(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.protns2 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_mmusecsid3() const { delegation_t value = static_cast<delegation_t>(bits.mmusecsid3); return value;}
    CONSTEXPR void set_mmusecsid3(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmusecsid3 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_protns3() const { delegation_t value = static_cast<delegation_t>(bits.protns3); return value;}
    CONSTEXPR void set_protns3(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.protns3 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_mmusecsid4() const { delegation_t value = static_cast<delegation_t>(bits.mmusecsid4); return value;}
    CONSTEXPR void set_mmusecsid4(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmusecsid4 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_protns4() const { delegation_t value = static_cast<delegation_t>(bits.protns4); return value;}
    CONSTEXPR void set_protns4(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.protns4 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_mmusecsid5() const { delegation_t value = static_cast<delegation_t>(bits.mmusecsid5); return value;}
    CONSTEXPR void set_mmusecsid5(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmusecsid5 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_protns5() const { delegation_t value = static_cast<delegation_t>(bits.protns5); return value;}
    CONSTEXPR void set_protns5(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.protns5 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_mmusecsid6() const { delegation_t value = static_cast<delegation_t>(bits.mmusecsid6); return value;}
    CONSTEXPR void set_mmusecsid6(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmusecsid6 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_protns6() const { delegation_t value = static_cast<delegation_t>(bits.protns6); return value;}
    CONSTEXPR void set_protns6(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.protns6 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_mmusecsid7() const { delegation_t value = static_cast<delegation_t>(bits.mmusecsid7); return value;}
    CONSTEXPR void set_mmusecsid7(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmusecsid7 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_protns7() const { delegation_t value = static_cast<delegation_t>(bits.protns7); return value;}
    CONSTEXPR void set_protns7(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.protns7 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_mmusecsid8() const { delegation_t value = static_cast<delegation_t>(bits.mmusecsid8); return value;}
    CONSTEXPR void set_mmusecsid8(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmusecsid8 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_protns8() const { delegation_t value = static_cast<delegation_t>(bits.protns8); return value;}
    CONSTEXPR void set_protns8(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.protns8 = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_delegation_nsaid_r - Non-secure Access Identifier delegation
//
struct dl3_delegation_nsaid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t nsaid0 : 1; // Delegation bit for stream 0 NSAID register
            uint32_t reserved0 : 1;
            uint32_t nsaid1 : 1; // Delegation bit for stream 1 NSAID register
            uint32_t reserved1 : 1;
            uint32_t nsaid2 : 1; // Delegation bit for stream 2 NSAID register
            uint32_t reserved2 : 1;
            uint32_t nsaid3 : 1; // Delegation bit for stream 3 NSAID register
            uint32_t reserved3 : 1;
            uint32_t nsaid4 : 1; // Delegation bit for stream 4 NSAID register
            uint32_t reserved4 : 1;
            uint32_t nsaid5 : 1; // Delegation bit for stream 5 NSAID register
            uint32_t reserved5 : 1;
            uint32_t nsaid6 : 1; // Delegation bit for stream 6 NSAID register
            uint32_t reserved6 : 1;
            uint32_t nsaid7 : 1; // Delegation bit for stream 7 NSAID register
            uint32_t reserved7 : 1;
            uint32_t nsaid8 : 1; // Delegation bit for stream 8 NSAID register
            uint32_t reserved8 : 15;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_delegation_nsaid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR delegation_t get_nsaid0() const { delegation_t value = static_cast<delegation_t>(bits.nsaid0); return value;}
    CONSTEXPR void set_nsaid0(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.nsaid0 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_nsaid1() const { delegation_t value = static_cast<delegation_t>(bits.nsaid1); return value;}
    CONSTEXPR void set_nsaid1(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.nsaid1 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_nsaid2() const { delegation_t value = static_cast<delegation_t>(bits.nsaid2); return value;}
    CONSTEXPR void set_nsaid2(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.nsaid2 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_nsaid3() const { delegation_t value = static_cast<delegation_t>(bits.nsaid3); return value;}
    CONSTEXPR void set_nsaid3(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.nsaid3 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_nsaid4() const { delegation_t value = static_cast<delegation_t>(bits.nsaid4); return value;}
    CONSTEXPR void set_nsaid4(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.nsaid4 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_nsaid5() const { delegation_t value = static_cast<delegation_t>(bits.nsaid5); return value;}
    CONSTEXPR void set_nsaid5(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.nsaid5 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_nsaid6() const { delegation_t value = static_cast<delegation_t>(bits.nsaid6); return value;}
    CONSTEXPR void set_nsaid6(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.nsaid6 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_nsaid7() const { delegation_t value = static_cast<delegation_t>(bits.nsaid7); return value;}
    CONSTEXPR void set_nsaid7(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.nsaid7 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_nsaid8() const { delegation_t value = static_cast<delegation_t>(bits.nsaid8); return value;}
    CONSTEXPR void set_nsaid8(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.nsaid8 = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_delegation_mmusid_r - MMU Stream Identifier delegation
//
struct dl3_delegation_mmusid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t sid0 : 2; // Delegation bit for stream 0 MMUSID register
            uint32_t sid1 : 2; // Delegation bit for stream 1 MMUSID register
            uint32_t sid2 : 2; // Delegation bit for stream 2 MMUSID register
            uint32_t sid3 : 2; // Delegation bit for stream 3 MMUSID register
            uint32_t sid4 : 2; // Delegation bit for stream 4 MMUSID register
            uint32_t sid5 : 2; // Delegation bit for stream 5 MMUSID register
            uint32_t sid6 : 2; // Delegation bit for stream 6 MMUSID register
            uint32_t sid7 : 2; // Delegation bit for stream 7 MMUSID register
            uint32_t sid8 : 2; // Delegation bit for stream 8 MMUSID register
            uint32_t reserved0 : 14;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_delegation_mmusid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR streamid_delegation_t get_sid0() const { streamid_delegation_t value = static_cast<streamid_delegation_t>(bits.sid0); return value;}
    CONSTEXPR void set_sid0(streamid_delegation_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.sid0 = static_cast<uint32_t>(value); }
    CONSTEXPR streamid_delegation_t get_sid1() const { streamid_delegation_t value = static_cast<streamid_delegation_t>(bits.sid1); return value;}
    CONSTEXPR void set_sid1(streamid_delegation_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.sid1 = static_cast<uint32_t>(value); }
    CONSTEXPR streamid_delegation_t get_sid2() const { streamid_delegation_t value = static_cast<streamid_delegation_t>(bits.sid2); return value;}
    CONSTEXPR void set_sid2(streamid_delegation_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.sid2 = static_cast<uint32_t>(value); }
    CONSTEXPR streamid_delegation_t get_sid3() const { streamid_delegation_t value = static_cast<streamid_delegation_t>(bits.sid3); return value;}
    CONSTEXPR void set_sid3(streamid_delegation_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.sid3 = static_cast<uint32_t>(value); }
    CONSTEXPR streamid_delegation_t get_sid4() const { streamid_delegation_t value = static_cast<streamid_delegation_t>(bits.sid4); return value;}
    CONSTEXPR void set_sid4(streamid_delegation_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.sid4 = static_cast<uint32_t>(value); }
    CONSTEXPR streamid_delegation_t get_sid5() const { streamid_delegation_t value = static_cast<streamid_delegation_t>(bits.sid5); return value;}
    CONSTEXPR void set_sid5(streamid_delegation_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.sid5 = static_cast<uint32_t>(value); }
    CONSTEXPR streamid_delegation_t get_sid6() const { streamid_delegation_t value = static_cast<streamid_delegation_t>(bits.sid6); return value;}
    CONSTEXPR void set_sid6(streamid_delegation_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.sid6 = static_cast<uint32_t>(value); }
    CONSTEXPR streamid_delegation_t get_sid7() const { streamid_delegation_t value = static_cast<streamid_delegation_t>(bits.sid7); return value;}
    CONSTEXPR void set_sid7(streamid_delegation_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.sid7 = static_cast<uint32_t>(value); }
    CONSTEXPR streamid_delegation_t get_sid8() const { streamid_delegation_t value = static_cast<streamid_delegation_t>(bits.sid8); return value;}
    CONSTEXPR void set_sid8(streamid_delegation_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.sid8 = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_delegation_mmussid_r - MMU Sub-stream Stream ID delegation
//
struct dl3_delegation_mmussid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t ssid0 : 2; // Delegation bit for stream 0 MMUSSID register
            uint32_t ssid1 : 2; // Delegation bit for stream 1 MMUSSID register
            uint32_t ssid2 : 2; // Delegation bit for stream 2 MMUSSID register
            uint32_t ssid3 : 2; // Delegation bit for stream 3 MMUSSID register
            uint32_t ssid4 : 2; // Delegation bit for stream 4 MMUSSID register
            uint32_t ssid5 : 2; // Delegation bit for stream 5 MMUSSID register
            uint32_t ssid6 : 2; // Delegation bit for stream 6 MMUSSID register
            uint32_t ssid7 : 2; // Delegation bit for stream 7 MMUSSID register
            uint32_t ssid8 : 2; // Delegation bit for stream 8 MMUSSID register
            uint32_t reserved0 : 14;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_delegation_mmussid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR substreamid_delegation_t get_ssid0() const { substreamid_delegation_t value = static_cast<substreamid_delegation_t>(bits.ssid0); return value;}
    CONSTEXPR void set_ssid0(substreamid_delegation_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.ssid0 = static_cast<uint32_t>(value); }
    CONSTEXPR substreamid_delegation_t get_ssid1() const { substreamid_delegation_t value = static_cast<substreamid_delegation_t>(bits.ssid1); return value;}
    CONSTEXPR void set_ssid1(substreamid_delegation_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.ssid1 = static_cast<uint32_t>(value); }
    CONSTEXPR substreamid_delegation_t get_ssid2() const { substreamid_delegation_t value = static_cast<substreamid_delegation_t>(bits.ssid2); return value;}
    CONSTEXPR void set_ssid2(substreamid_delegation_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.ssid2 = static_cast<uint32_t>(value); }
    CONSTEXPR substreamid_delegation_t get_ssid3() const { substreamid_delegation_t value = static_cast<substreamid_delegation_t>(bits.ssid3); return value;}
    CONSTEXPR void set_ssid3(substreamid_delegation_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.ssid3 = static_cast<uint32_t>(value); }
    CONSTEXPR substreamid_delegation_t get_ssid4() const { substreamid_delegation_t value = static_cast<substreamid_delegation_t>(bits.ssid4); return value;}
    CONSTEXPR void set_ssid4(substreamid_delegation_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.ssid4 = static_cast<uint32_t>(value); }
    CONSTEXPR substreamid_delegation_t get_ssid5() const { substreamid_delegation_t value = static_cast<substreamid_delegation_t>(bits.ssid5); return value;}
    CONSTEXPR void set_ssid5(substreamid_delegation_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.ssid5 = static_cast<uint32_t>(value); }
    CONSTEXPR substreamid_delegation_t get_ssid6() const { substreamid_delegation_t value = static_cast<substreamid_delegation_t>(bits.ssid6); return value;}
    CONSTEXPR void set_ssid6(substreamid_delegation_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.ssid6 = static_cast<uint32_t>(value); }
    CONSTEXPR substreamid_delegation_t get_ssid7() const { substreamid_delegation_t value = static_cast<substreamid_delegation_t>(bits.ssid7); return value;}
    CONSTEXPR void set_ssid7(substreamid_delegation_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.ssid7 = static_cast<uint32_t>(value); }
    CONSTEXPR substreamid_delegation_t get_ssid8() const { substreamid_delegation_t value = static_cast<substreamid_delegation_t>(bits.ssid8); return value;}
    CONSTEXPR void set_ssid8(substreamid_delegation_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.ssid8 = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_delegation_mmussidv_r - MMU Sub-stream Stream IDV delegation
//
struct dl3_delegation_mmussidv_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t ssidv0 : 1; // Delegation bit for stream 0 MMUSSIDV register
            uint32_t ssidv1 : 1; // Delegation bit for stream 1 MMUSSIDV register
            uint32_t ssidv2 : 1; // Delegation bit for stream 2 MMUSSIDV register
            uint32_t ssidv3 : 1; // Delegation bit for stream 3 MMUSSIDV register
            uint32_t ssidv4 : 1; // Delegation bit for stream 4 MMUSSIDV register
            uint32_t ssidv5 : 1; // Delegation bit for stream 5 MMUSSIDV register
            uint32_t ssidv6 : 1; // Delegation bit for stream 6 MMUSSIDV register
            uint32_t ssidv7 : 1; // Delegation bit for stream 7 MMUSSIDV register
            uint32_t ssidv8 : 1; // Delegation bit for stream 8 MMUSSIDV register
            uint32_t reserved0 : 23;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_delegation_mmussidv_r(uint32_t init=0) : word(init) {}
    CONSTEXPR delegation_t get_ssidv0() const { delegation_t value = static_cast<delegation_t>(bits.ssidv0); return value;}
    CONSTEXPR void set_ssidv0(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ssidv0 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_ssidv1() const { delegation_t value = static_cast<delegation_t>(bits.ssidv1); return value;}
    CONSTEXPR void set_ssidv1(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ssidv1 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_ssidv2() const { delegation_t value = static_cast<delegation_t>(bits.ssidv2); return value;}
    CONSTEXPR void set_ssidv2(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ssidv2 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_ssidv3() const { delegation_t value = static_cast<delegation_t>(bits.ssidv3); return value;}
    CONSTEXPR void set_ssidv3(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ssidv3 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_ssidv4() const { delegation_t value = static_cast<delegation_t>(bits.ssidv4); return value;}
    CONSTEXPR void set_ssidv4(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ssidv4 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_ssidv5() const { delegation_t value = static_cast<delegation_t>(bits.ssidv5); return value;}
    CONSTEXPR void set_ssidv5(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ssidv5 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_ssidv6() const { delegation_t value = static_cast<delegation_t>(bits.ssidv6); return value;}
    CONSTEXPR void set_ssidv6(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ssidv6 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_ssidv7() const { delegation_t value = static_cast<delegation_t>(bits.ssidv7); return value;}
    CONSTEXPR void set_ssidv7(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ssidv7 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_ssidv8() const { delegation_t value = static_cast<delegation_t>(bits.ssidv8); return value;}
    CONSTEXPR void set_ssidv8(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ssidv8 = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_delegation_attr_control_r - Attribute Control delegation
//
struct dl3_delegation_attr_control_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t attrctrl0 : 1; // Delegation bit for stream 0 Attribute Control register
            uint32_t attrctrl1 : 1; // Delegation bit for stream 1 Attribute Control register
            uint32_t attrctrl2 : 1; // Delegation bit for stream 2 Attribute Control register
            uint32_t attrctrl3 : 1; // Delegation bit for stream 3 Attribute Control register
            uint32_t attrctrl4 : 1; // Delegation bit for stream 4 Attribute Control register
            uint32_t attrctrl5 : 1; // Delegation bit for stream 5 Attribute Control register
            uint32_t attrctrl6 : 1; // Delegation bit for stream 6 Attribute Control register
            uint32_t attrctrl7 : 1; // Delegation bit for stream 7 Attribute Control register
            uint32_t attrctrl8 : 1; // Delegation bit for stream 8 Attribute Control register
            uint32_t reserved0 : 23;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_delegation_attr_control_r(uint32_t init=0) : word(init) {}
    CONSTEXPR delegation_t get_attrctrl0() const { delegation_t value = static_cast<delegation_t>(bits.attrctrl0); return value;}
    CONSTEXPR void set_attrctrl0(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.attrctrl0 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_attrctrl1() const { delegation_t value = static_cast<delegation_t>(bits.attrctrl1); return value;}
    CONSTEXPR void set_attrctrl1(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.attrctrl1 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_attrctrl2() const { delegation_t value = static_cast<delegation_t>(bits.attrctrl2); return value;}
    CONSTEXPR void set_attrctrl2(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.attrctrl2 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_attrctrl3() const { delegation_t value = static_cast<delegation_t>(bits.attrctrl3); return value;}
    CONSTEXPR void set_attrctrl3(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.attrctrl3 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_attrctrl4() const { delegation_t value = static_cast<delegation_t>(bits.attrctrl4); return value;}
    CONSTEXPR void set_attrctrl4(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.attrctrl4 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_attrctrl5() const { delegation_t value = static_cast<delegation_t>(bits.attrctrl5); return value;}
    CONSTEXPR void set_attrctrl5(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.attrctrl5 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_attrctrl6() const { delegation_t value = static_cast<delegation_t>(bits.attrctrl6); return value;}
    CONSTEXPR void set_attrctrl6(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.attrctrl6 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_attrctrl7() const { delegation_t value = static_cast<delegation_t>(bits.attrctrl7); return value;}
    CONSTEXPR void set_attrctrl7(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.attrctrl7 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_attrctrl8() const { delegation_t value = static_cast<delegation_t>(bits.attrctrl8); return value;}
    CONSTEXPR void set_attrctrl8(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.attrctrl8 = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_delegation_memattr_r - Memory Attributes delegation
//
struct dl3_delegation_memattr_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t memattr0 : 1; // Delegation bit for stream 0 Memory Attributes register
            uint32_t memattr1 : 1; // Delegation bit for stream 1 Memory Attributes register
            uint32_t memattr2 : 1; // Delegation bit for stream 2 Memory Attributes register
            uint32_t memattr3 : 1; // Delegation bit for stream 3 Memory Attributes register
            uint32_t memattr4 : 1; // Delegation bit for stream 4 Memory Attributes register
            uint32_t memattr5 : 1; // Delegation bit for stream 5 Memory Attributes register
            uint32_t memattr6 : 1; // Delegation bit for stream 6 Memory Attributes register
            uint32_t memattr7 : 1; // Delegation bit for stream 7 Memory Attributes register
            uint32_t memattr8 : 1; // Delegation bit for stream 8 Memory Attributes register
            uint32_t reserved0 : 23;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_delegation_memattr_r(uint32_t init=0) : word(init) {}
    CONSTEXPR delegation_t get_memattr0() const { delegation_t value = static_cast<delegation_t>(bits.memattr0); return value;}
    CONSTEXPR void set_memattr0(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.memattr0 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_memattr1() const { delegation_t value = static_cast<delegation_t>(bits.memattr1); return value;}
    CONSTEXPR void set_memattr1(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.memattr1 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_memattr2() const { delegation_t value = static_cast<delegation_t>(bits.memattr2); return value;}
    CONSTEXPR void set_memattr2(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.memattr2 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_memattr3() const { delegation_t value = static_cast<delegation_t>(bits.memattr3); return value;}
    CONSTEXPR void set_memattr3(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.memattr3 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_memattr4() const { delegation_t value = static_cast<delegation_t>(bits.memattr4); return value;}
    CONSTEXPR void set_memattr4(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.memattr4 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_memattr5() const { delegation_t value = static_cast<delegation_t>(bits.memattr5); return value;}
    CONSTEXPR void set_memattr5(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.memattr5 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_memattr6() const { delegation_t value = static_cast<delegation_t>(bits.memattr6); return value;}
    CONSTEXPR void set_memattr6(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.memattr6 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_memattr7() const { delegation_t value = static_cast<delegation_t>(bits.memattr7); return value;}
    CONSTEXPR void set_memattr7(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.memattr7 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_memattr8() const { delegation_t value = static_cast<delegation_t>(bits.memattr8); return value;}
    CONSTEXPR void set_memattr8(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.memattr8 = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_delegation_address_extend_r - Extended address bits control delegation
//
struct dl3_delegation_address_extend_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t addressextend0 : 1; // Delegation bit for stream 0 ADDRESSEXTEND register
            uint32_t reserved0 : 1;
            uint32_t addressextend1 : 1; // Delegation bit for stream 1 ADDRESSEXTEND register
            uint32_t reserved1 : 1;
            uint32_t addressextend2 : 1; // Delegation bit for stream 2 ADDRESSEXTEND register
            uint32_t reserved2 : 27;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_delegation_address_extend_r(uint32_t init=0) : word(init) {}
    CONSTEXPR delegation_t get_addressextend0() const { delegation_t value = static_cast<delegation_t>(bits.addressextend0); return value;}
    CONSTEXPR void set_addressextend0(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.addressextend0 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_addressextend1() const { delegation_t value = static_cast<delegation_t>(bits.addressextend1); return value;}
    CONSTEXPR void set_addressextend1(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.addressextend1 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_addressextend2() const { delegation_t value = static_cast<delegation_t>(bits.addressextend2); return value;}
    CONSTEXPR void set_addressextend2(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.addressextend2 = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_stream0_stream_security_r - Stream 0 - Security State
//
struct dl3_stream0_stream_security_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusecsid : 1; // MMU stream security state
            uint32_t protns : 1; // AXI stream security state
            uint32_t reserved0 : 30;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_stream0_stream_security_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmusecsid() const { uint32_t value = static_cast<uint32_t>(bits.mmusecsid); return value;}
    CONSTEXPR void set_mmusecsid(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmusecsid = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_protns() const { uint32_t value = static_cast<uint32_t>(bits.protns); return value;}
    CONSTEXPR void set_protns(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.protns = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_stream0_nsaid_r - Stream 0 - Non-secure Access Identifier
//
struct dl3_stream0_nsaid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t nsaid : 4; // Non-Secure Address Identifier
            uint32_t reserved0 : 28;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_stream0_nsaid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_nsaid() const { uint32_t value = static_cast<uint32_t>(bits.nsaid); return value;}
    CONSTEXPR void set_nsaid(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.nsaid = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_stream0_mmusid_r - Stream 0 - MMU Stream Identifier
//
struct dl3_stream0_mmusid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusid : 32; // MMU Stream ID (actual width is implementation defined)
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_stream0_mmusid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmusid() const { uint32_t value = static_cast<uint32_t>(bits.mmusid); return value;}
    CONSTEXPR void set_mmusid(uint32_t value) { bits.mmusid = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_stream0_mmussid_r - Stream 0 - MMU Sub-stream Stream Identifier
//
struct dl3_stream0_mmussid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmussid : 20; // MMU Sub-Stream ID (actual width is implementation defined)
            uint32_t reserved0 : 11;
            uint32_t mmussidv : 1; // MMUSSID valid bit
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_stream0_mmussid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmussid() const { uint32_t value = static_cast<uint32_t>(bits.mmussid); return value;}
    CONSTEXPR void set_mmussid(uint32_t value) { assert(static_cast<uint32_t>(value) < 1048576u); bits.mmussid = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mmussidv() const { uint32_t value = static_cast<uint32_t>(bits.mmussidv); return value;}
    CONSTEXPR void set_mmussidv(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmussidv = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_stream0_attr_control_r - Stream 0 - Attribute Control
//
struct dl3_stream0_attr_control_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t attrlocked : 1; // Stream attributes locked
            uint32_t reserved0 : 31;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_stream0_attr_control_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_attrlocked() const { uint32_t value = static_cast<uint32_t>(bits.attrlocked); return value;}
    CONSTEXPR void set_attrlocked(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.attrlocked = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_stream0_memattr_r - Stream 0 - Memory Attributes
//
struct dl3_stream0_memattr_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t memattr : 4; // Memory attributes
            uint32_t reserved0 : 28;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_stream0_memattr_r(uint32_t init=0) : word(init) {}
    CONSTEXPR memory_attributes_t get_memattr() const { memory_attributes_t value = static_cast<memory_attributes_t>(bits.memattr); return value;}
    CONSTEXPR void set_memattr(memory_attributes_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.memattr = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_stream0_address_extend_r - Stream 0 - Extended address bits per stream
//
struct dl3_stream0_address_extend_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t reserved0 : 9;
            uint32_t addrextend : 20; // Address extension bits [48:29]
            uint32_t reserved1 : 3;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_stream0_address_extend_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_addrextend() const { uint32_t value = static_cast<uint32_t>(bits.addrextend); return value;}
    CONSTEXPR void set_addrextend(uint32_t value) { assert(static_cast<uint32_t>(value) < 1048576u); bits.addrextend = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_stream1_stream_security_r - Stream 1 - Security State
//
struct dl3_stream1_stream_security_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusecsid : 1; // MMU stream security state
            uint32_t protns : 1; // AXI stream security state
            uint32_t reserved0 : 30;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_stream1_stream_security_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmusecsid() const { uint32_t value = static_cast<uint32_t>(bits.mmusecsid); return value;}
    CONSTEXPR void set_mmusecsid(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmusecsid = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_protns() const { uint32_t value = static_cast<uint32_t>(bits.protns); return value;}
    CONSTEXPR void set_protns(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.protns = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_stream1_nsaid_r - Stream 1 - Non-secure Access Identifier
//
struct dl3_stream1_nsaid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t nsaid : 4; // Non-Secure Address Identifier
            uint32_t reserved0 : 28;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_stream1_nsaid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_nsaid() const { uint32_t value = static_cast<uint32_t>(bits.nsaid); return value;}
    CONSTEXPR void set_nsaid(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.nsaid = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_stream1_mmusid_r - Stream 1 - MMU Stream Identifier
//
struct dl3_stream1_mmusid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusid : 32; // MMU Stream ID (actual width is implementation defined)
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_stream1_mmusid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmusid() const { uint32_t value = static_cast<uint32_t>(bits.mmusid); return value;}
    CONSTEXPR void set_mmusid(uint32_t value) { bits.mmusid = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_stream1_mmussid_r - Stream 1 - MMU Sub-stream Stream Identifier
//
struct dl3_stream1_mmussid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmussid : 20; // MMU Sub-Stream ID (actual width is implementation defined)
            uint32_t reserved0 : 11;
            uint32_t mmussidv : 1; // MMUSSID valid bit
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_stream1_mmussid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmussid() const { uint32_t value = static_cast<uint32_t>(bits.mmussid); return value;}
    CONSTEXPR void set_mmussid(uint32_t value) { assert(static_cast<uint32_t>(value) < 1048576u); bits.mmussid = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mmussidv() const { uint32_t value = static_cast<uint32_t>(bits.mmussidv); return value;}
    CONSTEXPR void set_mmussidv(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmussidv = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_stream1_attr_control_r - Stream 1 - Attribute Control
//
struct dl3_stream1_attr_control_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t attrlocked : 1; // Stream attributes locked
            uint32_t reserved0 : 31;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_stream1_attr_control_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_attrlocked() const { uint32_t value = static_cast<uint32_t>(bits.attrlocked); return value;}
    CONSTEXPR void set_attrlocked(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.attrlocked = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_stream1_memattr_r - Stream 1 - Memory Attributes
//
struct dl3_stream1_memattr_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t memattr : 4; // Memory attributes
            uint32_t reserved0 : 28;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_stream1_memattr_r(uint32_t init=0) : word(init) {}
    CONSTEXPR memory_attributes_t get_memattr() const { memory_attributes_t value = static_cast<memory_attributes_t>(bits.memattr); return value;}
    CONSTEXPR void set_memattr(memory_attributes_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.memattr = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_stream1_address_extend_r - Stream 1 - Extended address bits per stream
//
struct dl3_stream1_address_extend_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t reserved0 : 9;
            uint32_t addrextend : 20; // Address extension bits [48:29]
            uint32_t reserved1 : 3;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_stream1_address_extend_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_addrextend() const { uint32_t value = static_cast<uint32_t>(bits.addrextend); return value;}
    CONSTEXPR void set_addrextend(uint32_t value) { assert(static_cast<uint32_t>(value) < 1048576u); bits.addrextend = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_stream2_stream_security_r - Stream 2 - Security State
//
struct dl3_stream2_stream_security_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusecsid : 1; // MMU stream security state
            uint32_t protns : 1; // AXI stream security state
            uint32_t reserved0 : 30;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_stream2_stream_security_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmusecsid() const { uint32_t value = static_cast<uint32_t>(bits.mmusecsid); return value;}
    CONSTEXPR void set_mmusecsid(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmusecsid = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_protns() const { uint32_t value = static_cast<uint32_t>(bits.protns); return value;}
    CONSTEXPR void set_protns(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.protns = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_stream2_nsaid_r - Stream 2 - Non-secure Access Identifier
//
struct dl3_stream2_nsaid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t nsaid : 4; // Non-Secure Address Identifier
            uint32_t reserved0 : 28;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_stream2_nsaid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_nsaid() const { uint32_t value = static_cast<uint32_t>(bits.nsaid); return value;}
    CONSTEXPR void set_nsaid(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.nsaid = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_stream2_mmusid_r - Stream 2 - MMU Stream Identifier
//
struct dl3_stream2_mmusid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusid : 32; // MMU Stream ID (actual width is implementation defined)
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_stream2_mmusid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmusid() const { uint32_t value = static_cast<uint32_t>(bits.mmusid); return value;}
    CONSTEXPR void set_mmusid(uint32_t value) { bits.mmusid = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_stream2_mmussid_r - Stream 2 - MMU Sub-stream Stream Identifier
//
struct dl3_stream2_mmussid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmussid : 20; // MMU Sub-Stream ID (actual width is implementation defined)
            uint32_t reserved0 : 11;
            uint32_t mmussidv : 1; // MMUSSID valid bit
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_stream2_mmussid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmussid() const { uint32_t value = static_cast<uint32_t>(bits.mmussid); return value;}
    CONSTEXPR void set_mmussid(uint32_t value) { assert(static_cast<uint32_t>(value) < 1048576u); bits.mmussid = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mmussidv() const { uint32_t value = static_cast<uint32_t>(bits.mmussidv); return value;}
    CONSTEXPR void set_mmussidv(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmussidv = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_stream2_attr_control_r - Stream 2 - Attribute Control
//
struct dl3_stream2_attr_control_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t attrlocked : 1; // Stream attributes locked
            uint32_t reserved0 : 31;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_stream2_attr_control_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_attrlocked() const { uint32_t value = static_cast<uint32_t>(bits.attrlocked); return value;}
    CONSTEXPR void set_attrlocked(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.attrlocked = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_stream2_memattr_r - Stream 2 - Memory Attributes
//
struct dl3_stream2_memattr_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t memattr : 4; // Memory attributes
            uint32_t reserved0 : 28;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_stream2_memattr_r(uint32_t init=0) : word(init) {}
    CONSTEXPR memory_attributes_t get_memattr() const { memory_attributes_t value = static_cast<memory_attributes_t>(bits.memattr); return value;}
    CONSTEXPR void set_memattr(memory_attributes_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.memattr = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_stream2_address_extend_r - Stream 2 - Extended address bits per stream
//
struct dl3_stream2_address_extend_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t reserved0 : 9;
            uint32_t addrextend : 20; // Address extension bits [48:29]
            uint32_t reserved1 : 3;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_stream2_address_extend_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_addrextend() const { uint32_t value = static_cast<uint32_t>(bits.addrextend); return value;}
    CONSTEXPR void set_addrextend(uint32_t value) { assert(static_cast<uint32_t>(value) < 1048576u); bits.addrextend = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_stream3_stream_security_r - Stream 3 - Security State
//
struct dl3_stream3_stream_security_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusecsid : 1; // MMU stream security state
            uint32_t protns : 1; // AXI stream security state
            uint32_t reserved0 : 30;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_stream3_stream_security_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmusecsid() const { uint32_t value = static_cast<uint32_t>(bits.mmusecsid); return value;}
    CONSTEXPR void set_mmusecsid(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmusecsid = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_protns() const { uint32_t value = static_cast<uint32_t>(bits.protns); return value;}
    CONSTEXPR void set_protns(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.protns = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_stream3_nsaid_r - Stream 3 - Non-secure Access Identifier
//
struct dl3_stream3_nsaid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t nsaid : 4; // Non-Secure Address Identifier
            uint32_t reserved0 : 28;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_stream3_nsaid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_nsaid() const { uint32_t value = static_cast<uint32_t>(bits.nsaid); return value;}
    CONSTEXPR void set_nsaid(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.nsaid = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_stream3_mmusid_r - Stream 3 - MMU Stream Identifier
//
struct dl3_stream3_mmusid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusid : 32; // MMU Stream ID (actual width is implementation defined)
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_stream3_mmusid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmusid() const { uint32_t value = static_cast<uint32_t>(bits.mmusid); return value;}
    CONSTEXPR void set_mmusid(uint32_t value) { bits.mmusid = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_stream3_mmussid_r - Stream 3 - MMU Sub-stream Stream Identifier
//
struct dl3_stream3_mmussid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmussid : 20; // MMU Sub-Stream ID (actual width is implementation defined)
            uint32_t reserved0 : 11;
            uint32_t mmussidv : 1; // MMUSSID valid bit
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_stream3_mmussid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmussid() const { uint32_t value = static_cast<uint32_t>(bits.mmussid); return value;}
    CONSTEXPR void set_mmussid(uint32_t value) { assert(static_cast<uint32_t>(value) < 1048576u); bits.mmussid = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mmussidv() const { uint32_t value = static_cast<uint32_t>(bits.mmussidv); return value;}
    CONSTEXPR void set_mmussidv(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmussidv = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_stream3_attr_control_r - Stream 3 - Attribute Control
//
struct dl3_stream3_attr_control_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t attrlocked : 1; // Stream attributes locked
            uint32_t reserved0 : 31;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_stream3_attr_control_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_attrlocked() const { uint32_t value = static_cast<uint32_t>(bits.attrlocked); return value;}
    CONSTEXPR void set_attrlocked(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.attrlocked = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_stream3_memattr_r - Stream 3 - Memory Attributes
//
struct dl3_stream3_memattr_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t memattr : 4; // Memory attributes
            uint32_t reserved0 : 28;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_stream3_memattr_r(uint32_t init=0) : word(init) {}
    CONSTEXPR memory_attributes_t get_memattr() const { memory_attributes_t value = static_cast<memory_attributes_t>(bits.memattr); return value;}
    CONSTEXPR void set_memattr(memory_attributes_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.memattr = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_stream4_stream_security_r - Stream 4 - Security State
//
struct dl3_stream4_stream_security_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusecsid : 1; // MMU stream security state
            uint32_t protns : 1; // AXI stream security state
            uint32_t reserved0 : 30;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_stream4_stream_security_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmusecsid() const { uint32_t value = static_cast<uint32_t>(bits.mmusecsid); return value;}
    CONSTEXPR void set_mmusecsid(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmusecsid = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_protns() const { uint32_t value = static_cast<uint32_t>(bits.protns); return value;}
    CONSTEXPR void set_protns(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.protns = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_stream4_nsaid_r - Stream 4 - Non-secure Access Identifier
//
struct dl3_stream4_nsaid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t nsaid : 4; // Non-Secure Address Identifier
            uint32_t reserved0 : 28;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_stream4_nsaid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_nsaid() const { uint32_t value = static_cast<uint32_t>(bits.nsaid); return value;}
    CONSTEXPR void set_nsaid(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.nsaid = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_stream4_mmusid_r - Stream 4 - MMU Stream Identifier
//
struct dl3_stream4_mmusid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusid : 32; // MMU Stream ID (actual width is implementation defined)
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_stream4_mmusid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmusid() const { uint32_t value = static_cast<uint32_t>(bits.mmusid); return value;}
    CONSTEXPR void set_mmusid(uint32_t value) { bits.mmusid = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_stream4_mmussid_r - Stream 4 - MMU Sub-stream Stream Identifier
//
struct dl3_stream4_mmussid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmussid : 20; // MMU Sub-Stream ID (actual width is implementation defined)
            uint32_t reserved0 : 11;
            uint32_t mmussidv : 1; // MMUSSID valid bit
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_stream4_mmussid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmussid() const { uint32_t value = static_cast<uint32_t>(bits.mmussid); return value;}
    CONSTEXPR void set_mmussid(uint32_t value) { assert(static_cast<uint32_t>(value) < 1048576u); bits.mmussid = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mmussidv() const { uint32_t value = static_cast<uint32_t>(bits.mmussidv); return value;}
    CONSTEXPR void set_mmussidv(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmussidv = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_stream4_attr_control_r - Stream 4 - Attribute Control
//
struct dl3_stream4_attr_control_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t attrlocked : 1; // Stream attributes locked
            uint32_t reserved0 : 31;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_stream4_attr_control_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_attrlocked() const { uint32_t value = static_cast<uint32_t>(bits.attrlocked); return value;}
    CONSTEXPR void set_attrlocked(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.attrlocked = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_stream4_memattr_r - Stream 4 - Memory Attributes
//
struct dl3_stream4_memattr_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t memattr : 4; // Memory attributes
            uint32_t reserved0 : 28;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_stream4_memattr_r(uint32_t init=0) : word(init) {}
    CONSTEXPR memory_attributes_t get_memattr() const { memory_attributes_t value = static_cast<memory_attributes_t>(bits.memattr); return value;}
    CONSTEXPR void set_memattr(memory_attributes_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.memattr = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_stream5_stream_security_r - Stream 5 - Security State
//
struct dl3_stream5_stream_security_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusecsid : 1; // MMU stream security state
            uint32_t protns : 1; // AXI stream security state
            uint32_t reserved0 : 30;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_stream5_stream_security_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmusecsid() const { uint32_t value = static_cast<uint32_t>(bits.mmusecsid); return value;}
    CONSTEXPR void set_mmusecsid(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmusecsid = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_protns() const { uint32_t value = static_cast<uint32_t>(bits.protns); return value;}
    CONSTEXPR void set_protns(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.protns = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_stream5_nsaid_r - Stream 5 - Non-secure Access Identifier
//
struct dl3_stream5_nsaid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t nsaid : 4; // Non-Secure Address Identifier
            uint32_t reserved0 : 28;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_stream5_nsaid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_nsaid() const { uint32_t value = static_cast<uint32_t>(bits.nsaid); return value;}
    CONSTEXPR void set_nsaid(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.nsaid = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_stream5_mmusid_r - Stream 5 - MMU Stream Identifier
//
struct dl3_stream5_mmusid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusid : 32; // MMU Stream ID (actual width is implementation defined)
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_stream5_mmusid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmusid() const { uint32_t value = static_cast<uint32_t>(bits.mmusid); return value;}
    CONSTEXPR void set_mmusid(uint32_t value) { bits.mmusid = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_stream5_mmussid_r - Stream 5 - MMU Sub-stream Stream Identifier
//
struct dl3_stream5_mmussid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmussid : 20; // MMU Sub-Stream ID (actual width is implementation defined)
            uint32_t reserved0 : 11;
            uint32_t mmussidv : 1; // MMUSSID valid bit
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_stream5_mmussid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmussid() const { uint32_t value = static_cast<uint32_t>(bits.mmussid); return value;}
    CONSTEXPR void set_mmussid(uint32_t value) { assert(static_cast<uint32_t>(value) < 1048576u); bits.mmussid = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mmussidv() const { uint32_t value = static_cast<uint32_t>(bits.mmussidv); return value;}
    CONSTEXPR void set_mmussidv(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmussidv = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_stream5_attr_control_r - Stream 5 - Attribute Control
//
struct dl3_stream5_attr_control_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t attrlocked : 1; // Stream attributes locked
            uint32_t reserved0 : 31;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_stream5_attr_control_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_attrlocked() const { uint32_t value = static_cast<uint32_t>(bits.attrlocked); return value;}
    CONSTEXPR void set_attrlocked(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.attrlocked = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_stream5_memattr_r - Stream 5 - Memory Attributes
//
struct dl3_stream5_memattr_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t memattr : 4; // Memory attributes
            uint32_t reserved0 : 28;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_stream5_memattr_r(uint32_t init=0) : word(init) {}
    CONSTEXPR memory_attributes_t get_memattr() const { memory_attributes_t value = static_cast<memory_attributes_t>(bits.memattr); return value;}
    CONSTEXPR void set_memattr(memory_attributes_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.memattr = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_stream6_stream_security_r - Stream 6 - Security State
//
struct dl3_stream6_stream_security_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusecsid : 1; // MMU stream security state
            uint32_t protns : 1; // AXI stream security state
            uint32_t reserved0 : 30;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_stream6_stream_security_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmusecsid() const { uint32_t value = static_cast<uint32_t>(bits.mmusecsid); return value;}
    CONSTEXPR void set_mmusecsid(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmusecsid = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_protns() const { uint32_t value = static_cast<uint32_t>(bits.protns); return value;}
    CONSTEXPR void set_protns(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.protns = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_stream6_nsaid_r - Stream 6 - Non-secure Access Identifier
//
struct dl3_stream6_nsaid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t nsaid : 4; // Non-Secure Address Identifier
            uint32_t reserved0 : 28;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_stream6_nsaid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_nsaid() const { uint32_t value = static_cast<uint32_t>(bits.nsaid); return value;}
    CONSTEXPR void set_nsaid(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.nsaid = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_stream6_mmusid_r - Stream 6 - MMU Stream Identifier
//
struct dl3_stream6_mmusid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusid : 32; // MMU Stream ID (actual width is implementation defined)
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_stream6_mmusid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmusid() const { uint32_t value = static_cast<uint32_t>(bits.mmusid); return value;}
    CONSTEXPR void set_mmusid(uint32_t value) { bits.mmusid = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_stream6_mmussid_r - Stream 6 - MMU Sub-stream Stream Identifier
//
struct dl3_stream6_mmussid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmussid : 20; // MMU Sub-Stream ID (actual width is implementation defined)
            uint32_t reserved0 : 11;
            uint32_t mmussidv : 1; // MMUSSID valid bit
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_stream6_mmussid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmussid() const { uint32_t value = static_cast<uint32_t>(bits.mmussid); return value;}
    CONSTEXPR void set_mmussid(uint32_t value) { assert(static_cast<uint32_t>(value) < 1048576u); bits.mmussid = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mmussidv() const { uint32_t value = static_cast<uint32_t>(bits.mmussidv); return value;}
    CONSTEXPR void set_mmussidv(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmussidv = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_stream6_attr_control_r - Stream 6 - Attribute Control
//
struct dl3_stream6_attr_control_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t attrlocked : 1; // Stream attributes locked
            uint32_t reserved0 : 31;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_stream6_attr_control_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_attrlocked() const { uint32_t value = static_cast<uint32_t>(bits.attrlocked); return value;}
    CONSTEXPR void set_attrlocked(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.attrlocked = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_stream6_memattr_r - Stream 6 - Memory Attributes
//
struct dl3_stream6_memattr_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t memattr : 4; // Memory attributes
            uint32_t reserved0 : 28;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_stream6_memattr_r(uint32_t init=0) : word(init) {}
    CONSTEXPR memory_attributes_t get_memattr() const { memory_attributes_t value = static_cast<memory_attributes_t>(bits.memattr); return value;}
    CONSTEXPR void set_memattr(memory_attributes_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.memattr = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_stream7_stream_security_r - Stream 7 - Security State
//
struct dl3_stream7_stream_security_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusecsid : 1; // MMU stream security state
            uint32_t protns : 1; // AXI stream security state
            uint32_t reserved0 : 30;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_stream7_stream_security_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmusecsid() const { uint32_t value = static_cast<uint32_t>(bits.mmusecsid); return value;}
    CONSTEXPR void set_mmusecsid(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmusecsid = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_protns() const { uint32_t value = static_cast<uint32_t>(bits.protns); return value;}
    CONSTEXPR void set_protns(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.protns = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_stream7_nsaid_r - Stream 7 - Non-secure Access Identifier
//
struct dl3_stream7_nsaid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t nsaid : 4; // Non-Secure Address Identifier
            uint32_t reserved0 : 28;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_stream7_nsaid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_nsaid() const { uint32_t value = static_cast<uint32_t>(bits.nsaid); return value;}
    CONSTEXPR void set_nsaid(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.nsaid = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_stream7_mmusid_r - Stream 7 - MMU Stream Identifier
//
struct dl3_stream7_mmusid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusid : 32; // MMU Stream ID (actual width is implementation defined)
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_stream7_mmusid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmusid() const { uint32_t value = static_cast<uint32_t>(bits.mmusid); return value;}
    CONSTEXPR void set_mmusid(uint32_t value) { bits.mmusid = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_stream7_mmussid_r - Stream 7 - MMU Sub-stream Stream Identifier
//
struct dl3_stream7_mmussid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmussid : 20; // MMU Sub-Stream ID (actual width is implementation defined)
            uint32_t reserved0 : 11;
            uint32_t mmussidv : 1; // MMUSSID valid bit
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_stream7_mmussid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmussid() const { uint32_t value = static_cast<uint32_t>(bits.mmussid); return value;}
    CONSTEXPR void set_mmussid(uint32_t value) { assert(static_cast<uint32_t>(value) < 1048576u); bits.mmussid = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mmussidv() const { uint32_t value = static_cast<uint32_t>(bits.mmussidv); return value;}
    CONSTEXPR void set_mmussidv(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmussidv = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_stream7_attr_control_r - Stream 7 - Attribute Control
//
struct dl3_stream7_attr_control_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t attrlocked : 1; // Stream attributes locked
            uint32_t reserved0 : 31;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_stream7_attr_control_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_attrlocked() const { uint32_t value = static_cast<uint32_t>(bits.attrlocked); return value;}
    CONSTEXPR void set_attrlocked(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.attrlocked = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_stream7_memattr_r - Stream 7 - Memory Attributes
//
struct dl3_stream7_memattr_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t memattr : 4; // Memory attributes
            uint32_t reserved0 : 28;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_stream7_memattr_r(uint32_t init=0) : word(init) {}
    CONSTEXPR memory_attributes_t get_memattr() const { memory_attributes_t value = static_cast<memory_attributes_t>(bits.memattr); return value;}
    CONSTEXPR void set_memattr(memory_attributes_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.memattr = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_stream8_stream_security_r - Stream 8 - Security State
//
struct dl3_stream8_stream_security_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusecsid : 1; // MMU stream security state
            uint32_t protns : 1; // AXI stream security state
            uint32_t reserved0 : 30;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_stream8_stream_security_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmusecsid() const { uint32_t value = static_cast<uint32_t>(bits.mmusecsid); return value;}
    CONSTEXPR void set_mmusecsid(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmusecsid = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_protns() const { uint32_t value = static_cast<uint32_t>(bits.protns); return value;}
    CONSTEXPR void set_protns(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.protns = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_stream8_nsaid_r - Stream 8 - Non-secure Access Identifier
//
struct dl3_stream8_nsaid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t nsaid : 4; // Non-Secure Address Identifier
            uint32_t reserved0 : 28;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_stream8_nsaid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_nsaid() const { uint32_t value = static_cast<uint32_t>(bits.nsaid); return value;}
    CONSTEXPR void set_nsaid(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.nsaid = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_stream8_mmusid_r - Stream 8 - MMU Stream Identifier
//
struct dl3_stream8_mmusid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusid : 32; // MMU Stream ID (actual width is implementation defined)
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_stream8_mmusid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmusid() const { uint32_t value = static_cast<uint32_t>(bits.mmusid); return value;}
    CONSTEXPR void set_mmusid(uint32_t value) { bits.mmusid = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_stream8_mmussid_r - Stream 8 - MMU Sub-stream Stream Identifier
//
struct dl3_stream8_mmussid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmussid : 20; // MMU Sub-Stream ID (actual width is implementation defined)
            uint32_t reserved0 : 11;
            uint32_t mmussidv : 1; // MMUSSID valid bit
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_stream8_mmussid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmussid() const { uint32_t value = static_cast<uint32_t>(bits.mmussid); return value;}
    CONSTEXPR void set_mmussid(uint32_t value) { assert(static_cast<uint32_t>(value) < 1048576u); bits.mmussid = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mmussidv() const { uint32_t value = static_cast<uint32_t>(bits.mmussidv); return value;}
    CONSTEXPR void set_mmussidv(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmussidv = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_stream8_attr_control_r - Stream 8 - Attribute Control
//
struct dl3_stream8_attr_control_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t attrlocked : 1; // Stream attributes locked
            uint32_t reserved0 : 31;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_stream8_attr_control_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_attrlocked() const { uint32_t value = static_cast<uint32_t>(bits.attrlocked); return value;}
    CONSTEXPR void set_attrlocked(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.attrlocked = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_stream8_memattr_r - Stream 8 - Memory Attributes
//
struct dl3_stream8_memattr_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t memattr : 4; // Memory attributes
            uint32_t reserved0 : 28;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_stream8_memattr_r(uint32_t init=0) : word(init) {}
    CONSTEXPR memory_attributes_t get_memattr() const { memory_attributes_t value = static_cast<memory_attributes_t>(bits.memattr); return value;}
    CONSTEXPR void set_memattr(memory_attributes_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.memattr = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_npu_id_r - NPU ID register
//
struct dl3_npu_id_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t version_status : 4; // Status of the NPU release
            uint32_t version_minor : 4; // Minor release version number
            uint32_t version_major : 4; // Major release version number
            uint32_t product_major : 4; // Product identifier
            uint32_t arch_rev : 8; // Architecture patch revision
            uint32_t arch_minor : 4; // Architecture minor revision
            uint32_t arch_major : 4; // Architecture major revision
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_npu_id_r(uint32_t init=0) : word(init) {}
    CONSTEXPR npu_version_status_t get_version_status() const { npu_version_status_t value = static_cast<npu_version_status_t>(bits.version_status); return value;}
    CONSTEXPR void set_version_status(npu_version_status_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.version_status = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_version_minor() const { uint32_t value = static_cast<uint32_t>(bits.version_minor); return value;}
    CONSTEXPR void set_version_minor(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.version_minor = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_version_major() const { uint32_t value = static_cast<uint32_t>(bits.version_major); return value;}
    CONSTEXPR void set_version_major(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.version_major = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_product_major() const { uint32_t value = static_cast<uint32_t>(bits.product_major); return value;}
    CONSTEXPR void set_product_major(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.product_major = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_arch_rev() const { uint32_t value = static_cast<uint32_t>(bits.arch_rev); return value;}
    CONSTEXPR void set_arch_rev(uint32_t value) { assert(static_cast<uint32_t>(value) < 256u); bits.arch_rev = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_arch_minor() const { uint32_t value = static_cast<uint32_t>(bits.arch_minor); return value;}
    CONSTEXPR void set_arch_minor(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.arch_minor = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_arch_major() const { uint32_t value = static_cast<uint32_t>(bits.arch_major); return value;}
    CONSTEXPR void set_arch_major(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.arch_major = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_unit_count_r - Units present count
//
struct dl3_unit_count_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t quad_count : 8; // Number of quads
            uint32_t engines_per_quad : 8; // Number of engines per quad
            uint32_t dfc_emc_per_engine : 4; // Number of memory controllers per engine
            uint32_t reserved0 : 12;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_unit_count_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_quad_count() const { uint32_t value = static_cast<uint32_t>(bits.quad_count); return value;}
    CONSTEXPR void set_quad_count(uint32_t value) { assert(static_cast<uint32_t>(value) < 256u); bits.quad_count = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_engines_per_quad() const { uint32_t value = static_cast<uint32_t>(bits.engines_per_quad); return value;}
    CONSTEXPR void set_engines_per_quad(uint32_t value) { assert(static_cast<uint32_t>(value) < 256u); bits.engines_per_quad = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_dfc_emc_per_engine() const { uint32_t value = static_cast<uint32_t>(bits.dfc_emc_per_engine); return value;}
    CONSTEXPR void set_dfc_emc_per_engine(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.dfc_emc_per_engine = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_mce_features_r - MCE features
//
struct dl3_mce_features_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t ifm_generated_per_engine : 4; // IFMs sent to broadcast network per engine
            uint32_t reserved0 : 4;
            uint32_t ofm_generated_per_engine : 4; // OFMs generated per Engine
            uint32_t mce_num_macs : 8; // Number of MAC units per MCE
            uint32_t mce_num_acc : 8; // Number of accumulators per MAC unit
            uint32_t winograd_support : 1; // Winograd funcationality present
            uint32_t tsu_16bit_sequence_support : 1; // TSU support for automatically sequencing 16 bit IFM and weights
            uint32_t ofm_scaling_16bit_support : 1; // Hardware support for scaling results from 16-bit operations
            uint32_t reserved1 : 1;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_mce_features_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_ifm_generated_per_engine() const { uint32_t value = static_cast<uint32_t>(bits.ifm_generated_per_engine); return value;}
    CONSTEXPR void set_ifm_generated_per_engine(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.ifm_generated_per_engine = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ofm_generated_per_engine() const { uint32_t value = static_cast<uint32_t>(bits.ofm_generated_per_engine); return value;}
    CONSTEXPR void set_ofm_generated_per_engine(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.ofm_generated_per_engine = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mce_num_macs() const { uint32_t value = static_cast<uint32_t>(bits.mce_num_macs); return value;}
    CONSTEXPR void set_mce_num_macs(uint32_t value) { assert(static_cast<uint32_t>(value) < 256u); bits.mce_num_macs = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mce_num_acc() const { uint32_t value = static_cast<uint32_t>(bits.mce_num_acc); return value;}
    CONSTEXPR void set_mce_num_acc(uint32_t value) { assert(static_cast<uint32_t>(value) < 256u); bits.mce_num_acc = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_winograd_support() const { uint32_t value = static_cast<uint32_t>(bits.winograd_support); return value;}
    CONSTEXPR void set_winograd_support(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.winograd_support = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_tsu_16bit_sequence_support() const { uint32_t value = static_cast<uint32_t>(bits.tsu_16bit_sequence_support); return value;}
    CONSTEXPR void set_tsu_16bit_sequence_support(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.tsu_16bit_sequence_support = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ofm_scaling_16bit_support() const { uint32_t value = static_cast<uint32_t>(bits.ofm_scaling_16bit_support); return value;}
    CONSTEXPR void set_ofm_scaling_16bit_support(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ofm_scaling_16bit_support = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_dfc_features_r - DFC features
//
struct dl3_dfc_features_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t dfc_mem_size_per_emc : 16; // DFC memory size per EMC
            uint32_t bank_count : 6; // Number of banks in DFC memory
            uint32_t activation_compression : 4; // Version of activation compression supported
            uint32_t reserved0 : 6;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_dfc_features_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_dfc_mem_size_per_emc() const { uint32_t value = static_cast<uint32_t>(bits.dfc_mem_size_per_emc); return (value << 12);}
    CONSTEXPR void set_dfc_mem_size_per_emc(uint32_t value) { assert(static_cast<uint32_t>((value >> 12)) < 65536u); bits.dfc_mem_size_per_emc = static_cast<uint32_t>((value >> 12)); }
    CONSTEXPR uint32_t get_bank_count() const { uint32_t value = static_cast<uint32_t>(bits.bank_count); return value;}
    CONSTEXPR void set_bank_count(uint32_t value) { assert(static_cast<uint32_t>(value) < 64u); bits.bank_count = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_activation_compression() const { uint32_t value = static_cast<uint32_t>(bits.activation_compression); return value;}
    CONSTEXPR void set_activation_compression(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.activation_compression = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_ple_features_r - PLE features
//
struct dl3_ple_features_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t ple_input_mem_size : 8; // PLE input memory size
            uint32_t ple_output_mem_size : 8; // PLE output memory size
            uint32_t ple_vrf_mem_size : 8; // PLE vector register file memory size
            uint32_t ple_mem_size : 8; // PLE base memory size
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_ple_features_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_ple_input_mem_size() const { uint32_t value = static_cast<uint32_t>(bits.ple_input_mem_size); return (value << 8);}
    CONSTEXPR void set_ple_input_mem_size(uint32_t value) { assert(static_cast<uint32_t>((value >> 8)) < 256u); bits.ple_input_mem_size = static_cast<uint32_t>((value >> 8)); }
    CONSTEXPR uint32_t get_ple_output_mem_size() const { uint32_t value = static_cast<uint32_t>(bits.ple_output_mem_size); return (value << 8);}
    CONSTEXPR void set_ple_output_mem_size(uint32_t value) { assert(static_cast<uint32_t>((value >> 8)) < 256u); bits.ple_output_mem_size = static_cast<uint32_t>((value >> 8)); }
    CONSTEXPR uint32_t get_ple_vrf_mem_size() const { uint32_t value = static_cast<uint32_t>(bits.ple_vrf_mem_size); return (value << 4);}
    CONSTEXPR void set_ple_vrf_mem_size(uint32_t value) { assert(static_cast<uint32_t>((value >> 4)) < 256u); bits.ple_vrf_mem_size = static_cast<uint32_t>((value >> 4)); }
    CONSTEXPR uint32_t get_ple_mem_size() const { uint32_t value = static_cast<uint32_t>(bits.ple_mem_size); return (value << 8);}
    CONSTEXPR void set_ple_mem_size(uint32_t value) { assert(static_cast<uint32_t>((value >> 8)) < 256u); bits.ple_mem_size = static_cast<uint32_t>((value >> 8)); }
#endif
};


//
// dl3_wd_features_r - Weight Decoder features
//
struct dl3_wd_features_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t buffer_size : 8; // Weight decoder buffer size
            uint32_t max_dim : 8; // Weight decoder max dimension
            uint32_t compression_version : 4; // Version of weight compression implemented
            uint32_t reserved0 : 12;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_wd_features_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_buffer_size() const { uint32_t value = static_cast<uint32_t>(bits.buffer_size); return value;}
    CONSTEXPR void set_buffer_size(uint32_t value) { assert(static_cast<uint32_t>(value) < 256u); bits.buffer_size = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_max_dim() const { uint32_t value = static_cast<uint32_t>(bits.max_dim); return value;}
    CONSTEXPR void set_max_dim(uint32_t value) { assert(static_cast<uint32_t>(value) < 256u); bits.max_dim = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_compression_version() const { uint32_t value = static_cast<uint32_t>(bits.compression_version); return value;}
    CONSTEXPR void set_compression_version(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.compression_version = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_vector_engine_features_r - PLE VE features
//
struct dl3_vector_engine_features_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t vector_engine_version : 4; // Version of the vector engine implemented
            uint32_t ple_lanes : 2; // Number of lanes in the PLE
            uint32_t reserved0 : 26;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_vector_engine_features_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_vector_engine_version() const { uint32_t value = static_cast<uint32_t>(bits.vector_engine_version); return value;}
    CONSTEXPR void set_vector_engine_version(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.vector_engine_version = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ple_lanes() const { uint32_t value = static_cast<uint32_t>(bits.ple_lanes); return (value + 1);}
    CONSTEXPR void set_ple_lanes(uint32_t value) { assert(static_cast<uint32_t>((value - 1)) < 4u); bits.ple_lanes = static_cast<uint32_t>((value - 1)); }
#endif
};


//
// dl3_ecoid_r - Encoding describing ECOs implemented
//
struct dl3_ecoid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t ecoid : 12; // Field for describing ECOs implemented
            uint32_t reserved0 : 20;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_ecoid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_ecoid() const { uint32_t value = static_cast<uint32_t>(bits.ecoid); return value;}
    CONSTEXPR void set_ecoid(uint32_t value) { assert(static_cast<uint32_t>(value) < 4096u); bits.ecoid = static_cast<uint32_t>(value); }
#endif
};


//
// dl3_streamid_width_r - Configured StreamID widths
//
struct dl3_streamid_width_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusid_w : 5; // Configured width of StreamID (AxMMUSID)
            uint32_t reserved0 : 3;
            uint32_t mmussid_w : 5; // Configured width of SubstreamID (AxMMUSSID)
            uint32_t reserved1 : 19;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dl3_streamid_width_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmusid_w() const { uint32_t value = static_cast<uint32_t>(bits.mmusid_w); return (value + 1);}
    CONSTEXPR void set_mmusid_w(uint32_t value) { assert(static_cast<uint32_t>((value - 1)) < 32u); bits.mmusid_w = static_cast<uint32_t>((value - 1)); }
    CONSTEXPR uint32_t get_mmussid_w() const { uint32_t value = static_cast<uint32_t>(bits.mmussid_w); return (value + 1);}
    CONSTEXPR void set_mmussid_w(uint32_t value) { assert(static_cast<uint32_t>((value - 1)) < 32u); bits.mmussid_w = static_cast<uint32_t>((value - 1)); }
#endif
};


//
// dram_addr_l_r - DRAM base address low 32 bits
//
struct dram_addr_l_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t dram_address_l : 32; // Lower 32 bits of external DRAM address
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dram_addr_l_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_dram_address_l() const { uint32_t value = static_cast<uint32_t>(bits.dram_address_l); return value;}
    CONSTEXPR void set_dram_address_l(uint32_t value) { bits.dram_address_l = static_cast<uint32_t>(value); }
#endif
};


//
// dram_addr_h_r - DRAM base address high 17 bits
//
struct dram_addr_h_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t dram_address_h : 17; // High 17 bits of external DRAM address
            uint32_t reserved0 : 15;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dram_addr_h_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_dram_address_h() const { uint32_t value = static_cast<uint32_t>(bits.dram_address_h); return value;}
    CONSTEXPR void set_dram_address_h(uint32_t value) { assert(static_cast<uint32_t>(value) < 131072u); bits.dram_address_h = static_cast<uint32_t>(value); }
#endif
};


//
// dma_status_r - DMA engine status
//
struct dma_status_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t dma_idle : 1; // DMA engine is idle
            uint32_t rd_cmdq_free : 3; // Number of slots free in read command queue
            uint32_t last_rd_id_written : 3; // ID of the last read command written
            uint32_t last_rd_id_completed : 3; // ID of the last read command completed
            uint32_t wr_cmdq_free : 3; // Number of slots free in write command queue
            uint32_t last_wr_id_written : 3; // ID of the last write command written
            uint32_t last_wr_id_completed : 3; // ID of the last write command completed
            uint32_t reserved0 : 13;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dma_status_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_dma_idle() const { uint32_t value = static_cast<uint32_t>(bits.dma_idle); return value;}
    CONSTEXPR void set_dma_idle(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.dma_idle = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_rd_cmdq_free() const { uint32_t value = static_cast<uint32_t>(bits.rd_cmdq_free); return value;}
    CONSTEXPR void set_rd_cmdq_free(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.rd_cmdq_free = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_last_rd_id_written() const { uint32_t value = static_cast<uint32_t>(bits.last_rd_id_written); return value;}
    CONSTEXPR void set_last_rd_id_written(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.last_rd_id_written = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_last_rd_id_completed() const { uint32_t value = static_cast<uint32_t>(bits.last_rd_id_completed); return value;}
    CONSTEXPR void set_last_rd_id_completed(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.last_rd_id_completed = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_wr_cmdq_free() const { uint32_t value = static_cast<uint32_t>(bits.wr_cmdq_free); return value;}
    CONSTEXPR void set_wr_cmdq_free(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.wr_cmdq_free = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_last_wr_id_written() const { uint32_t value = static_cast<uint32_t>(bits.last_wr_id_written); return value;}
    CONSTEXPR void set_last_wr_id_written(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.last_wr_id_written = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_last_wr_id_completed() const { uint32_t value = static_cast<uint32_t>(bits.last_wr_id_completed); return value;}
    CONSTEXPR void set_last_wr_id_completed(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.last_wr_id_completed = static_cast<uint32_t>(value); }
#endif
};


//
// sram_addr_r - SRAM base address
//
struct sram_addr_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t address : 15; // Address into SRAM in terms of 128-bit words
            uint32_t reserved0 : 1;
            uint32_t address_h : 15; // Address into SRAM in terms of 128-bit words (higher bytes)
            uint32_t reserved1 : 1;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sram_addr_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_address() const { uint32_t value = static_cast<uint32_t>(bits.address); return (value << 4);}
    CONSTEXPR void set_address(uint32_t value) { assert(static_cast<uint32_t>((value >> 4)) < 32768u); bits.address = static_cast<uint32_t>((value >> 4)); }
    CONSTEXPR uint32_t get_address_h() const { uint32_t value = static_cast<uint32_t>(bits.address_h); return (value << 4);}
    CONSTEXPR void set_address_h(uint32_t value) { assert(static_cast<uint32_t>((value >> 4)) < 32768u); bits.address_h = static_cast<uint32_t>((value >> 4)); }
#endif
};


//
// dma_emcs_r - EMCs to be accessed by the next command
//
struct dma_emcs_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t emcs : 32; // Bit mask indicating the engine memory controllers to be accessed in the next command
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dma_emcs_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_emcs() const { uint32_t value = static_cast<uint32_t>(bits.emcs); return value;}
    CONSTEXPR void set_emcs(uint32_t value) { bits.emcs = static_cast<uint32_t>(value); }
#endif
};


//
// dma_channels_r - Channels for both read and write commands
//
struct dma_channels_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t channels : 16; // Number of channels minus 1
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dma_channels_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_channels() const { uint32_t value = static_cast<uint32_t>(bits.channels); return (value + 1);}
    CONSTEXPR void set_channels(uint32_t value) { assert(static_cast<uint32_t>((value - 1)) < 65536u); bits.channels = static_cast<uint32_t>((value - 1)); }
#endif
};


//
// dma_rd_cmd_r - DMA read command queue
//
struct dma_rd_cmd_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t rd_id : 3; // Read ID
            uint32_t format : 3; // DMA read transfer format
            uint32_t stream_type : 3; // DMA read stream type
            uint32_t int_transfer : 1; // Indicates that this is an internal transfer (SRAM to SRAM)
            uint32_t nhwc16 : 1; // Indicates that this is a NHWC16 read transfer
            uint32_t reserved0 : 21;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dma_rd_cmd_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_rd_id() const { uint32_t value = static_cast<uint32_t>(bits.rd_id); return value;}
    CONSTEXPR void set_rd_id(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.rd_id = static_cast<uint32_t>(value); }
    CONSTEXPR dma_format_read_t get_format() const { dma_format_read_t value = static_cast<dma_format_read_t>(bits.format); return value;}
    CONSTEXPR void set_format(dma_format_read_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.format = static_cast<uint32_t>(value); }
    CONSTEXPR dma_stream_type_t get_stream_type() const { dma_stream_type_t value = static_cast<dma_stream_type_t>(bits.stream_type); return value;}
    CONSTEXPR void set_stream_type(dma_stream_type_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.stream_type = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_int_transfer() const { uint32_t value = static_cast<uint32_t>(bits.int_transfer); return value;}
    CONSTEXPR void set_int_transfer(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.int_transfer = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_nhwc16() const { uint32_t value = static_cast<uint32_t>(bits.nhwc16); return value;}
    CONSTEXPR void set_nhwc16(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.nhwc16 = static_cast<uint32_t>(value); }
#endif
};


//
// dma_wr_cmd_r - DMA write command queue
//
struct dma_wr_cmd_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t wr_id : 3; // Write ID
            uint32_t format : 3; // DMA write transfer format
            uint32_t stream_type : 3; // DMA write stream type
            uint32_t int_transfer : 1; // Indicates that this is an internal transfer (SRAM to SRAM)
            uint32_t nhwc16 : 1; // Indicates that this is a NHWC16 write transfer
            uint32_t reserved0 : 21;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dma_wr_cmd_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_wr_id() const { uint32_t value = static_cast<uint32_t>(bits.wr_id); return value;}
    CONSTEXPR void set_wr_id(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.wr_id = static_cast<uint32_t>(value); }
    CONSTEXPR dma_format_write_t get_format() const { dma_format_write_t value = static_cast<dma_format_write_t>(bits.format); return value;}
    CONSTEXPR void set_format(dma_format_write_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.format = static_cast<uint32_t>(value); }
    CONSTEXPR dma_stream_type_t get_stream_type() const { dma_stream_type_t value = static_cast<dma_stream_type_t>(bits.stream_type); return value;}
    CONSTEXPR void set_stream_type(dma_stream_type_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.stream_type = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_int_transfer() const { uint32_t value = static_cast<uint32_t>(bits.int_transfer); return value;}
    CONSTEXPR void set_int_transfer(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.int_transfer = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_nhwc16() const { uint32_t value = static_cast<uint32_t>(bits.nhwc16); return value;}
    CONSTEXPR void set_nhwc16(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.nhwc16 = static_cast<uint32_t>(value); }
#endif
};


//
// dma_stride0_r - Strides for both read and write commands
//
struct dma_stride0_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t inner_stride : 32; // Inner byte stride minus 1
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dma_stride0_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_inner_stride() const { uint32_t value = static_cast<uint32_t>(bits.inner_stride); return (value + 1);}
    CONSTEXPR void set_inner_stride(uint32_t value) { bits.inner_stride = static_cast<uint32_t>((value - 1)); }
#endif
};


//
// dma_stride1_r - Strides for both read and write commands
//
struct dma_stride1_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t outer_stride : 32; // Outer byte stride minus 1
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dma_stride1_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_outer_stride() const { uint32_t value = static_cast<uint32_t>(bits.outer_stride); return (value + 1);}
    CONSTEXPR void set_outer_stride(uint32_t value) { bits.outer_stride = static_cast<uint32_t>((value - 1)); }
#endif
};


//
// dma_stride2_r - Strides for both read and write commands
//
struct dma_stride2_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t extra_stride : 32; // Extra byte stride minus 1
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dma_stride2_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_extra_stride() const { uint32_t value = static_cast<uint32_t>(bits.extra_stride); return (value + 1);}
    CONSTEXPR void set_extra_stride(uint32_t value) { bits.extra_stride = static_cast<uint32_t>((value - 1)); }
#endif
};


//
// dma_stride3_r - Strides for both read and write commands
//
struct dma_stride3_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t stride3 : 32; // Extra byte stride minus 1
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dma_stride3_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_stride3() const { uint32_t value = static_cast<uint32_t>(bits.stride3); return (value + 1);}
    CONSTEXPR void set_stride3(uint32_t value) { bits.stride3 = static_cast<uint32_t>((value - 1)); }
#endif
};


//
// dma_sram_stride_r - SRAM stride for read and write commands
//
struct dma_sram_stride_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t sram_group_stride : 15; // SRAM group stride minus 1 in terms of 128-bit words
            uint32_t reserved0 : 1;
            uint32_t sram_row_stride : 15; // SRAM row stride minus 1 in terms of 128-bit words
            uint32_t reserved1 : 1;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dma_sram_stride_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_sram_group_stride() const { uint32_t value = static_cast<uint32_t>(bits.sram_group_stride); return (value + 1);}
    CONSTEXPR void set_sram_group_stride(uint32_t value) { assert(static_cast<uint32_t>((value - 1)) < 32768u); bits.sram_group_stride = static_cast<uint32_t>((value - 1)); }
    CONSTEXPR uint32_t get_sram_row_stride() const { uint32_t value = static_cast<uint32_t>(bits.sram_row_stride); return (value + 1);}
    CONSTEXPR void set_sram_row_stride(uint32_t value) { assert(static_cast<uint32_t>((value - 1)) < 32768u); bits.sram_row_stride = static_cast<uint32_t>((value - 1)); }
#endif
};


//
// dma_total_bytes_r - Total number of bytes for both read and write commands
//
struct dma_total_bytes_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t total_bytes : 32; // Total number of bytes minus 1 read/written
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dma_total_bytes_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_total_bytes() const { uint32_t value = static_cast<uint32_t>(bits.total_bytes); return (value + 1);}
    CONSTEXPR void set_total_bytes(uint32_t value) { bits.total_bytes = static_cast<uint32_t>((value - 1)); }
#endif
};


//
// dma_comp_config0_r - DMA compression control registers
//
struct dma_comp_config0_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t reserved0 : 23;
            uint32_t signed_activations : 1; // 8-bit activation elements are in signed 8-bit format.
            uint32_t zero_point : 8; // Zero point value for this compression/decompression operation
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR dma_comp_config0_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_signed_activations() const { uint32_t value = static_cast<uint32_t>(bits.signed_activations); return value;}
    CONSTEXPR void set_signed_activations(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.signed_activations = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_zero_point() const { uint32_t value = static_cast<uint32_t>(bits.zero_point); return value;}
    CONSTEXPR void set_zero_point(uint32_t value) { assert(static_cast<uint32_t>(value) < 256u); bits.zero_point = static_cast<uint32_t>(value); }
#endif
};


//
// stash_address_l_r - StashTranslation address lower 32 bits
//
struct stash_address_l_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t stream_id : 4; // ID of the stream requesting the StashTranslation transaction
            uint32_t reserved0 : 8;
            uint32_t stash_addr_low : 20; // StashTranslation address bits [31:12]
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR stash_address_l_r(uint32_t init=0) : word(init) {}
    CONSTEXPR stream_type_t get_stream_id() const { stream_type_t value = static_cast<stream_type_t>(bits.stream_id); return value;}
    CONSTEXPR void set_stream_id(stream_type_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.stream_id = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_stash_addr_low() const { uint32_t value = static_cast<uint32_t>(bits.stash_addr_low); return value;}
    CONSTEXPR void set_stash_addr_low(uint32_t value) { assert(static_cast<uint32_t>(value) < 1048576u); bits.stash_addr_low = static_cast<uint32_t>(value); }
#endif
};


//
// stash_address_h_r - StashTranslation address upper 17 bits
//
struct stash_address_h_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t stash_addr_hi : 17; // StashTranslation address bits [48:32]
            uint32_t reserved0 : 15;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR stash_address_h_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_stash_addr_hi() const { uint32_t value = static_cast<uint32_t>(bits.stash_addr_hi); return value;}
    CONSTEXPR void set_stash_addr_hi(uint32_t value) { assert(static_cast<uint32_t>(value) < 131072u); bits.stash_addr_hi = static_cast<uint32_t>(value); }
#endif
};


//
// stripe_bank_config_r - Stripe bank configuration
//
struct stripe_bank_config_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t force_bank : 2; // Force reads/writes to go to a particular register bank
            uint32_t reserved0 : 30;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR stripe_bank_config_r(uint32_t init=0) : word(init) {}
    CONSTEXPR force_stripe_bank_t get_force_bank() const { force_stripe_bank_t value = static_cast<force_stripe_bank_t>(bits.force_bank); return value;}
    CONSTEXPR void set_force_bank(force_stripe_bank_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.force_bank = static_cast<uint32_t>(value); }
#endif
};


//
// stripe_bank_control_r - Stripe bank start control
//
struct stripe_bank_control_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t start : 1; // Start CE Execution of stripe
            uint32_t reserved0 : 31;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR stripe_bank_control_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_start() const { uint32_t value = static_cast<uint32_t>(bits.start); return value;}
    CONSTEXPR void set_start(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.start = static_cast<uint32_t>(value); }
#endif
};


//
// block_bank_config_r - Block bank configuration
//
struct block_bank_config_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t force_bank : 3; // Force reads/writes to go to a particular register bank
            uint32_t reserved0 : 29;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR block_bank_config_r(uint32_t init=0) : word(init) {}
    CONSTEXPR force_block_bank_t get_force_bank() const { force_block_bank_t value = static_cast<force_block_bank_t>(bits.force_bank); return value;}
    CONSTEXPR void set_force_bank(force_block_bank_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.force_bank = static_cast<uint32_t>(value); }
#endif
};


//
// block_bank_control_r - Block bank start control
//
struct block_bank_control_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t start : 1; // Start CE Execution of block
            uint32_t reserved0 : 31;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR block_bank_control_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_start() const { uint32_t value = static_cast<uint32_t>(bits.start); return value;}
    CONSTEXPR void set_start(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.start = static_cast<uint32_t>(value); }
#endif
};


//
// ple_mceif_config_r - PLE MCEIF interface setup
//
struct ple_mceif_config_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mceif_num_bufs : 4; // The number of MCEIF register buffers to be allocated
            uint32_t mceif_buf_size : 8; // Number of registers allocated for each MCEIF register buffer
            uint32_t mceif_buf_base : 8; // Base address for MCEIF register buffers
            uint32_t reserved0 : 12;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR ple_mceif_config_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mceif_num_bufs() const { uint32_t value = static_cast<uint32_t>(bits.mceif_num_bufs); return (value + 1);}
    CONSTEXPR void set_mceif_num_bufs(uint32_t value) { assert(static_cast<uint32_t>((value - 1)) < 16u); bits.mceif_num_bufs = static_cast<uint32_t>((value - 1)); }
    CONSTEXPR uint32_t get_mceif_buf_size() const { uint32_t value = static_cast<uint32_t>(bits.mceif_buf_size); return (value + 1);}
    CONSTEXPR void set_mceif_buf_size(uint32_t value) { assert(static_cast<uint32_t>((value - 1)) < 256u); bits.mceif_buf_size = static_cast<uint32_t>((value - 1)); }
    CONSTEXPR uint32_t get_mceif_buf_base() const { uint32_t value = static_cast<uint32_t>(bits.mceif_buf_base); return value;}
    CONSTEXPR void set_mceif_buf_base(uint32_t value) { assert(static_cast<uint32_t>(value) < 256u); bits.mceif_buf_base = static_cast<uint32_t>(value); }
#endif
};


//
// top_err_cause_r - Top level error cause
//
struct top_err_cause_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t engine_ram_correctable_err : 1; // Engine RAM correctable error
            uint32_t engine_ram_uncorrectable_err : 1; // Engine RAM uncorrectable error
            uint32_t top_tolerable_ram_err : 1; // DMA or reorder buffer RAM correctable error, ncu_mcu correctable/uncorrectable error
            uint32_t top_recoverable_ram_err : 1; // DMA or reorder buffer RAM uncorrectable error
            uint32_t mcu_lockup_err : 1; // MCU lockup error
            uint32_t mcu_instr_err : 1; // MCU instr error (interconnect response)
            uint32_t mcu_data_read_err : 1; // MCU data read error (interconnect response)
            uint32_t mcu_data_write_err : 1; // MCU data write error (interconnect error response)
            uint32_t dma_read_err : 1; // DMA read error (interconnect response)
            uint32_t dma_write_err : 1; // DMA write error (interconnect response)
            uint32_t stash_translation_err : 1; // Stash translation error (interconnect response)
            uint32_t reserved0 : 1;
            uint32_t dma_queue_programming_err : 1; // DMA queue programming error (incl: read, write)
            uint32_t pwrctlr_active_programming_err : 1; // PWRCTLR ACTIVE programming error
            uint32_t stash_trans_programming_err : 1; // Stash translation programming error (incorrect stream)
            uint32_t tsu_event_overflow_err : 1; // TSU EVENT overflow error
            uint32_t stripe_programming_err : 1; // Stripe programming error
            uint32_t stripe_write_while_busy_err : 1; // Stripe write while busy
            uint32_t block_programming_err : 1; // Block programming error
            uint32_t block_write_while_busy_err : 1; // Block write while busy
            uint32_t shadow_err : 1; // Shadow register access error
            uint32_t reserved1 : 10;
            uint32_t engine_func_err : 1; // Engine functional error
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR top_err_cause_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_engine_ram_correctable_err() const { uint32_t value = static_cast<uint32_t>(bits.engine_ram_correctable_err); return value;}
    CONSTEXPR void set_engine_ram_correctable_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.engine_ram_correctable_err = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_engine_ram_uncorrectable_err() const { uint32_t value = static_cast<uint32_t>(bits.engine_ram_uncorrectable_err); return value;}
    CONSTEXPR void set_engine_ram_uncorrectable_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.engine_ram_uncorrectable_err = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_top_tolerable_ram_err() const { uint32_t value = static_cast<uint32_t>(bits.top_tolerable_ram_err); return value;}
    CONSTEXPR void set_top_tolerable_ram_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.top_tolerable_ram_err = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_top_recoverable_ram_err() const { uint32_t value = static_cast<uint32_t>(bits.top_recoverable_ram_err); return value;}
    CONSTEXPR void set_top_recoverable_ram_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.top_recoverable_ram_err = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mcu_lockup_err() const { uint32_t value = static_cast<uint32_t>(bits.mcu_lockup_err); return value;}
    CONSTEXPR void set_mcu_lockup_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mcu_lockup_err = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mcu_instr_err() const { uint32_t value = static_cast<uint32_t>(bits.mcu_instr_err); return value;}
    CONSTEXPR void set_mcu_instr_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mcu_instr_err = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mcu_data_read_err() const { uint32_t value = static_cast<uint32_t>(bits.mcu_data_read_err); return value;}
    CONSTEXPR void set_mcu_data_read_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mcu_data_read_err = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mcu_data_write_err() const { uint32_t value = static_cast<uint32_t>(bits.mcu_data_write_err); return value;}
    CONSTEXPR void set_mcu_data_write_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mcu_data_write_err = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_dma_read_err() const { uint32_t value = static_cast<uint32_t>(bits.dma_read_err); return value;}
    CONSTEXPR void set_dma_read_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.dma_read_err = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_dma_write_err() const { uint32_t value = static_cast<uint32_t>(bits.dma_write_err); return value;}
    CONSTEXPR void set_dma_write_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.dma_write_err = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_stash_translation_err() const { uint32_t value = static_cast<uint32_t>(bits.stash_translation_err); return value;}
    CONSTEXPR void set_stash_translation_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.stash_translation_err = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_dma_queue_programming_err() const { uint32_t value = static_cast<uint32_t>(bits.dma_queue_programming_err); return value;}
    CONSTEXPR void set_dma_queue_programming_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.dma_queue_programming_err = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_pwrctlr_active_programming_err() const { uint32_t value = static_cast<uint32_t>(bits.pwrctlr_active_programming_err); return value;}
    CONSTEXPR void set_pwrctlr_active_programming_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.pwrctlr_active_programming_err = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_stash_trans_programming_err() const { uint32_t value = static_cast<uint32_t>(bits.stash_trans_programming_err); return value;}
    CONSTEXPR void set_stash_trans_programming_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.stash_trans_programming_err = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_tsu_event_overflow_err() const { uint32_t value = static_cast<uint32_t>(bits.tsu_event_overflow_err); return value;}
    CONSTEXPR void set_tsu_event_overflow_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.tsu_event_overflow_err = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_stripe_programming_err() const { uint32_t value = static_cast<uint32_t>(bits.stripe_programming_err); return value;}
    CONSTEXPR void set_stripe_programming_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.stripe_programming_err = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_stripe_write_while_busy_err() const { uint32_t value = static_cast<uint32_t>(bits.stripe_write_while_busy_err); return value;}
    CONSTEXPR void set_stripe_write_while_busy_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.stripe_write_while_busy_err = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_block_programming_err() const { uint32_t value = static_cast<uint32_t>(bits.block_programming_err); return value;}
    CONSTEXPR void set_block_programming_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.block_programming_err = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_block_write_while_busy_err() const { uint32_t value = static_cast<uint32_t>(bits.block_write_while_busy_err); return value;}
    CONSTEXPR void set_block_write_while_busy_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.block_write_while_busy_err = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_shadow_err() const { uint32_t value = static_cast<uint32_t>(bits.shadow_err); return value;}
    CONSTEXPR void set_shadow_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.shadow_err = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_engine_func_err() const { uint32_t value = static_cast<uint32_t>(bits.engine_func_err); return value;}
    CONSTEXPR void set_engine_func_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.engine_func_err = static_cast<uint32_t>(value); }
#endif
};


//
// top_err_address_r - Top level error address
//
struct top_err_address_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t address : 10; // Error address; granularity dependent on indicated RAM
            uint32_t reserved0 : 2;
            uint32_t bank : 3; // Error bank
            uint32_t reserved1 : 1;
            uint32_t ncu_mcu_icache_tag : 1; // NCU_MCU Ichache tag RAM error
            uint32_t ncu_mcu_icache_data : 1; // NCU_MCU Ichache data RAM error
            uint32_t ncu_mcu_dcache_tag : 1; // NCU_MCU Dchache tag RAM error
            uint32_t ncu_mcu_dcache_data : 1; // NCU_MCU Dchache data RAM error
            uint32_t reserved2 : 1;
            uint32_t dfc_rob : 1; // DFC reorder buffer error
            uint32_t dfc_compressor_sim : 1; // DFC Compressor SIM RAM error
            uint32_t dfc_compressor_rem : 1; // DFC Compressor REM RAM error
            uint32_t dfc_compressor_unary : 1; // DFC Compressor UNARY RAM error
            uint32_t dfc_decompressor : 1; // DFC Decompressor RAM error
            uint32_t reserved3 : 4;
            uint32_t err_multi : 1; // Multiple errors seen
            uint32_t err_uncorrected : 1; // Uncorrected error seen
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR top_err_address_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_address() const { uint32_t value = static_cast<uint32_t>(bits.address); return value;}
    CONSTEXPR void set_address(uint32_t value) { assert(static_cast<uint32_t>(value) < 1024u); bits.address = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_bank() const { uint32_t value = static_cast<uint32_t>(bits.bank); return value;}
    CONSTEXPR void set_bank(uint32_t value) { assert(static_cast<uint32_t>(value) < 8u); bits.bank = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ncu_mcu_icache_tag() const { uint32_t value = static_cast<uint32_t>(bits.ncu_mcu_icache_tag); return value;}
    CONSTEXPR void set_ncu_mcu_icache_tag(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ncu_mcu_icache_tag = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ncu_mcu_icache_data() const { uint32_t value = static_cast<uint32_t>(bits.ncu_mcu_icache_data); return value;}
    CONSTEXPR void set_ncu_mcu_icache_data(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ncu_mcu_icache_data = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ncu_mcu_dcache_tag() const { uint32_t value = static_cast<uint32_t>(bits.ncu_mcu_dcache_tag); return value;}
    CONSTEXPR void set_ncu_mcu_dcache_tag(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ncu_mcu_dcache_tag = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ncu_mcu_dcache_data() const { uint32_t value = static_cast<uint32_t>(bits.ncu_mcu_dcache_data); return value;}
    CONSTEXPR void set_ncu_mcu_dcache_data(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ncu_mcu_dcache_data = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_dfc_rob() const { uint32_t value = static_cast<uint32_t>(bits.dfc_rob); return value;}
    CONSTEXPR void set_dfc_rob(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.dfc_rob = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_dfc_compressor_sim() const { uint32_t value = static_cast<uint32_t>(bits.dfc_compressor_sim); return value;}
    CONSTEXPR void set_dfc_compressor_sim(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.dfc_compressor_sim = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_dfc_compressor_rem() const { uint32_t value = static_cast<uint32_t>(bits.dfc_compressor_rem); return value;}
    CONSTEXPR void set_dfc_compressor_rem(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.dfc_compressor_rem = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_dfc_compressor_unary() const { uint32_t value = static_cast<uint32_t>(bits.dfc_compressor_unary); return value;}
    CONSTEXPR void set_dfc_compressor_unary(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.dfc_compressor_unary = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_dfc_decompressor() const { uint32_t value = static_cast<uint32_t>(bits.dfc_decompressor); return value;}
    CONSTEXPR void set_dfc_decompressor(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.dfc_decompressor = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_err_multi() const { uint32_t value = static_cast<uint32_t>(bits.err_multi); return value;}
    CONSTEXPR void set_err_multi(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.err_multi = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_err_uncorrected() const { uint32_t value = static_cast<uint32_t>(bits.err_uncorrected); return value;}
    CONSTEXPR void set_err_uncorrected(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.err_uncorrected = static_cast<uint32_t>(value); }
#endif
};


//
// pmcr_r - Performance monitor control register
//
struct pmcr_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t cnt_en : 1; // Enable counters
            uint32_t event_cnt_rst : 1; // Event counter reset
            uint32_t cycle_cnt_rst : 1; // Cycle counter reset
            uint32_t clk_div : 1; // RES0
            uint32_t export_events : 1; // RES0
            uint32_t disable_cycle_cnt : 1; // RES0
            uint32_t long_cycle_cnt : 1; // RES0
            uint32_t reserved0 : 4;
            uint32_t num_counters : 5; // Number of event counters
            uint32_t read_stream_type : 4; // Read stream type
            uint32_t write_stream_type : 4; // Write stream type
            uint32_t stash_lat_en : 1; // Stash latency measurement enable
            uint32_t reserved1 : 7;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR pmcr_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_cnt_en() const { uint32_t value = static_cast<uint32_t>(bits.cnt_en); return value;}
    CONSTEXPR void set_cnt_en(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.cnt_en = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_event_cnt_rst() const { uint32_t value = static_cast<uint32_t>(bits.event_cnt_rst); return value;}
    CONSTEXPR void set_event_cnt_rst(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.event_cnt_rst = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_cycle_cnt_rst() const { uint32_t value = static_cast<uint32_t>(bits.cycle_cnt_rst); return value;}
    CONSTEXPR void set_cycle_cnt_rst(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.cycle_cnt_rst = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_clk_div() const { uint32_t value = static_cast<uint32_t>(bits.clk_div); return value;}
    CONSTEXPR void set_clk_div(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.clk_div = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_export_events() const { uint32_t value = static_cast<uint32_t>(bits.export_events); return value;}
    CONSTEXPR void set_export_events(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.export_events = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_disable_cycle_cnt() const { uint32_t value = static_cast<uint32_t>(bits.disable_cycle_cnt); return value;}
    CONSTEXPR void set_disable_cycle_cnt(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.disable_cycle_cnt = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_long_cycle_cnt() const { uint32_t value = static_cast<uint32_t>(bits.long_cycle_cnt); return value;}
    CONSTEXPR void set_long_cycle_cnt(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.long_cycle_cnt = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_num_counters() const { uint32_t value = static_cast<uint32_t>(bits.num_counters); return value;}
    CONSTEXPR void set_num_counters(uint32_t value) { assert(static_cast<uint32_t>(value) < 32u); bits.num_counters = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_read_stream_type() const { uint32_t value = static_cast<uint32_t>(bits.read_stream_type); return value;}
    CONSTEXPR void set_read_stream_type(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.read_stream_type = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_write_stream_type() const { uint32_t value = static_cast<uint32_t>(bits.write_stream_type); return value;}
    CONSTEXPR void set_write_stream_type(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.write_stream_type = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_stash_lat_en() const { uint32_t value = static_cast<uint32_t>(bits.stash_lat_en); return value;}
    CONSTEXPR void set_stash_lat_en(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.stash_lat_en = static_cast<uint32_t>(value); }
#endif
};


//
// pmcntenset_r - Count enable set register
//
struct pmcntenset_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t event_cnt_0 : 1; // Event counter enable bit for PMEVCNTR0
            uint32_t event_cnt_1 : 1; // Event counter enable bit for PMEVCNTR1
            uint32_t event_cnt_2 : 1; // Event counter enable bit for PMEVCNTR2
            uint32_t event_cnt_3 : 1; // Event counter enable bit for PMEVCNTR3
            uint32_t event_cnt_4 : 1; // Event counter enable bit for PMEVCNTR4
            uint32_t event_cnt_5 : 1; // Event counter enable bit for PMEVCNTR5
            uint32_t reserved0 : 25;
            uint32_t cycle_cnt : 1; // PMCCNTR enable bit
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR pmcntenset_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_event_cnt_0() const { uint32_t value = static_cast<uint32_t>(bits.event_cnt_0); return value;}
    CONSTEXPR void set_event_cnt_0(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.event_cnt_0 = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_event_cnt_1() const { uint32_t value = static_cast<uint32_t>(bits.event_cnt_1); return value;}
    CONSTEXPR void set_event_cnt_1(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.event_cnt_1 = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_event_cnt_2() const { uint32_t value = static_cast<uint32_t>(bits.event_cnt_2); return value;}
    CONSTEXPR void set_event_cnt_2(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.event_cnt_2 = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_event_cnt_3() const { uint32_t value = static_cast<uint32_t>(bits.event_cnt_3); return value;}
    CONSTEXPR void set_event_cnt_3(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.event_cnt_3 = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_event_cnt_4() const { uint32_t value = static_cast<uint32_t>(bits.event_cnt_4); return value;}
    CONSTEXPR void set_event_cnt_4(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.event_cnt_4 = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_event_cnt_5() const { uint32_t value = static_cast<uint32_t>(bits.event_cnt_5); return value;}
    CONSTEXPR void set_event_cnt_5(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.event_cnt_5 = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_cycle_cnt() const { uint32_t value = static_cast<uint32_t>(bits.cycle_cnt); return value;}
    CONSTEXPR void set_cycle_cnt(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.cycle_cnt = static_cast<uint32_t>(value); }
#endif
};


//
// pmcntenclr_r - Count enable clear register
//
struct pmcntenclr_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t event_cnt_0 : 1; // Event counter disable bit for PMEVCNTR0
            uint32_t event_cnt_1 : 1; // Event counter disable bit for PMEVCNTR1
            uint32_t event_cnt_2 : 1; // Event counter disable bit for PMEVCNTR2
            uint32_t event_cnt_3 : 1; // Event counter disable bit for PMEVCNTR3
            uint32_t event_cnt_4 : 1; // Event counter disable bit for PMEVCNTR4
            uint32_t event_cnt_5 : 1; // Event counter disable bit for PMEVCNTR5
            uint32_t reserved0 : 25;
            uint32_t cycle_cnt : 1; // PMCCNTR disable bit
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR pmcntenclr_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_event_cnt_0() const { uint32_t value = static_cast<uint32_t>(bits.event_cnt_0); return value;}
    CONSTEXPR void set_event_cnt_0(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.event_cnt_0 = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_event_cnt_1() const { uint32_t value = static_cast<uint32_t>(bits.event_cnt_1); return value;}
    CONSTEXPR void set_event_cnt_1(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.event_cnt_1 = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_event_cnt_2() const { uint32_t value = static_cast<uint32_t>(bits.event_cnt_2); return value;}
    CONSTEXPR void set_event_cnt_2(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.event_cnt_2 = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_event_cnt_3() const { uint32_t value = static_cast<uint32_t>(bits.event_cnt_3); return value;}
    CONSTEXPR void set_event_cnt_3(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.event_cnt_3 = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_event_cnt_4() const { uint32_t value = static_cast<uint32_t>(bits.event_cnt_4); return value;}
    CONSTEXPR void set_event_cnt_4(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.event_cnt_4 = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_event_cnt_5() const { uint32_t value = static_cast<uint32_t>(bits.event_cnt_5); return value;}
    CONSTEXPR void set_event_cnt_5(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.event_cnt_5 = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_cycle_cnt() const { uint32_t value = static_cast<uint32_t>(bits.cycle_cnt); return value;}
    CONSTEXPR void set_cycle_cnt(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.cycle_cnt = static_cast<uint32_t>(value); }
#endif
};


//
// pmovsset_r - Overflow flag status set register
//
struct pmovsset_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t event_cnt_0_ovf : 1; // Event counter overflow set bit for PMEVCNTR0
            uint32_t event_cnt_1_ovf : 1; // Event counter overflow set bit for PMEVCNTR1
            uint32_t event_cnt_2_ovf : 1; // Event counter overflow set bit for PMEVCNTR2
            uint32_t event_cnt_3_ovf : 1; // Event counter overflow set bit for PMEVCNTR3
            uint32_t event_cnt_4_ovf : 1; // Event counter overflow set bit for PMEVCNTR4
            uint32_t event_cnt_5_ovf : 1; // Event counter overflow set bit for PMEVCNTR5
            uint32_t reserved0 : 25;
            uint32_t cycle_cnt_ovf : 1; // PMCCNTR overflow set bit
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR pmovsset_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_event_cnt_0_ovf() const { uint32_t value = static_cast<uint32_t>(bits.event_cnt_0_ovf); return value;}
    CONSTEXPR void set_event_cnt_0_ovf(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.event_cnt_0_ovf = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_event_cnt_1_ovf() const { uint32_t value = static_cast<uint32_t>(bits.event_cnt_1_ovf); return value;}
    CONSTEXPR void set_event_cnt_1_ovf(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.event_cnt_1_ovf = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_event_cnt_2_ovf() const { uint32_t value = static_cast<uint32_t>(bits.event_cnt_2_ovf); return value;}
    CONSTEXPR void set_event_cnt_2_ovf(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.event_cnt_2_ovf = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_event_cnt_3_ovf() const { uint32_t value = static_cast<uint32_t>(bits.event_cnt_3_ovf); return value;}
    CONSTEXPR void set_event_cnt_3_ovf(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.event_cnt_3_ovf = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_event_cnt_4_ovf() const { uint32_t value = static_cast<uint32_t>(bits.event_cnt_4_ovf); return value;}
    CONSTEXPR void set_event_cnt_4_ovf(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.event_cnt_4_ovf = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_event_cnt_5_ovf() const { uint32_t value = static_cast<uint32_t>(bits.event_cnt_5_ovf); return value;}
    CONSTEXPR void set_event_cnt_5_ovf(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.event_cnt_5_ovf = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_cycle_cnt_ovf() const { uint32_t value = static_cast<uint32_t>(bits.cycle_cnt_ovf); return value;}
    CONSTEXPR void set_cycle_cnt_ovf(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.cycle_cnt_ovf = static_cast<uint32_t>(value); }
#endif
};


//
// pmovsclr_r - Overflow flag status clear register
//
struct pmovsclr_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t event_cnt_0_ovf : 1; // Event counter overflow clear bit for PMEVCNTR0
            uint32_t event_cnt_1_ovf : 1; // Event counter overflow clear bit for PMEVCNTR1
            uint32_t event_cnt_2_ovf : 1; // Event counter overflow clear bit for PMEVCNTR2
            uint32_t event_cnt_3_ovf : 1; // Event counter overflow clear bit for PMEVCNTR3
            uint32_t event_cnt_4_ovf : 1; // Event counter overflow clear bit for PMEVCNTR4
            uint32_t event_cnt_5_ovf : 1; // Event counter overflow clear bit for PMEVCNTR5
            uint32_t reserved0 : 25;
            uint32_t cycle_cnt_ovf : 1; // PMCCNTR overflow clear bit
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR pmovsclr_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_event_cnt_0_ovf() const { uint32_t value = static_cast<uint32_t>(bits.event_cnt_0_ovf); return value;}
    CONSTEXPR void set_event_cnt_0_ovf(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.event_cnt_0_ovf = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_event_cnt_1_ovf() const { uint32_t value = static_cast<uint32_t>(bits.event_cnt_1_ovf); return value;}
    CONSTEXPR void set_event_cnt_1_ovf(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.event_cnt_1_ovf = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_event_cnt_2_ovf() const { uint32_t value = static_cast<uint32_t>(bits.event_cnt_2_ovf); return value;}
    CONSTEXPR void set_event_cnt_2_ovf(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.event_cnt_2_ovf = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_event_cnt_3_ovf() const { uint32_t value = static_cast<uint32_t>(bits.event_cnt_3_ovf); return value;}
    CONSTEXPR void set_event_cnt_3_ovf(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.event_cnt_3_ovf = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_event_cnt_4_ovf() const { uint32_t value = static_cast<uint32_t>(bits.event_cnt_4_ovf); return value;}
    CONSTEXPR void set_event_cnt_4_ovf(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.event_cnt_4_ovf = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_event_cnt_5_ovf() const { uint32_t value = static_cast<uint32_t>(bits.event_cnt_5_ovf); return value;}
    CONSTEXPR void set_event_cnt_5_ovf(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.event_cnt_5_ovf = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_cycle_cnt_ovf() const { uint32_t value = static_cast<uint32_t>(bits.cycle_cnt_ovf); return value;}
    CONSTEXPR void set_cycle_cnt_ovf(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.cycle_cnt_ovf = static_cast<uint32_t>(value); }
#endif
};


//
// pmintenset_r - Interrupt enable set register
//
struct pmintenset_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t event_cnt_0_int : 1; // Event counter overflow interrupt request enable bit for PMEVCNTR0
            uint32_t event_cnt_1_int : 1; // Event counter overflow interrupt request enable bit for PMEVCNTR1
            uint32_t event_cnt_2_int : 1; // Event counter overflow interrupt request enable bit for PMEVCNTR2
            uint32_t event_cnt_3_int : 1; // Event counter overflow interrupt request enable bit for PMEVCNTR3
            uint32_t event_cnt_4_int : 1; // Event counter overflow interrupt request enable bit for PMEVCNTR4
            uint32_t event_cnt_5_int : 1; // Event counter overflow interrupt request enable bit for PMEVCNTR5
            uint32_t reserved0 : 25;
            uint32_t cycle_cnt_int : 1; // PMCCNTR overflow interrupt request enable bit
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR pmintenset_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_event_cnt_0_int() const { uint32_t value = static_cast<uint32_t>(bits.event_cnt_0_int); return value;}
    CONSTEXPR void set_event_cnt_0_int(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.event_cnt_0_int = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_event_cnt_1_int() const { uint32_t value = static_cast<uint32_t>(bits.event_cnt_1_int); return value;}
    CONSTEXPR void set_event_cnt_1_int(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.event_cnt_1_int = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_event_cnt_2_int() const { uint32_t value = static_cast<uint32_t>(bits.event_cnt_2_int); return value;}
    CONSTEXPR void set_event_cnt_2_int(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.event_cnt_2_int = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_event_cnt_3_int() const { uint32_t value = static_cast<uint32_t>(bits.event_cnt_3_int); return value;}
    CONSTEXPR void set_event_cnt_3_int(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.event_cnt_3_int = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_event_cnt_4_int() const { uint32_t value = static_cast<uint32_t>(bits.event_cnt_4_int); return value;}
    CONSTEXPR void set_event_cnt_4_int(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.event_cnt_4_int = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_event_cnt_5_int() const { uint32_t value = static_cast<uint32_t>(bits.event_cnt_5_int); return value;}
    CONSTEXPR void set_event_cnt_5_int(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.event_cnt_5_int = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_cycle_cnt_int() const { uint32_t value = static_cast<uint32_t>(bits.cycle_cnt_int); return value;}
    CONSTEXPR void set_cycle_cnt_int(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.cycle_cnt_int = static_cast<uint32_t>(value); }
#endif
};


//
// pmintenclr_r - Interrupt enable clear register
//
struct pmintenclr_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t event_cnt_0_int : 1; // Event counter overflow interrupt request disable bit for PMEVCNTR0
            uint32_t event_cnt_1_int : 1; // Event counter overflow interrupt request disable bit for PMEVCNTR1
            uint32_t event_cnt_2_int : 1; // Event counter overflow interrupt request disable bit for PMEVCNTR2
            uint32_t event_cnt_3_int : 1; // Event counter overflow interrupt request disable bit for PMEVCNTR3
            uint32_t event_cnt_4_int : 1; // Event counter overflow interrupt request disable bit for PMEVCNTR4
            uint32_t event_cnt_5_int : 1; // Event counter overflow interrupt request disable bit for PMEVCNTR5
            uint32_t reserved0 : 25;
            uint32_t cycle_cnt_int : 1; // PMCCNTR overflow interrupt request disable bit
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR pmintenclr_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_event_cnt_0_int() const { uint32_t value = static_cast<uint32_t>(bits.event_cnt_0_int); return value;}
    CONSTEXPR void set_event_cnt_0_int(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.event_cnt_0_int = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_event_cnt_1_int() const { uint32_t value = static_cast<uint32_t>(bits.event_cnt_1_int); return value;}
    CONSTEXPR void set_event_cnt_1_int(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.event_cnt_1_int = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_event_cnt_2_int() const { uint32_t value = static_cast<uint32_t>(bits.event_cnt_2_int); return value;}
    CONSTEXPR void set_event_cnt_2_int(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.event_cnt_2_int = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_event_cnt_3_int() const { uint32_t value = static_cast<uint32_t>(bits.event_cnt_3_int); return value;}
    CONSTEXPR void set_event_cnt_3_int(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.event_cnt_3_int = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_event_cnt_4_int() const { uint32_t value = static_cast<uint32_t>(bits.event_cnt_4_int); return value;}
    CONSTEXPR void set_event_cnt_4_int(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.event_cnt_4_int = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_event_cnt_5_int() const { uint32_t value = static_cast<uint32_t>(bits.event_cnt_5_int); return value;}
    CONSTEXPR void set_event_cnt_5_int(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.event_cnt_5_int = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_cycle_cnt_int() const { uint32_t value = static_cast<uint32_t>(bits.cycle_cnt_int); return value;}
    CONSTEXPR void set_cycle_cnt_int(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.cycle_cnt_int = static_cast<uint32_t>(value); }
#endif
};


//
// pmccntr_lo_r - Performance monitor cycle count low register
//
struct pmccntr_lo_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t cycle_cnt_lo : 32; // Cycle count low
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR pmccntr_lo_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_cycle_cnt_lo() const { uint32_t value = static_cast<uint32_t>(bits.cycle_cnt_lo); return value;}
    CONSTEXPR void set_cycle_cnt_lo(uint32_t value) { bits.cycle_cnt_lo = static_cast<uint32_t>(value); }
#endif
};


//
// pmccntr_hi_r - Performance monitor cycle count high register
//
struct pmccntr_hi_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t cycle_cnt_hi : 16; // Cycle count high
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR pmccntr_hi_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_cycle_cnt_hi() const { uint32_t value = static_cast<uint32_t>(bits.cycle_cnt_hi); return value;}
    CONSTEXPR void set_cycle_cnt_hi(uint32_t value) { assert(static_cast<uint32_t>(value) < 65536u); bits.cycle_cnt_hi = static_cast<uint32_t>(value); }
#endif
};


//
// pmevcntr0_r - Performance monitor event 0 count register
//
struct pmevcntr0_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t event_cnt : 16; // Event counter
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR pmevcntr0_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_event_cnt() const { uint32_t value = static_cast<uint32_t>(bits.event_cnt); return value;}
    CONSTEXPR void set_event_cnt(uint32_t value) { assert(static_cast<uint32_t>(value) < 65536u); bits.event_cnt = static_cast<uint32_t>(value); }
#endif
};


//
// pmevcntr1_r - Performance monitor event 1 count register
//
struct pmevcntr1_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t event_cnt : 16; // Event counter
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR pmevcntr1_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_event_cnt() const { uint32_t value = static_cast<uint32_t>(bits.event_cnt); return value;}
    CONSTEXPR void set_event_cnt(uint32_t value) { assert(static_cast<uint32_t>(value) < 65536u); bits.event_cnt = static_cast<uint32_t>(value); }
#endif
};


//
// pmevcntr2_r - Performance monitor event 2 count register
//
struct pmevcntr2_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t event_cnt : 16; // Event counter
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR pmevcntr2_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_event_cnt() const { uint32_t value = static_cast<uint32_t>(bits.event_cnt); return value;}
    CONSTEXPR void set_event_cnt(uint32_t value) { assert(static_cast<uint32_t>(value) < 65536u); bits.event_cnt = static_cast<uint32_t>(value); }
#endif
};


//
// pmevcntr3_r - Performance monitor event 3 count register
//
struct pmevcntr3_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t event_cnt : 16; // Event counter
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR pmevcntr3_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_event_cnt() const { uint32_t value = static_cast<uint32_t>(bits.event_cnt); return value;}
    CONSTEXPR void set_event_cnt(uint32_t value) { assert(static_cast<uint32_t>(value) < 65536u); bits.event_cnt = static_cast<uint32_t>(value); }
#endif
};


//
// pmevcntr4_r - Performance monitor event 4 count register
//
struct pmevcntr4_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t event_cnt : 16; // Event counter
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR pmevcntr4_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_event_cnt() const { uint32_t value = static_cast<uint32_t>(bits.event_cnt); return value;}
    CONSTEXPR void set_event_cnt(uint32_t value) { assert(static_cast<uint32_t>(value) < 65536u); bits.event_cnt = static_cast<uint32_t>(value); }
#endif
};


//
// pmevcntr5_r - Performance monitor event 5 count register
//
struct pmevcntr5_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t event_cnt : 16; // Event counter
            uint32_t reserved0 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR pmevcntr5_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_event_cnt() const { uint32_t value = static_cast<uint32_t>(bits.event_cnt); return value;}
    CONSTEXPR void set_event_cnt(uint32_t value) { assert(static_cast<uint32_t>(value) < 65536u); bits.event_cnt = static_cast<uint32_t>(value); }
#endif
};


//
// pmevtyper0_r - Performance monitor event type register 0
//
struct pmevtyper0_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t event_type : 10;
            uint32_t reserved0 : 22;
        } bits;
        struct
        {
            uint32_t top_event_type : 10; // Top level counter event type
            uint32_t reserved0 : 22;
        } bits_TOP;
        struct
        {
            uint32_t engine_event_type : 10; // Engine level counter event type
            uint32_t reserved0 : 22;
        } bits_ENGINE;
    };
#ifdef __cplusplus
    CONSTEXPR pmevtyper0_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_event_type() const { uint32_t value = static_cast<uint32_t>(bits.event_type); return value;}
    CONSTEXPR void set_event_type(uint32_t value) { assert(static_cast<uint32_t>(value) < 1024u); bits.event_type = static_cast<uint32_t>(value); }
    CONSTEXPR pm_top_event_type_t get_top_event_type() const { pm_top_event_type_t value = static_cast<pm_top_event_type_t>(bits_TOP.top_event_type); return value;}
    CONSTEXPR void set_top_event_type(pm_top_event_type_t value) { assert(static_cast<uint32_t>(value) < 1024u); bits_TOP.top_event_type = static_cast<uint32_t>(value); }
    CONSTEXPR pm_engine_event_type_t get_engine_event_type() const { pm_engine_event_type_t value = static_cast<pm_engine_event_type_t>(bits_ENGINE.engine_event_type); return value;}
    CONSTEXPR void set_engine_event_type(pm_engine_event_type_t value) { assert(static_cast<uint32_t>(value) < 1024u); bits_ENGINE.engine_event_type = static_cast<uint32_t>(value); }
#endif
};


//
// pmevtyper1_r - Performance monitor event type register 1
//
struct pmevtyper1_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t event_type : 10;
            uint32_t reserved0 : 22;
        } bits;
        struct
        {
            uint32_t top_event_type : 10; // Top level counter event type
            uint32_t reserved0 : 22;
        } bits_TOP;
        struct
        {
            uint32_t engine_event_type : 10; // Engine level counter event type
            uint32_t reserved0 : 22;
        } bits_ENGINE;
    };
#ifdef __cplusplus
    CONSTEXPR pmevtyper1_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_event_type() const { uint32_t value = static_cast<uint32_t>(bits.event_type); return value;}
    CONSTEXPR void set_event_type(uint32_t value) { assert(static_cast<uint32_t>(value) < 1024u); bits.event_type = static_cast<uint32_t>(value); }
    CONSTEXPR pm_top_event_type_t get_top_event_type() const { pm_top_event_type_t value = static_cast<pm_top_event_type_t>(bits_TOP.top_event_type); return value;}
    CONSTEXPR void set_top_event_type(pm_top_event_type_t value) { assert(static_cast<uint32_t>(value) < 1024u); bits_TOP.top_event_type = static_cast<uint32_t>(value); }
    CONSTEXPR pm_engine_event_type_t get_engine_event_type() const { pm_engine_event_type_t value = static_cast<pm_engine_event_type_t>(bits_ENGINE.engine_event_type); return value;}
    CONSTEXPR void set_engine_event_type(pm_engine_event_type_t value) { assert(static_cast<uint32_t>(value) < 1024u); bits_ENGINE.engine_event_type = static_cast<uint32_t>(value); }
#endif
};


//
// pmevtyper2_r - Performance monitor event type register 2
//
struct pmevtyper2_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t event_type : 10;
            uint32_t reserved0 : 22;
        } bits;
        struct
        {
            uint32_t top_event_type : 10; // Top level counter event type
            uint32_t reserved0 : 22;
        } bits_TOP;
        struct
        {
            uint32_t engine_event_type : 10; // Engine level counter event type
            uint32_t reserved0 : 22;
        } bits_ENGINE;
    };
#ifdef __cplusplus
    CONSTEXPR pmevtyper2_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_event_type() const { uint32_t value = static_cast<uint32_t>(bits.event_type); return value;}
    CONSTEXPR void set_event_type(uint32_t value) { assert(static_cast<uint32_t>(value) < 1024u); bits.event_type = static_cast<uint32_t>(value); }
    CONSTEXPR pm_top_event_type_t get_top_event_type() const { pm_top_event_type_t value = static_cast<pm_top_event_type_t>(bits_TOP.top_event_type); return value;}
    CONSTEXPR void set_top_event_type(pm_top_event_type_t value) { assert(static_cast<uint32_t>(value) < 1024u); bits_TOP.top_event_type = static_cast<uint32_t>(value); }
    CONSTEXPR pm_engine_event_type_t get_engine_event_type() const { pm_engine_event_type_t value = static_cast<pm_engine_event_type_t>(bits_ENGINE.engine_event_type); return value;}
    CONSTEXPR void set_engine_event_type(pm_engine_event_type_t value) { assert(static_cast<uint32_t>(value) < 1024u); bits_ENGINE.engine_event_type = static_cast<uint32_t>(value); }
#endif
};


//
// pmevtyper3_r - Performance monitor event type register 3
//
struct pmevtyper3_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t event_type : 10;
            uint32_t reserved0 : 22;
        } bits;
        struct
        {
            uint32_t top_event_type : 10; // Top level counter event type
            uint32_t reserved0 : 22;
        } bits_TOP;
        struct
        {
            uint32_t engine_event_type : 10; // Engine level counter event type
            uint32_t reserved0 : 22;
        } bits_ENGINE;
    };
#ifdef __cplusplus
    CONSTEXPR pmevtyper3_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_event_type() const { uint32_t value = static_cast<uint32_t>(bits.event_type); return value;}
    CONSTEXPR void set_event_type(uint32_t value) { assert(static_cast<uint32_t>(value) < 1024u); bits.event_type = static_cast<uint32_t>(value); }
    CONSTEXPR pm_top_event_type_t get_top_event_type() const { pm_top_event_type_t value = static_cast<pm_top_event_type_t>(bits_TOP.top_event_type); return value;}
    CONSTEXPR void set_top_event_type(pm_top_event_type_t value) { assert(static_cast<uint32_t>(value) < 1024u); bits_TOP.top_event_type = static_cast<uint32_t>(value); }
    CONSTEXPR pm_engine_event_type_t get_engine_event_type() const { pm_engine_event_type_t value = static_cast<pm_engine_event_type_t>(bits_ENGINE.engine_event_type); return value;}
    CONSTEXPR void set_engine_event_type(pm_engine_event_type_t value) { assert(static_cast<uint32_t>(value) < 1024u); bits_ENGINE.engine_event_type = static_cast<uint32_t>(value); }
#endif
};


//
// pmevtyper4_r - Performance monitor event type register 4
//
struct pmevtyper4_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t event_type : 10;
            uint32_t reserved0 : 22;
        } bits;
        struct
        {
            uint32_t top_event_type : 10; // Top level counter event type
            uint32_t reserved0 : 22;
        } bits_TOP;
        struct
        {
            uint32_t engine_event_type : 10; // Engine level counter event type
            uint32_t reserved0 : 22;
        } bits_ENGINE;
    };
#ifdef __cplusplus
    CONSTEXPR pmevtyper4_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_event_type() const { uint32_t value = static_cast<uint32_t>(bits.event_type); return value;}
    CONSTEXPR void set_event_type(uint32_t value) { assert(static_cast<uint32_t>(value) < 1024u); bits.event_type = static_cast<uint32_t>(value); }
    CONSTEXPR pm_top_event_type_t get_top_event_type() const { pm_top_event_type_t value = static_cast<pm_top_event_type_t>(bits_TOP.top_event_type); return value;}
    CONSTEXPR void set_top_event_type(pm_top_event_type_t value) { assert(static_cast<uint32_t>(value) < 1024u); bits_TOP.top_event_type = static_cast<uint32_t>(value); }
    CONSTEXPR pm_engine_event_type_t get_engine_event_type() const { pm_engine_event_type_t value = static_cast<pm_engine_event_type_t>(bits_ENGINE.engine_event_type); return value;}
    CONSTEXPR void set_engine_event_type(pm_engine_event_type_t value) { assert(static_cast<uint32_t>(value) < 1024u); bits_ENGINE.engine_event_type = static_cast<uint32_t>(value); }
#endif
};


//
// pmevtyper5_r - Performance monitor event type register 5
//
struct pmevtyper5_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t event_type : 10;
            uint32_t reserved0 : 22;
        } bits;
        struct
        {
            uint32_t top_event_type : 10; // Top level counter event type
            uint32_t reserved0 : 22;
        } bits_TOP;
        struct
        {
            uint32_t engine_event_type : 10; // Engine level counter event type
            uint32_t reserved0 : 22;
        } bits_ENGINE;
    };
#ifdef __cplusplus
    CONSTEXPR pmevtyper5_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_event_type() const { uint32_t value = static_cast<uint32_t>(bits.event_type); return value;}
    CONSTEXPR void set_event_type(uint32_t value) { assert(static_cast<uint32_t>(value) < 1024u); bits.event_type = static_cast<uint32_t>(value); }
    CONSTEXPR pm_top_event_type_t get_top_event_type() const { pm_top_event_type_t value = static_cast<pm_top_event_type_t>(bits_TOP.top_event_type); return value;}
    CONSTEXPR void set_top_event_type(pm_top_event_type_t value) { assert(static_cast<uint32_t>(value) < 1024u); bits_TOP.top_event_type = static_cast<uint32_t>(value); }
    CONSTEXPR pm_engine_event_type_t get_engine_event_type() const { pm_engine_event_type_t value = static_cast<pm_engine_event_type_t>(bits_ENGINE.engine_event_type); return value;}
    CONSTEXPR void set_engine_event_type(pm_engine_event_type_t value) { assert(static_cast<uint32_t>(value) < 1024u); bits_ENGINE.engine_event_type = static_cast<uint32_t>(value); }
#endif
};


//
// sec_ext_access_control_r - External Access Control
//
struct sec_ext_access_control_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t excctlr : 1; // Execution control pages access control
            uint32_t ramctlr : 1; // Memory mapped RAMs access control
            uint32_t dbgctlr : 1; // PMU and DBG pages access control
            uint32_t reserved0 : 5;
            uint32_t excctlr_ns_allowed : 1; // Execution control pages non-secure access allowed
            uint32_t ramctlr_ns_allowed : 1; // Memory mapped RAMs non-secure access allowed
            uint32_t dbgctlr_ns_allowed : 1; // PMU and DBG pages non-secure access allowed
            uint32_t reserved1 : 5;
            uint32_t reserved2 : 16;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_ext_access_control_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_excctlr() const { uint32_t value = static_cast<uint32_t>(bits.excctlr); return value;}
    CONSTEXPR void set_excctlr(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.excctlr = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ramctlr() const { uint32_t value = static_cast<uint32_t>(bits.ramctlr); return value;}
    CONSTEXPR void set_ramctlr(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ramctlr = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_dbgctlr() const { uint32_t value = static_cast<uint32_t>(bits.dbgctlr); return value;}
    CONSTEXPR void set_dbgctlr(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.dbgctlr = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_excctlr_ns_allowed() const { uint32_t value = static_cast<uint32_t>(bits.excctlr_ns_allowed); return value;}
    CONSTEXPR void set_excctlr_ns_allowed(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.excctlr_ns_allowed = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ramctlr_ns_allowed() const { uint32_t value = static_cast<uint32_t>(bits.ramctlr_ns_allowed); return value;}
    CONSTEXPR void set_ramctlr_ns_allowed(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ramctlr_ns_allowed = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_dbgctlr_ns_allowed() const { uint32_t value = static_cast<uint32_t>(bits.dbgctlr_ns_allowed); return value;}
    CONSTEXPR void set_dbgctlr_ns_allowed(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.dbgctlr_ns_allowed = static_cast<uint32_t>(value); }
#endif
};


//
// sec_delegation_r - Control Access Delegation
//
struct sec_delegation_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t secctlr : 1; // SECCTLR register delegation bit
            uint32_t secmcuctlr : 1; // SECMCUCTLR register delegation bit
            uint32_t sysctlr : 1; // SYSCTLR register delegation bit
            uint32_t pwrctlr : 1; // PWRCTLR register delegation bit
            uint32_t auxctlr : 1; // AUXCTLR register delegation bit
            uint32_t excctlr : 1; // EXCCTLR delegation bit
            uint32_t ramctlr : 1; // RAMCTLR delegation bit
            uint32_t dbgctlr : 1; // DBGCTLR delegation bit
            uint32_t err : 1; // Error register delegation bit
            uint32_t debug : 1; // Debug register delegation bit
            uint32_t job : 1; // Job register delegation bit
            uint32_t event : 1; // Event register delegation bit
            uint32_t interrupt : 1; // Interrupt register delegation bit
            uint32_t nmi : 1; // NMI register delegation bit
            uint32_t irq : 1; // IRQ_STATUS register delegation bit
            uint32_t intext : 1; // INT_STATUS and EXT_STATUS registers delegation bit (shared)
            uint32_t gp0 : 1; // GP0 register delegation bit
            uint32_t gp1 : 1; // GP1 register delegation bit
            uint32_t gp2 : 1; // GP2 register delegation bit
            uint32_t gp3 : 1; // GP3 register delegation bit
            uint32_t gp4 : 1; // GP4 register delegation bit
            uint32_t gp5 : 1; // GP5 register delegation bit
            uint32_t gp6 : 1; // GP6 register delegation bit
            uint32_t gp7 : 1; // GP7 register delegation bit
            uint32_t dfcot : 1; // DFC outstanding transaction registers delegation bit
            uint32_t reserved0 : 7;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_delegation_r(uint32_t init=0) : word(init) {}
    CONSTEXPR delegation_t get_secctlr() const { delegation_t value = static_cast<delegation_t>(bits.secctlr); return value;}
    CONSTEXPR void set_secctlr(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.secctlr = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_secmcuctlr() const { delegation_t value = static_cast<delegation_t>(bits.secmcuctlr); return value;}
    CONSTEXPR void set_secmcuctlr(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.secmcuctlr = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_sysctlr() const { delegation_t value = static_cast<delegation_t>(bits.sysctlr); return value;}
    CONSTEXPR void set_sysctlr(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.sysctlr = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_pwrctlr() const { delegation_t value = static_cast<delegation_t>(bits.pwrctlr); return value;}
    CONSTEXPR void set_pwrctlr(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.pwrctlr = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_auxctlr() const { delegation_t value = static_cast<delegation_t>(bits.auxctlr); return value;}
    CONSTEXPR void set_auxctlr(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.auxctlr = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_excctlr() const { delegation_t value = static_cast<delegation_t>(bits.excctlr); return value;}
    CONSTEXPR void set_excctlr(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.excctlr = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_ramctlr() const { delegation_t value = static_cast<delegation_t>(bits.ramctlr); return value;}
    CONSTEXPR void set_ramctlr(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ramctlr = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_dbgctlr() const { delegation_t value = static_cast<delegation_t>(bits.dbgctlr); return value;}
    CONSTEXPR void set_dbgctlr(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.dbgctlr = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_err() const { delegation_t value = static_cast<delegation_t>(bits.err); return value;}
    CONSTEXPR void set_err(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.err = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_debug() const { delegation_t value = static_cast<delegation_t>(bits.debug); return value;}
    CONSTEXPR void set_debug(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.debug = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_job() const { delegation_t value = static_cast<delegation_t>(bits.job); return value;}
    CONSTEXPR void set_job(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.job = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_event() const { delegation_t value = static_cast<delegation_t>(bits.event); return value;}
    CONSTEXPR void set_event(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.event = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_interrupt() const { delegation_t value = static_cast<delegation_t>(bits.interrupt); return value;}
    CONSTEXPR void set_interrupt(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.interrupt = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_nmi() const { delegation_t value = static_cast<delegation_t>(bits.nmi); return value;}
    CONSTEXPR void set_nmi(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.nmi = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_irq() const { delegation_t value = static_cast<delegation_t>(bits.irq); return value;}
    CONSTEXPR void set_irq(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.irq = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_intext() const { delegation_t value = static_cast<delegation_t>(bits.intext); return value;}
    CONSTEXPR void set_intext(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.intext = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_gp0() const { delegation_t value = static_cast<delegation_t>(bits.gp0); return value;}
    CONSTEXPR void set_gp0(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.gp0 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_gp1() const { delegation_t value = static_cast<delegation_t>(bits.gp1); return value;}
    CONSTEXPR void set_gp1(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.gp1 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_gp2() const { delegation_t value = static_cast<delegation_t>(bits.gp2); return value;}
    CONSTEXPR void set_gp2(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.gp2 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_gp3() const { delegation_t value = static_cast<delegation_t>(bits.gp3); return value;}
    CONSTEXPR void set_gp3(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.gp3 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_gp4() const { delegation_t value = static_cast<delegation_t>(bits.gp4); return value;}
    CONSTEXPR void set_gp4(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.gp4 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_gp5() const { delegation_t value = static_cast<delegation_t>(bits.gp5); return value;}
    CONSTEXPR void set_gp5(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.gp5 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_gp6() const { delegation_t value = static_cast<delegation_t>(bits.gp6); return value;}
    CONSTEXPR void set_gp6(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.gp6 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_gp7() const { delegation_t value = static_cast<delegation_t>(bits.gp7); return value;}
    CONSTEXPR void set_gp7(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.gp7 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_dfcot() const { delegation_t value = static_cast<delegation_t>(bits.dfcot); return value;}
    CONSTEXPR void set_dfcot(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.dfcot = static_cast<uint32_t>(value); }
#endif
};


//
// sec_secctlr_r - NPU security controls
//
struct sec_secctlr_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t ns_allowed : 1; // Allow Non-secure transactions
            uint32_t npu_ns_mode : 1; // NPU Non-secure mode
            uint32_t reserved0 : 6;
            uint32_t ext_ns_evnt_to_s_evnt : 1; // NCU MCU S x NS Event
            uint32_t ext_ns_irq_to_s_irq : 1; // NCU MCU S x NS Interrupt
            uint32_t ext_s_evnt_to_ns_evnt : 1; // NCU MCU NS x S Event
            uint32_t ext_s_evnt_to_ns_irq : 1; // NCU MCU NS x S Event interrupt upgrade
            uint32_t reserved1 : 20;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_secctlr_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_ns_allowed() const { uint32_t value = static_cast<uint32_t>(bits.ns_allowed); return value;}
    CONSTEXPR void set_ns_allowed(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ns_allowed = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_npu_ns_mode() const { uint32_t value = static_cast<uint32_t>(bits.npu_ns_mode); return value;}
    CONSTEXPR void set_npu_ns_mode(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.npu_ns_mode = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ext_ns_evnt_to_s_evnt() const { uint32_t value = static_cast<uint32_t>(bits.ext_ns_evnt_to_s_evnt); return value;}
    CONSTEXPR void set_ext_ns_evnt_to_s_evnt(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ext_ns_evnt_to_s_evnt = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ext_ns_irq_to_s_irq() const { uint32_t value = static_cast<uint32_t>(bits.ext_ns_irq_to_s_irq); return value;}
    CONSTEXPR void set_ext_ns_irq_to_s_irq(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ext_ns_irq_to_s_irq = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ext_s_evnt_to_ns_evnt() const { uint32_t value = static_cast<uint32_t>(bits.ext_s_evnt_to_ns_evnt); return value;}
    CONSTEXPR void set_ext_s_evnt_to_ns_evnt(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ext_s_evnt_to_ns_evnt = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ext_s_evnt_to_ns_irq() const { uint32_t value = static_cast<uint32_t>(bits.ext_s_evnt_to_ns_irq); return value;}
    CONSTEXPR void set_ext_s_evnt_to_ns_irq(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ext_s_evnt_to_ns_irq = static_cast<uint32_t>(value); }
#endif
};


//
// sec_secmcuctlr_r - NCU MCU security state control
//
struct sec_secmcuctlr_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mcu_state : 1; // NCU MCU security state
            uint32_t reserved0 : 31;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_secmcuctlr_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mcu_state() const { uint32_t value = static_cast<uint32_t>(bits.mcu_state); return value;}
    CONSTEXPR void set_mcu_state(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mcu_state = static_cast<uint32_t>(value); }
#endif
};


//
// sec_sysctlr0_r - System control 0 - MCU Control and Status
//
struct sec_sysctlr0_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t cpuwait : 1; // MCU CPUWAIT input
            uint32_t lockup : 1; // MCU LOCKUP output
            uint32_t halted : 1; // MCU HALTED output
            uint32_t rstreq : 1; // MCU SYSRESETREQ output
            uint32_t sleeping : 1; // MCU SLEEPING and TRCENA output
            uint32_t reserved0 : 2;
            uint32_t initvtor : 22; // MCU Vector Table address
            uint32_t soft_rstreq : 2; // Soft reset request
            uint32_t hard_rstreq : 1; // Hard reset request
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_sysctlr0_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_cpuwait() const { uint32_t value = static_cast<uint32_t>(bits.cpuwait); return value;}
    CONSTEXPR void set_cpuwait(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.cpuwait = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_lockup() const { uint32_t value = static_cast<uint32_t>(bits.lockup); return value;}
    CONSTEXPR void set_lockup(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.lockup = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_halted() const { uint32_t value = static_cast<uint32_t>(bits.halted); return value;}
    CONSTEXPR void set_halted(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.halted = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_rstreq() const { uint32_t value = static_cast<uint32_t>(bits.rstreq); return value;}
    CONSTEXPR void set_rstreq(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.rstreq = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_sleeping() const { uint32_t value = static_cast<uint32_t>(bits.sleeping); return value;}
    CONSTEXPR void set_sleeping(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.sleeping = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_initvtor() const { uint32_t value = static_cast<uint32_t>(bits.initvtor); return value;}
    CONSTEXPR void set_initvtor(uint32_t value) { assert(static_cast<uint32_t>(value) < 4194304u); bits.initvtor = static_cast<uint32_t>(value); }
    CONSTEXPR soft_reset_t get_soft_rstreq() const { soft_reset_t value = static_cast<soft_reset_t>(bits.soft_rstreq); return value;}
    CONSTEXPR void set_soft_rstreq(soft_reset_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.soft_rstreq = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_hard_rstreq() const { uint32_t value = static_cast<uint32_t>(bits.hard_rstreq); return value;}
    CONSTEXPR void set_hard_rstreq(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.hard_rstreq = static_cast<uint32_t>(value); }
#endif
};


//
// sec_sysctlr1_r - System control 1 - Event Control
//
struct sec_sysctlr1_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t reserved0 : 4;
            uint32_t mcu_setevnt : 1; // MCU SET event
            uint32_t mcu_setirq : 1; // MCU SET interrupt
            uint32_t mcu_gpevnt : 1; // MCU GP event
            uint32_t reserved1 : 1;
            uint32_t tsu_evnt : 1; // TSU event
            uint32_t tsu_irq : 1; // TSU interrupt
            uint32_t tsu_dbg : 1; // TSU debug request
            uint32_t reserved2 : 5;
            uint32_t txev_ple : 1; // MCU TXEV sent to PLE
            uint32_t reserved3 : 1;
            uint32_t txev_dbg : 1; // MCU TXEV sent to Host
            uint32_t rxev_degroup : 1; // Degroup PLE TXEV sent to MCU
            uint32_t rxev_evnt : 1; // PLE TXEV sent to MCU
            uint32_t rxev_irq : 1; // PLE TXEV triggers MCU interrupt
            uint32_t reserved4 : 2;
            uint32_t pmu_evnt : 1; // PMU counter overflow event
            uint32_t pmu_irq : 1; // PMU counter overflow interrupt
            uint32_t pmu_dbg : 1; // PMU counter overflow debug request
            uint32_t pmu_eng : 1; // PMU engine counter overflow request
            uint32_t err_tolr_evnt : 1; // Tolerable error triggers MCU event
            uint32_t err_tolr_irq : 1; // Tolerable error triggers MCU interrupt
            uint32_t err_func_irq : 1; // Functional error triggers MCU interrupt
            uint32_t err_recv_irq : 1; // Recoverable error triggers MCU interrupt
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_sysctlr1_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mcu_setevnt() const { uint32_t value = static_cast<uint32_t>(bits.mcu_setevnt); return value;}
    CONSTEXPR void set_mcu_setevnt(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mcu_setevnt = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mcu_setirq() const { uint32_t value = static_cast<uint32_t>(bits.mcu_setirq); return value;}
    CONSTEXPR void set_mcu_setirq(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mcu_setirq = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mcu_gpevnt() const { uint32_t value = static_cast<uint32_t>(bits.mcu_gpevnt); return value;}
    CONSTEXPR void set_mcu_gpevnt(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mcu_gpevnt = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_tsu_evnt() const { uint32_t value = static_cast<uint32_t>(bits.tsu_evnt); return value;}
    CONSTEXPR void set_tsu_evnt(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.tsu_evnt = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_tsu_irq() const { uint32_t value = static_cast<uint32_t>(bits.tsu_irq); return value;}
    CONSTEXPR void set_tsu_irq(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.tsu_irq = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_tsu_dbg() const { uint32_t value = static_cast<uint32_t>(bits.tsu_dbg); return value;}
    CONSTEXPR void set_tsu_dbg(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.tsu_dbg = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_txev_ple() const { uint32_t value = static_cast<uint32_t>(bits.txev_ple); return value;}
    CONSTEXPR void set_txev_ple(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.txev_ple = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_txev_dbg() const { uint32_t value = static_cast<uint32_t>(bits.txev_dbg); return value;}
    CONSTEXPR void set_txev_dbg(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.txev_dbg = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_rxev_degroup() const { uint32_t value = static_cast<uint32_t>(bits.rxev_degroup); return value;}
    CONSTEXPR void set_rxev_degroup(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.rxev_degroup = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_rxev_evnt() const { uint32_t value = static_cast<uint32_t>(bits.rxev_evnt); return value;}
    CONSTEXPR void set_rxev_evnt(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.rxev_evnt = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_rxev_irq() const { uint32_t value = static_cast<uint32_t>(bits.rxev_irq); return value;}
    CONSTEXPR void set_rxev_irq(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.rxev_irq = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_pmu_evnt() const { uint32_t value = static_cast<uint32_t>(bits.pmu_evnt); return value;}
    CONSTEXPR void set_pmu_evnt(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.pmu_evnt = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_pmu_irq() const { uint32_t value = static_cast<uint32_t>(bits.pmu_irq); return value;}
    CONSTEXPR void set_pmu_irq(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.pmu_irq = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_pmu_dbg() const { uint32_t value = static_cast<uint32_t>(bits.pmu_dbg); return value;}
    CONSTEXPR void set_pmu_dbg(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.pmu_dbg = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_pmu_eng() const { uint32_t value = static_cast<uint32_t>(bits.pmu_eng); return value;}
    CONSTEXPR void set_pmu_eng(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.pmu_eng = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_err_tolr_evnt() const { uint32_t value = static_cast<uint32_t>(bits.err_tolr_evnt); return value;}
    CONSTEXPR void set_err_tolr_evnt(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.err_tolr_evnt = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_err_tolr_irq() const { uint32_t value = static_cast<uint32_t>(bits.err_tolr_irq); return value;}
    CONSTEXPR void set_err_tolr_irq(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.err_tolr_irq = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_err_func_irq() const { uint32_t value = static_cast<uint32_t>(bits.err_func_irq); return value;}
    CONSTEXPR void set_err_func_irq(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.err_func_irq = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_err_recv_irq() const { uint32_t value = static_cast<uint32_t>(bits.err_recv_irq); return value;}
    CONSTEXPR void set_err_recv_irq(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.err_recv_irq = static_cast<uint32_t>(value); }
#endif
};


//
// sec_pwrctlr_r - Power Control
//
struct sec_pwrctlr_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t active : 1; // NPU activity state
            uint32_t qreqn : 1; // Value of CLK Q-channel QREQn
            uint32_t reserved0 : 30;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_pwrctlr_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_active() const { uint32_t value = static_cast<uint32_t>(bits.active); return value;}
    CONSTEXPR void set_active(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.active = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_qreqn() const { uint32_t value = static_cast<uint32_t>(bits.qreqn); return value;}
    CONSTEXPR void set_qreqn(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.qreqn = static_cast<uint32_t>(value); }
#endif
};


//
// sec_auxctlr_r - Auxiliary Control
//
struct sec_auxctlr_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t dis_clkgate : 1; // Disable clock gating
            uint32_t dis_qdeny : 1; // Q-channel FSM deny control
            uint32_t dis_edgeirq : 1; // Change sensitivity of DEBUG and JOB IRQs
            uint32_t dis_mcu_unique_rid : 1; // Disable MCU logic enforcing unique RIDs
            uint32_t dis_stshtrnsltn : 1; // Disable StashTranslation transactions
            uint32_t reserved0 : 2;
            uint32_t increase_outstanding_writes : 1; // Increase outstanding master write transactions
            uint32_t dbgen : 1; // Invasive debug enable
            uint32_t niden : 1; // Non-invasive debug enable
            uint32_t reserved1 : 2;
            uint32_t dis_ext_err_unrecoverable : 1; // Disable ext err irq for unrecoverable errors
            uint32_t dis_ext_err_recoverable : 1; // Disable ext err irq for recoverable errors
            uint32_t dis_ext_err_functional : 1; // Disable ext err irq for functional errors
            uint32_t dis_ext_err_tolerable : 1; // Disable ext debug irq for tolerable errors
            uint32_t dis_non_broadcast_global_err : 1; // Disable non broadcast global errors
            uint32_t en_ple_block_done : 1; // Enable detection in TSU of PLE_BLOCK_DONE events indicated by engines.
            uint32_t mac_ramp_cycles : 2; // Number of ramp cycles when the MAC units transition between idle and active states.
            uint32_t snoop_dis : 1; // Disable external snooping of internal signals
            uint32_t wd_ramp_dis : 1; // Disable weight decoder ramping
            uint32_t reserved2 : 2;
            uint32_t stash_ahead : 4; // Number of 4kB pages to automatically read ahead for each of read and write before the corresponding DMA accesses
            uint32_t stash_issue : 4; // Issuing capacity for StashTranslation transactions
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_auxctlr_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_dis_clkgate() const { uint32_t value = static_cast<uint32_t>(bits.dis_clkgate); return value;}
    CONSTEXPR void set_dis_clkgate(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.dis_clkgate = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_dis_qdeny() const { uint32_t value = static_cast<uint32_t>(bits.dis_qdeny); return value;}
    CONSTEXPR void set_dis_qdeny(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.dis_qdeny = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_dis_edgeirq() const { uint32_t value = static_cast<uint32_t>(bits.dis_edgeirq); return value;}
    CONSTEXPR void set_dis_edgeirq(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.dis_edgeirq = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_dis_mcu_unique_rid() const { uint32_t value = static_cast<uint32_t>(bits.dis_mcu_unique_rid); return value;}
    CONSTEXPR void set_dis_mcu_unique_rid(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.dis_mcu_unique_rid = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_dis_stshtrnsltn() const { uint32_t value = static_cast<uint32_t>(bits.dis_stshtrnsltn); return value;}
    CONSTEXPR void set_dis_stshtrnsltn(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.dis_stshtrnsltn = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_increase_outstanding_writes() const { uint32_t value = static_cast<uint32_t>(bits.increase_outstanding_writes); return value;}
    CONSTEXPR void set_increase_outstanding_writes(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.increase_outstanding_writes = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_dbgen() const { uint32_t value = static_cast<uint32_t>(bits.dbgen); return value;}
    CONSTEXPR void set_dbgen(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.dbgen = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_niden() const { uint32_t value = static_cast<uint32_t>(bits.niden); return value;}
    CONSTEXPR void set_niden(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.niden = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_dis_ext_err_unrecoverable() const { uint32_t value = static_cast<uint32_t>(bits.dis_ext_err_unrecoverable); return value;}
    CONSTEXPR void set_dis_ext_err_unrecoverable(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.dis_ext_err_unrecoverable = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_dis_ext_err_recoverable() const { uint32_t value = static_cast<uint32_t>(bits.dis_ext_err_recoverable); return value;}
    CONSTEXPR void set_dis_ext_err_recoverable(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.dis_ext_err_recoverable = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_dis_ext_err_functional() const { uint32_t value = static_cast<uint32_t>(bits.dis_ext_err_functional); return value;}
    CONSTEXPR void set_dis_ext_err_functional(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.dis_ext_err_functional = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_dis_ext_err_tolerable() const { uint32_t value = static_cast<uint32_t>(bits.dis_ext_err_tolerable); return value;}
    CONSTEXPR void set_dis_ext_err_tolerable(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.dis_ext_err_tolerable = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_dis_non_broadcast_global_err() const { uint32_t value = static_cast<uint32_t>(bits.dis_non_broadcast_global_err); return value;}
    CONSTEXPR void set_dis_non_broadcast_global_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.dis_non_broadcast_global_err = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_en_ple_block_done() const { uint32_t value = static_cast<uint32_t>(bits.en_ple_block_done); return value;}
    CONSTEXPR void set_en_ple_block_done(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.en_ple_block_done = static_cast<uint32_t>(value); }
    CONSTEXPR mac_ramp_t get_mac_ramp_cycles() const { mac_ramp_t value = static_cast<mac_ramp_t>(bits.mac_ramp_cycles); return value;}
    CONSTEXPR void set_mac_ramp_cycles(mac_ramp_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.mac_ramp_cycles = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_snoop_dis() const { uint32_t value = static_cast<uint32_t>(bits.snoop_dis); return value;}
    CONSTEXPR void set_snoop_dis(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.snoop_dis = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_wd_ramp_dis() const { uint32_t value = static_cast<uint32_t>(bits.wd_ramp_dis); return value;}
    CONSTEXPR void set_wd_ramp_dis(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.wd_ramp_dis = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_stash_ahead() const { uint32_t value = static_cast<uint32_t>(bits.stash_ahead); return value;}
    CONSTEXPR void set_stash_ahead(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.stash_ahead = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_stash_issue() const { uint32_t value = static_cast<uint32_t>(bits.stash_issue); return value;}
    CONSTEXPR void set_stash_issue(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.stash_issue = static_cast<uint32_t>(value); }
#endif
};


//
// sec_setirq_ext_r - Set external interrupts (to host)
//
struct sec_setirq_ext_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t err : 1; // Host error interrupt set request (level-sensitive to host)
            uint32_t debug : 1; // Host debug interrupt set request
            uint32_t job : 1; // Host job interrupt set request
            uint32_t reserved0 : 29;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_setirq_ext_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_err() const { uint32_t value = static_cast<uint32_t>(bits.err); return value;}
    CONSTEXPR void set_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.err = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_debug() const { uint32_t value = static_cast<uint32_t>(bits.debug); return value;}
    CONSTEXPR void set_debug(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.debug = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_job() const { uint32_t value = static_cast<uint32_t>(bits.job); return value;}
    CONSTEXPR void set_job(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.job = static_cast<uint32_t>(value); }
#endif
};


//
// sec_clrirq_ext_r - Clear external interrupts (to host)
//
struct sec_clrirq_ext_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t err : 1; // Host error interrupt clear request
            uint32_t debug : 1; // Host debug interrupt clear request
            uint32_t job : 1; // Host job interrupt clear request
            uint32_t reserved0 : 29;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_clrirq_ext_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_err() const { uint32_t value = static_cast<uint32_t>(bits.err); return value;}
    CONSTEXPR void set_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.err = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_debug() const { uint32_t value = static_cast<uint32_t>(bits.debug); return value;}
    CONSTEXPR void set_debug(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.debug = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_job() const { uint32_t value = static_cast<uint32_t>(bits.job); return value;}
    CONSTEXPR void set_job(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.job = static_cast<uint32_t>(value); }
#endif
};


//
// sec_setirq_int_r - Raise internal interrupts and events
//
struct sec_setirq_int_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t reserved0 : 4;
            uint32_t event : 1; // MCU event (edge-sensitive to MCU'S RXEV pin)
            uint32_t interrupt : 1; // MCU interrupt (edge-sensitive to MCU's IRQ pin)
            uint32_t reserved1 : 1;
            uint32_t nmi : 1; // MCU interrupt (edge-sensitive to MCU's NMI pin)
            uint32_t reserved2 : 24;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_setirq_int_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_event() const { uint32_t value = static_cast<uint32_t>(bits.event); return value;}
    CONSTEXPR void set_event(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.event = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_interrupt() const { uint32_t value = static_cast<uint32_t>(bits.interrupt); return value;}
    CONSTEXPR void set_interrupt(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.interrupt = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_nmi() const { uint32_t value = static_cast<uint32_t>(bits.nmi); return value;}
    CONSTEXPR void set_nmi(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.nmi = static_cast<uint32_t>(value); }
#endif
};


//
// sec_dfc_slv_ord_r - DFC Slave Outstanding Reads
//
struct sec_dfc_slv_ord_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t out_reads : 8; // Outstanding read transaction count
            uint32_t reserved0 : 24;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_dfc_slv_ord_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_out_reads() const { uint32_t value = static_cast<uint32_t>(bits.out_reads); return value;}
    CONSTEXPR void set_out_reads(uint32_t value) { assert(static_cast<uint32_t>(value) < 256u); bits.out_reads = static_cast<uint32_t>(value); }
#endif
};


//
// sec_dfc_slv_owr_r - DFC Slave Outstanding Writes
//
struct sec_dfc_slv_owr_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t out_writes : 8; // Outstanding write transaction count
            uint32_t reserved0 : 24;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_dfc_slv_owr_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_out_writes() const { uint32_t value = static_cast<uint32_t>(bits.out_writes); return value;}
    CONSTEXPR void set_out_writes(uint32_t value) { assert(static_cast<uint32_t>(value) < 256u); bits.out_writes = static_cast<uint32_t>(value); }
#endif
};


//
// sec_dfc_mst_ord_r - DFC Master Outstanding Reads
//
struct sec_dfc_mst_ord_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t out_reads : 8; // Outstanding read transaction count
            uint32_t reserved0 : 24;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_dfc_mst_ord_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_out_reads() const { uint32_t value = static_cast<uint32_t>(bits.out_reads); return value;}
    CONSTEXPR void set_out_reads(uint32_t value) { assert(static_cast<uint32_t>(value) < 256u); bits.out_reads = static_cast<uint32_t>(value); }
#endif
};


//
// sec_dfc_mst_owr_r - DFC Master Outstanding Writes
//
struct sec_dfc_mst_owr_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t out_writes : 8; // Outstanding write transaction count
            uint32_t reserved0 : 24;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_dfc_mst_owr_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_out_writes() const { uint32_t value = static_cast<uint32_t>(bits.out_writes); return value;}
    CONSTEXPR void set_out_writes(uint32_t value) { assert(static_cast<uint32_t>(value) < 256u); bits.out_writes = static_cast<uint32_t>(value); }
#endif
};


//
// sec_irq_status_r - Status register used by the Host system
//
struct sec_irq_status_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t setirq_err : 1; // ERR interrupt caused by SETIRQ
            uint32_t setirq_dbg : 1; // DEBUG interrupt caused by SETIRQ
            uint32_t setirq_job : 1; // JOB interrupt caused by SETIRQ
            uint32_t reserved0 : 7;
            uint32_t tsu_dbg : 1; // DEBUG interrupt caused by TSU
            uint32_t reserved1 : 15;
            uint32_t pmu_dbg : 1; // DEBUG interrupt caused by top-level PMU
            uint32_t pmu_eng : 1; // DEBUG interrupt caused by engine-level PMU
            uint32_t tol_err : 1; // Tolerable error
            uint32_t func_err : 1; // Functional error
            uint32_t rec_err : 1; // Recoverable error
            uint32_t unrec_err : 1; // Unrecoverable error
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_irq_status_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_setirq_err() const { uint32_t value = static_cast<uint32_t>(bits.setirq_err); return value;}
    CONSTEXPR void set_setirq_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.setirq_err = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_setirq_dbg() const { uint32_t value = static_cast<uint32_t>(bits.setirq_dbg); return value;}
    CONSTEXPR void set_setirq_dbg(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.setirq_dbg = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_setirq_job() const { uint32_t value = static_cast<uint32_t>(bits.setirq_job); return value;}
    CONSTEXPR void set_setirq_job(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.setirq_job = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_tsu_dbg() const { uint32_t value = static_cast<uint32_t>(bits.tsu_dbg); return value;}
    CONSTEXPR void set_tsu_dbg(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.tsu_dbg = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_pmu_dbg() const { uint32_t value = static_cast<uint32_t>(bits.pmu_dbg); return value;}
    CONSTEXPR void set_pmu_dbg(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.pmu_dbg = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_pmu_eng() const { uint32_t value = static_cast<uint32_t>(bits.pmu_eng); return value;}
    CONSTEXPR void set_pmu_eng(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.pmu_eng = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_tol_err() const { uint32_t value = static_cast<uint32_t>(bits.tol_err); return value;}
    CONSTEXPR void set_tol_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.tol_err = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_func_err() const { uint32_t value = static_cast<uint32_t>(bits.func_err); return value;}
    CONSTEXPR void set_func_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.func_err = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_rec_err() const { uint32_t value = static_cast<uint32_t>(bits.rec_err); return value;}
    CONSTEXPR void set_rec_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.rec_err = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_unrec_err() const { uint32_t value = static_cast<uint32_t>(bits.unrec_err); return value;}
    CONSTEXPR void set_unrec_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.unrec_err = static_cast<uint32_t>(value); }
#endif
};


//
// sec_int_status_r - Internal status register used by the NCU's MCU
//
struct sec_int_status_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t reserved0 : 8;
            uint32_t tsu_evnt : 1; // Event caused by TSU
            uint32_t tsu_irq : 1; // Interrupt caused by TSU
            uint32_t reserved1 : 10;
            uint32_t rxev_evnt : 1; // Event caused by PLE's SEV
            uint32_t rxev_irq : 1; // Interrupt caused by PLE's SEV
            uint32_t reserved2 : 2;
            uint32_t pmu_evnt : 1; // Event caused by PMU overflow
            uint32_t pmu_irq : 1; // Interrupt caused by PMU overflow
            uint32_t reserved3 : 1;
            uint32_t pmu_eng : 1; // Event or interrupt caused by engine PMU
            uint32_t tol_err : 1; // Tolerable error
            uint32_t func_err : 1; // Functional error
            uint32_t rec_err : 1; // Recoverable error
            uint32_t unrec_err : 1; // Unrecoverable error
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_int_status_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_tsu_evnt() const { uint32_t value = static_cast<uint32_t>(bits.tsu_evnt); return value;}
    CONSTEXPR void set_tsu_evnt(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.tsu_evnt = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_tsu_irq() const { uint32_t value = static_cast<uint32_t>(bits.tsu_irq); return value;}
    CONSTEXPR void set_tsu_irq(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.tsu_irq = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_rxev_evnt() const { uint32_t value = static_cast<uint32_t>(bits.rxev_evnt); return value;}
    CONSTEXPR void set_rxev_evnt(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.rxev_evnt = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_rxev_irq() const { uint32_t value = static_cast<uint32_t>(bits.rxev_irq); return value;}
    CONSTEXPR void set_rxev_irq(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.rxev_irq = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_pmu_evnt() const { uint32_t value = static_cast<uint32_t>(bits.pmu_evnt); return value;}
    CONSTEXPR void set_pmu_evnt(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.pmu_evnt = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_pmu_irq() const { uint32_t value = static_cast<uint32_t>(bits.pmu_irq); return value;}
    CONSTEXPR void set_pmu_irq(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.pmu_irq = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_pmu_eng() const { uint32_t value = static_cast<uint32_t>(bits.pmu_eng); return value;}
    CONSTEXPR void set_pmu_eng(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.pmu_eng = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_tol_err() const { uint32_t value = static_cast<uint32_t>(bits.tol_err); return value;}
    CONSTEXPR void set_tol_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.tol_err = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_func_err() const { uint32_t value = static_cast<uint32_t>(bits.func_err); return value;}
    CONSTEXPR void set_func_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.func_err = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_rec_err() const { uint32_t value = static_cast<uint32_t>(bits.rec_err); return value;}
    CONSTEXPR void set_rec_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.rec_err = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_unrec_err() const { uint32_t value = static_cast<uint32_t>(bits.unrec_err); return value;}
    CONSTEXPR void set_unrec_err(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.unrec_err = static_cast<uint32_t>(value); }
#endif
};


//
// sec_ext_status_r - External status register used by the NCU's MCU
//
struct sec_ext_status_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t reserved0 : 4;
            uint32_t setirq_evnt : 1; // Event caused by SETIRQ_INT
            uint32_t setirq_irq : 1; // Interrupt caused by SETIRQ_INT
            uint32_t gp_evnt : 1; // Event caused by host write to GPreg
            uint32_t reserved1 : 25;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_ext_status_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_setirq_evnt() const { uint32_t value = static_cast<uint32_t>(bits.setirq_evnt); return value;}
    CONSTEXPR void set_setirq_evnt(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.setirq_evnt = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_setirq_irq() const { uint32_t value = static_cast<uint32_t>(bits.setirq_irq); return value;}
    CONSTEXPR void set_setirq_irq(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.setirq_irq = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_gp_evnt() const { uint32_t value = static_cast<uint32_t>(bits.gp_evnt); return value;}
    CONSTEXPR void set_gp_evnt(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.gp_evnt = static_cast<uint32_t>(value); }
#endif
};


//
// sec_gp0_r - General purpose register 0
//
struct sec_gp0_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t gp0 : 32; // General purpose register 0
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_gp0_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_gp0() const { uint32_t value = static_cast<uint32_t>(bits.gp0); return value;}
    CONSTEXPR void set_gp0(uint32_t value) { bits.gp0 = static_cast<uint32_t>(value); }
#endif
};


//
// sec_gp1_r - General purpose register 1
//
struct sec_gp1_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t gp1 : 32; // General purpose register 1
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_gp1_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_gp1() const { uint32_t value = static_cast<uint32_t>(bits.gp1); return value;}
    CONSTEXPR void set_gp1(uint32_t value) { bits.gp1 = static_cast<uint32_t>(value); }
#endif
};


//
// sec_gp2_r - General purpose register 2
//
struct sec_gp2_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t gp2 : 32; // General purpose register 2
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_gp2_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_gp2() const { uint32_t value = static_cast<uint32_t>(bits.gp2); return value;}
    CONSTEXPR void set_gp2(uint32_t value) { bits.gp2 = static_cast<uint32_t>(value); }
#endif
};


//
// sec_gp3_r - General purpose register 3
//
struct sec_gp3_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t gp3 : 32; // General purpose register 3
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_gp3_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_gp3() const { uint32_t value = static_cast<uint32_t>(bits.gp3); return value;}
    CONSTEXPR void set_gp3(uint32_t value) { bits.gp3 = static_cast<uint32_t>(value); }
#endif
};


//
// sec_gp4_r - General purpose register 4
//
struct sec_gp4_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t gp4 : 32; // General purpose register 4
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_gp4_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_gp4() const { uint32_t value = static_cast<uint32_t>(bits.gp4); return value;}
    CONSTEXPR void set_gp4(uint32_t value) { bits.gp4 = static_cast<uint32_t>(value); }
#endif
};


//
// sec_gp5_r - General purpose register 5
//
struct sec_gp5_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t gp5 : 32; // General purpose register 5
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_gp5_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_gp5() const { uint32_t value = static_cast<uint32_t>(bits.gp5); return value;}
    CONSTEXPR void set_gp5(uint32_t value) { bits.gp5 = static_cast<uint32_t>(value); }
#endif
};


//
// sec_gp6_r - General purpose register 6
//
struct sec_gp6_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t gp6 : 32; // General purpose register 6
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_gp6_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_gp6() const { uint32_t value = static_cast<uint32_t>(bits.gp6); return value;}
    CONSTEXPR void set_gp6(uint32_t value) { bits.gp6 = static_cast<uint32_t>(value); }
#endif
};


//
// sec_gp7_r - General purpose register 7
//
struct sec_gp7_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t gp7 : 32; // General purpose register 7
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_gp7_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_gp7() const { uint32_t value = static_cast<uint32_t>(bits.gp7); return value;}
    CONSTEXPR void set_gp7(uint32_t value) { bits.gp7 = static_cast<uint32_t>(value); }
#endif
};


//
// sec_delegation_stream_security_r - Stream security state control delegation
//
struct sec_delegation_stream_security_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusecsid0 : 1; // Delegation bit for stream 0 MMUSECSID register
            uint32_t protns0 : 1; // Delegation bit for stream 0 PROTNS register
            uint32_t mmusecsid1 : 1; // Delegation bit for stream 1 MMUSECSID register
            uint32_t protns1 : 1; // Delegation bit for stream 1 PROTNS register
            uint32_t mmusecsid2 : 1; // Delegation bit for stream 2 MMUSECSID register
            uint32_t protns2 : 1; // Delegation bit for stream 2 PROTNS register
            uint32_t mmusecsid3 : 1; // Delegation bit for stream 3 MMUSECSID register
            uint32_t protns3 : 1; // Delegation bit for stream 3 PROTNS register
            uint32_t mmusecsid4 : 1; // Delegation bit for stream 4 MMUSECSID register
            uint32_t protns4 : 1; // Delegation bit for stream 4 PROTNS register
            uint32_t mmusecsid5 : 1; // Delegation bit for stream 5 MMUSECSID register
            uint32_t protns5 : 1; // Delegation bit for stream 5 PROTNS register
            uint32_t mmusecsid6 : 1; // Delegation bit for stream 6 MMUSECSID register
            uint32_t protns6 : 1; // Delegation bit for stream 6 PROTNS register
            uint32_t mmusecsid7 : 1; // Delegation bit for stream 7 MMUSECSID register
            uint32_t protns7 : 1; // Delegation bit for stream 7 PROTNS register
            uint32_t mmusecsid8 : 1; // Delegation bit for stream 8 MMUSECSID register
            uint32_t protns8 : 1; // Delegation bit for stream 8 PROTNS register
            uint32_t reserved0 : 14;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_delegation_stream_security_r(uint32_t init=0) : word(init) {}
    CONSTEXPR delegation_t get_mmusecsid0() const { delegation_t value = static_cast<delegation_t>(bits.mmusecsid0); return value;}
    CONSTEXPR void set_mmusecsid0(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmusecsid0 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_protns0() const { delegation_t value = static_cast<delegation_t>(bits.protns0); return value;}
    CONSTEXPR void set_protns0(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.protns0 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_mmusecsid1() const { delegation_t value = static_cast<delegation_t>(bits.mmusecsid1); return value;}
    CONSTEXPR void set_mmusecsid1(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmusecsid1 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_protns1() const { delegation_t value = static_cast<delegation_t>(bits.protns1); return value;}
    CONSTEXPR void set_protns1(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.protns1 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_mmusecsid2() const { delegation_t value = static_cast<delegation_t>(bits.mmusecsid2); return value;}
    CONSTEXPR void set_mmusecsid2(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmusecsid2 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_protns2() const { delegation_t value = static_cast<delegation_t>(bits.protns2); return value;}
    CONSTEXPR void set_protns2(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.protns2 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_mmusecsid3() const { delegation_t value = static_cast<delegation_t>(bits.mmusecsid3); return value;}
    CONSTEXPR void set_mmusecsid3(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmusecsid3 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_protns3() const { delegation_t value = static_cast<delegation_t>(bits.protns3); return value;}
    CONSTEXPR void set_protns3(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.protns3 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_mmusecsid4() const { delegation_t value = static_cast<delegation_t>(bits.mmusecsid4); return value;}
    CONSTEXPR void set_mmusecsid4(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmusecsid4 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_protns4() const { delegation_t value = static_cast<delegation_t>(bits.protns4); return value;}
    CONSTEXPR void set_protns4(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.protns4 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_mmusecsid5() const { delegation_t value = static_cast<delegation_t>(bits.mmusecsid5); return value;}
    CONSTEXPR void set_mmusecsid5(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmusecsid5 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_protns5() const { delegation_t value = static_cast<delegation_t>(bits.protns5); return value;}
    CONSTEXPR void set_protns5(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.protns5 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_mmusecsid6() const { delegation_t value = static_cast<delegation_t>(bits.mmusecsid6); return value;}
    CONSTEXPR void set_mmusecsid6(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmusecsid6 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_protns6() const { delegation_t value = static_cast<delegation_t>(bits.protns6); return value;}
    CONSTEXPR void set_protns6(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.protns6 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_mmusecsid7() const { delegation_t value = static_cast<delegation_t>(bits.mmusecsid7); return value;}
    CONSTEXPR void set_mmusecsid7(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmusecsid7 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_protns7() const { delegation_t value = static_cast<delegation_t>(bits.protns7); return value;}
    CONSTEXPR void set_protns7(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.protns7 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_mmusecsid8() const { delegation_t value = static_cast<delegation_t>(bits.mmusecsid8); return value;}
    CONSTEXPR void set_mmusecsid8(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmusecsid8 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_protns8() const { delegation_t value = static_cast<delegation_t>(bits.protns8); return value;}
    CONSTEXPR void set_protns8(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.protns8 = static_cast<uint32_t>(value); }
#endif
};


//
// sec_delegation_nsaid_r - Non-secure Access Identifier delegation
//
struct sec_delegation_nsaid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t nsaid0 : 1; // Delegation bit for stream 0 NSAID register
            uint32_t reserved0 : 1;
            uint32_t nsaid1 : 1; // Delegation bit for stream 1 NSAID register
            uint32_t reserved1 : 1;
            uint32_t nsaid2 : 1; // Delegation bit for stream 2 NSAID register
            uint32_t reserved2 : 1;
            uint32_t nsaid3 : 1; // Delegation bit for stream 3 NSAID register
            uint32_t reserved3 : 1;
            uint32_t nsaid4 : 1; // Delegation bit for stream 4 NSAID register
            uint32_t reserved4 : 1;
            uint32_t nsaid5 : 1; // Delegation bit for stream 5 NSAID register
            uint32_t reserved5 : 1;
            uint32_t nsaid6 : 1; // Delegation bit for stream 6 NSAID register
            uint32_t reserved6 : 1;
            uint32_t nsaid7 : 1; // Delegation bit for stream 7 NSAID register
            uint32_t reserved7 : 1;
            uint32_t nsaid8 : 1; // Delegation bit for stream 8 NSAID register
            uint32_t reserved8 : 15;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_delegation_nsaid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR delegation_t get_nsaid0() const { delegation_t value = static_cast<delegation_t>(bits.nsaid0); return value;}
    CONSTEXPR void set_nsaid0(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.nsaid0 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_nsaid1() const { delegation_t value = static_cast<delegation_t>(bits.nsaid1); return value;}
    CONSTEXPR void set_nsaid1(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.nsaid1 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_nsaid2() const { delegation_t value = static_cast<delegation_t>(bits.nsaid2); return value;}
    CONSTEXPR void set_nsaid2(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.nsaid2 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_nsaid3() const { delegation_t value = static_cast<delegation_t>(bits.nsaid3); return value;}
    CONSTEXPR void set_nsaid3(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.nsaid3 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_nsaid4() const { delegation_t value = static_cast<delegation_t>(bits.nsaid4); return value;}
    CONSTEXPR void set_nsaid4(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.nsaid4 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_nsaid5() const { delegation_t value = static_cast<delegation_t>(bits.nsaid5); return value;}
    CONSTEXPR void set_nsaid5(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.nsaid5 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_nsaid6() const { delegation_t value = static_cast<delegation_t>(bits.nsaid6); return value;}
    CONSTEXPR void set_nsaid6(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.nsaid6 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_nsaid7() const { delegation_t value = static_cast<delegation_t>(bits.nsaid7); return value;}
    CONSTEXPR void set_nsaid7(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.nsaid7 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_nsaid8() const { delegation_t value = static_cast<delegation_t>(bits.nsaid8); return value;}
    CONSTEXPR void set_nsaid8(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.nsaid8 = static_cast<uint32_t>(value); }
#endif
};


//
// sec_delegation_mmusid_r - MMU Stream Identifier delegation
//
struct sec_delegation_mmusid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t sid0 : 2; // Delegation bit for stream 0 MMUSID register
            uint32_t sid1 : 2; // Delegation bit for stream 1 MMUSID register
            uint32_t sid2 : 2; // Delegation bit for stream 2 MMUSID register
            uint32_t sid3 : 2; // Delegation bit for stream 3 MMUSID register
            uint32_t sid4 : 2; // Delegation bit for stream 4 MMUSID register
            uint32_t sid5 : 2; // Delegation bit for stream 5 MMUSID register
            uint32_t sid6 : 2; // Delegation bit for stream 6 MMUSID register
            uint32_t sid7 : 2; // Delegation bit for stream 7 MMUSID register
            uint32_t sid8 : 2; // Delegation bit for stream 8 MMUSID register
            uint32_t reserved0 : 14;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_delegation_mmusid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR streamid_delegation_t get_sid0() const { streamid_delegation_t value = static_cast<streamid_delegation_t>(bits.sid0); return value;}
    CONSTEXPR void set_sid0(streamid_delegation_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.sid0 = static_cast<uint32_t>(value); }
    CONSTEXPR streamid_delegation_t get_sid1() const { streamid_delegation_t value = static_cast<streamid_delegation_t>(bits.sid1); return value;}
    CONSTEXPR void set_sid1(streamid_delegation_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.sid1 = static_cast<uint32_t>(value); }
    CONSTEXPR streamid_delegation_t get_sid2() const { streamid_delegation_t value = static_cast<streamid_delegation_t>(bits.sid2); return value;}
    CONSTEXPR void set_sid2(streamid_delegation_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.sid2 = static_cast<uint32_t>(value); }
    CONSTEXPR streamid_delegation_t get_sid3() const { streamid_delegation_t value = static_cast<streamid_delegation_t>(bits.sid3); return value;}
    CONSTEXPR void set_sid3(streamid_delegation_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.sid3 = static_cast<uint32_t>(value); }
    CONSTEXPR streamid_delegation_t get_sid4() const { streamid_delegation_t value = static_cast<streamid_delegation_t>(bits.sid4); return value;}
    CONSTEXPR void set_sid4(streamid_delegation_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.sid4 = static_cast<uint32_t>(value); }
    CONSTEXPR streamid_delegation_t get_sid5() const { streamid_delegation_t value = static_cast<streamid_delegation_t>(bits.sid5); return value;}
    CONSTEXPR void set_sid5(streamid_delegation_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.sid5 = static_cast<uint32_t>(value); }
    CONSTEXPR streamid_delegation_t get_sid6() const { streamid_delegation_t value = static_cast<streamid_delegation_t>(bits.sid6); return value;}
    CONSTEXPR void set_sid6(streamid_delegation_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.sid6 = static_cast<uint32_t>(value); }
    CONSTEXPR streamid_delegation_t get_sid7() const { streamid_delegation_t value = static_cast<streamid_delegation_t>(bits.sid7); return value;}
    CONSTEXPR void set_sid7(streamid_delegation_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.sid7 = static_cast<uint32_t>(value); }
    CONSTEXPR streamid_delegation_t get_sid8() const { streamid_delegation_t value = static_cast<streamid_delegation_t>(bits.sid8); return value;}
    CONSTEXPR void set_sid8(streamid_delegation_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.sid8 = static_cast<uint32_t>(value); }
#endif
};


//
// sec_delegation_mmussid_r - MMU Sub-stream Stream ID delegation
//
struct sec_delegation_mmussid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t ssid0 : 2; // Delegation bit for stream 0 MMUSSID register
            uint32_t ssid1 : 2; // Delegation bit for stream 1 MMUSSID register
            uint32_t ssid2 : 2; // Delegation bit for stream 2 MMUSSID register
            uint32_t ssid3 : 2; // Delegation bit for stream 3 MMUSSID register
            uint32_t ssid4 : 2; // Delegation bit for stream 4 MMUSSID register
            uint32_t ssid5 : 2; // Delegation bit for stream 5 MMUSSID register
            uint32_t ssid6 : 2; // Delegation bit for stream 6 MMUSSID register
            uint32_t ssid7 : 2; // Delegation bit for stream 7 MMUSSID register
            uint32_t ssid8 : 2; // Delegation bit for stream 8 MMUSSID register
            uint32_t reserved0 : 14;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_delegation_mmussid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR substreamid_delegation_t get_ssid0() const { substreamid_delegation_t value = static_cast<substreamid_delegation_t>(bits.ssid0); return value;}
    CONSTEXPR void set_ssid0(substreamid_delegation_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.ssid0 = static_cast<uint32_t>(value); }
    CONSTEXPR substreamid_delegation_t get_ssid1() const { substreamid_delegation_t value = static_cast<substreamid_delegation_t>(bits.ssid1); return value;}
    CONSTEXPR void set_ssid1(substreamid_delegation_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.ssid1 = static_cast<uint32_t>(value); }
    CONSTEXPR substreamid_delegation_t get_ssid2() const { substreamid_delegation_t value = static_cast<substreamid_delegation_t>(bits.ssid2); return value;}
    CONSTEXPR void set_ssid2(substreamid_delegation_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.ssid2 = static_cast<uint32_t>(value); }
    CONSTEXPR substreamid_delegation_t get_ssid3() const { substreamid_delegation_t value = static_cast<substreamid_delegation_t>(bits.ssid3); return value;}
    CONSTEXPR void set_ssid3(substreamid_delegation_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.ssid3 = static_cast<uint32_t>(value); }
    CONSTEXPR substreamid_delegation_t get_ssid4() const { substreamid_delegation_t value = static_cast<substreamid_delegation_t>(bits.ssid4); return value;}
    CONSTEXPR void set_ssid4(substreamid_delegation_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.ssid4 = static_cast<uint32_t>(value); }
    CONSTEXPR substreamid_delegation_t get_ssid5() const { substreamid_delegation_t value = static_cast<substreamid_delegation_t>(bits.ssid5); return value;}
    CONSTEXPR void set_ssid5(substreamid_delegation_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.ssid5 = static_cast<uint32_t>(value); }
    CONSTEXPR substreamid_delegation_t get_ssid6() const { substreamid_delegation_t value = static_cast<substreamid_delegation_t>(bits.ssid6); return value;}
    CONSTEXPR void set_ssid6(substreamid_delegation_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.ssid6 = static_cast<uint32_t>(value); }
    CONSTEXPR substreamid_delegation_t get_ssid7() const { substreamid_delegation_t value = static_cast<substreamid_delegation_t>(bits.ssid7); return value;}
    CONSTEXPR void set_ssid7(substreamid_delegation_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.ssid7 = static_cast<uint32_t>(value); }
    CONSTEXPR substreamid_delegation_t get_ssid8() const { substreamid_delegation_t value = static_cast<substreamid_delegation_t>(bits.ssid8); return value;}
    CONSTEXPR void set_ssid8(substreamid_delegation_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.ssid8 = static_cast<uint32_t>(value); }
#endif
};


//
// sec_delegation_mmussidv_r - MMU Sub-stream Stream IDV delegation
//
struct sec_delegation_mmussidv_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t ssidv0 : 1; // Delegation bit for stream 0 MMUSSIDV register
            uint32_t ssidv1 : 1; // Delegation bit for stream 1 MMUSSIDV register
            uint32_t ssidv2 : 1; // Delegation bit for stream 2 MMUSSIDV register
            uint32_t ssidv3 : 1; // Delegation bit for stream 3 MMUSSIDV register
            uint32_t ssidv4 : 1; // Delegation bit for stream 4 MMUSSIDV register
            uint32_t ssidv5 : 1; // Delegation bit for stream 5 MMUSSIDV register
            uint32_t ssidv6 : 1; // Delegation bit for stream 6 MMUSSIDV register
            uint32_t ssidv7 : 1; // Delegation bit for stream 7 MMUSSIDV register
            uint32_t ssidv8 : 1; // Delegation bit for stream 8 MMUSSIDV register
            uint32_t reserved0 : 23;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_delegation_mmussidv_r(uint32_t init=0) : word(init) {}
    CONSTEXPR delegation_t get_ssidv0() const { delegation_t value = static_cast<delegation_t>(bits.ssidv0); return value;}
    CONSTEXPR void set_ssidv0(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ssidv0 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_ssidv1() const { delegation_t value = static_cast<delegation_t>(bits.ssidv1); return value;}
    CONSTEXPR void set_ssidv1(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ssidv1 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_ssidv2() const { delegation_t value = static_cast<delegation_t>(bits.ssidv2); return value;}
    CONSTEXPR void set_ssidv2(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ssidv2 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_ssidv3() const { delegation_t value = static_cast<delegation_t>(bits.ssidv3); return value;}
    CONSTEXPR void set_ssidv3(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ssidv3 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_ssidv4() const { delegation_t value = static_cast<delegation_t>(bits.ssidv4); return value;}
    CONSTEXPR void set_ssidv4(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ssidv4 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_ssidv5() const { delegation_t value = static_cast<delegation_t>(bits.ssidv5); return value;}
    CONSTEXPR void set_ssidv5(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ssidv5 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_ssidv6() const { delegation_t value = static_cast<delegation_t>(bits.ssidv6); return value;}
    CONSTEXPR void set_ssidv6(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ssidv6 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_ssidv7() const { delegation_t value = static_cast<delegation_t>(bits.ssidv7); return value;}
    CONSTEXPR void set_ssidv7(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ssidv7 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_ssidv8() const { delegation_t value = static_cast<delegation_t>(bits.ssidv8); return value;}
    CONSTEXPR void set_ssidv8(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ssidv8 = static_cast<uint32_t>(value); }
#endif
};


//
// sec_delegation_attr_control_r - Attribute Control delegation
//
struct sec_delegation_attr_control_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t attrctrl0 : 1; // Delegation bit for stream 0 Attribute Control register
            uint32_t attrctrl1 : 1; // Delegation bit for stream 1 Attribute Control register
            uint32_t attrctrl2 : 1; // Delegation bit for stream 2 Attribute Control register
            uint32_t attrctrl3 : 1; // Delegation bit for stream 3 Attribute Control register
            uint32_t attrctrl4 : 1; // Delegation bit for stream 4 Attribute Control register
            uint32_t attrctrl5 : 1; // Delegation bit for stream 5 Attribute Control register
            uint32_t attrctrl6 : 1; // Delegation bit for stream 6 Attribute Control register
            uint32_t attrctrl7 : 1; // Delegation bit for stream 7 Attribute Control register
            uint32_t attrctrl8 : 1; // Delegation bit for stream 8 Attribute Control register
            uint32_t reserved0 : 23;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_delegation_attr_control_r(uint32_t init=0) : word(init) {}
    CONSTEXPR delegation_t get_attrctrl0() const { delegation_t value = static_cast<delegation_t>(bits.attrctrl0); return value;}
    CONSTEXPR void set_attrctrl0(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.attrctrl0 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_attrctrl1() const { delegation_t value = static_cast<delegation_t>(bits.attrctrl1); return value;}
    CONSTEXPR void set_attrctrl1(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.attrctrl1 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_attrctrl2() const { delegation_t value = static_cast<delegation_t>(bits.attrctrl2); return value;}
    CONSTEXPR void set_attrctrl2(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.attrctrl2 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_attrctrl3() const { delegation_t value = static_cast<delegation_t>(bits.attrctrl3); return value;}
    CONSTEXPR void set_attrctrl3(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.attrctrl3 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_attrctrl4() const { delegation_t value = static_cast<delegation_t>(bits.attrctrl4); return value;}
    CONSTEXPR void set_attrctrl4(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.attrctrl4 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_attrctrl5() const { delegation_t value = static_cast<delegation_t>(bits.attrctrl5); return value;}
    CONSTEXPR void set_attrctrl5(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.attrctrl5 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_attrctrl6() const { delegation_t value = static_cast<delegation_t>(bits.attrctrl6); return value;}
    CONSTEXPR void set_attrctrl6(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.attrctrl6 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_attrctrl7() const { delegation_t value = static_cast<delegation_t>(bits.attrctrl7); return value;}
    CONSTEXPR void set_attrctrl7(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.attrctrl7 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_attrctrl8() const { delegation_t value = static_cast<delegation_t>(bits.attrctrl8); return value;}
    CONSTEXPR void set_attrctrl8(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.attrctrl8 = static_cast<uint32_t>(value); }
#endif
};


//
// sec_delegation_memattr_r - Memory Attributes delegation
//
struct sec_delegation_memattr_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t memattr0 : 1; // Delegation bit for stream 0 Memory Attributes register
            uint32_t memattr1 : 1; // Delegation bit for stream 1 Memory Attributes register
            uint32_t memattr2 : 1; // Delegation bit for stream 2 Memory Attributes register
            uint32_t memattr3 : 1; // Delegation bit for stream 3 Memory Attributes register
            uint32_t memattr4 : 1; // Delegation bit for stream 4 Memory Attributes register
            uint32_t memattr5 : 1; // Delegation bit for stream 5 Memory Attributes register
            uint32_t memattr6 : 1; // Delegation bit for stream 6 Memory Attributes register
            uint32_t memattr7 : 1; // Delegation bit for stream 7 Memory Attributes register
            uint32_t memattr8 : 1; // Delegation bit for stream 8 Memory Attributes register
            uint32_t reserved0 : 23;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_delegation_memattr_r(uint32_t init=0) : word(init) {}
    CONSTEXPR delegation_t get_memattr0() const { delegation_t value = static_cast<delegation_t>(bits.memattr0); return value;}
    CONSTEXPR void set_memattr0(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.memattr0 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_memattr1() const { delegation_t value = static_cast<delegation_t>(bits.memattr1); return value;}
    CONSTEXPR void set_memattr1(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.memattr1 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_memattr2() const { delegation_t value = static_cast<delegation_t>(bits.memattr2); return value;}
    CONSTEXPR void set_memattr2(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.memattr2 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_memattr3() const { delegation_t value = static_cast<delegation_t>(bits.memattr3); return value;}
    CONSTEXPR void set_memattr3(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.memattr3 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_memattr4() const { delegation_t value = static_cast<delegation_t>(bits.memattr4); return value;}
    CONSTEXPR void set_memattr4(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.memattr4 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_memattr5() const { delegation_t value = static_cast<delegation_t>(bits.memattr5); return value;}
    CONSTEXPR void set_memattr5(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.memattr5 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_memattr6() const { delegation_t value = static_cast<delegation_t>(bits.memattr6); return value;}
    CONSTEXPR void set_memattr6(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.memattr6 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_memattr7() const { delegation_t value = static_cast<delegation_t>(bits.memattr7); return value;}
    CONSTEXPR void set_memattr7(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.memattr7 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_memattr8() const { delegation_t value = static_cast<delegation_t>(bits.memattr8); return value;}
    CONSTEXPR void set_memattr8(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.memattr8 = static_cast<uint32_t>(value); }
#endif
};


//
// sec_delegation_address_extend_r - Extended address bits control delegation
//
struct sec_delegation_address_extend_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t addressextend0 : 1; // Delegation bit for stream 0 ADDRESSEXTEND register
            uint32_t reserved0 : 1;
            uint32_t addressextend1 : 1; // Delegation bit for stream 1 ADDRESSEXTEND register
            uint32_t reserved1 : 1;
            uint32_t addressextend2 : 1; // Delegation bit for stream 2 ADDRESSEXTEND register
            uint32_t reserved2 : 27;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_delegation_address_extend_r(uint32_t init=0) : word(init) {}
    CONSTEXPR delegation_t get_addressextend0() const { delegation_t value = static_cast<delegation_t>(bits.addressextend0); return value;}
    CONSTEXPR void set_addressextend0(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.addressextend0 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_addressextend1() const { delegation_t value = static_cast<delegation_t>(bits.addressextend1); return value;}
    CONSTEXPR void set_addressextend1(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.addressextend1 = static_cast<uint32_t>(value); }
    CONSTEXPR delegation_t get_addressextend2() const { delegation_t value = static_cast<delegation_t>(bits.addressextend2); return value;}
    CONSTEXPR void set_addressextend2(delegation_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.addressextend2 = static_cast<uint32_t>(value); }
#endif
};


//
// sec_stream0_stream_security_r - Stream 0 - Security State
//
struct sec_stream0_stream_security_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusecsid : 1; // MMU stream security state
            uint32_t protns : 1; // AXI stream security state
            uint32_t reserved0 : 30;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_stream0_stream_security_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmusecsid() const { uint32_t value = static_cast<uint32_t>(bits.mmusecsid); return value;}
    CONSTEXPR void set_mmusecsid(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmusecsid = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_protns() const { uint32_t value = static_cast<uint32_t>(bits.protns); return value;}
    CONSTEXPR void set_protns(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.protns = static_cast<uint32_t>(value); }
#endif
};


//
// sec_stream0_nsaid_r - Stream 0 - Non-secure Access Identifier
//
struct sec_stream0_nsaid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t nsaid : 4; // Non-Secure Address Identifier
            uint32_t reserved0 : 28;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_stream0_nsaid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_nsaid() const { uint32_t value = static_cast<uint32_t>(bits.nsaid); return value;}
    CONSTEXPR void set_nsaid(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.nsaid = static_cast<uint32_t>(value); }
#endif
};


//
// sec_stream0_mmusid_r - Stream 0 - MMU Stream Identifier
//
struct sec_stream0_mmusid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusid : 32; // MMU Stream ID (actual width is implementation defined)
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_stream0_mmusid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmusid() const { uint32_t value = static_cast<uint32_t>(bits.mmusid); return value;}
    CONSTEXPR void set_mmusid(uint32_t value) { bits.mmusid = static_cast<uint32_t>(value); }
#endif
};


//
// sec_stream0_mmussid_r - Stream 0 - MMU Sub-stream Stream Identifier
//
struct sec_stream0_mmussid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmussid : 20; // MMU Sub-Stream ID (actual width is implementation defined)
            uint32_t reserved0 : 11;
            uint32_t mmussidv : 1; // MMUSSID valid bit
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_stream0_mmussid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmussid() const { uint32_t value = static_cast<uint32_t>(bits.mmussid); return value;}
    CONSTEXPR void set_mmussid(uint32_t value) { assert(static_cast<uint32_t>(value) < 1048576u); bits.mmussid = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mmussidv() const { uint32_t value = static_cast<uint32_t>(bits.mmussidv); return value;}
    CONSTEXPR void set_mmussidv(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmussidv = static_cast<uint32_t>(value); }
#endif
};


//
// sec_stream0_attr_control_r - Stream 0 - Attribute Control
//
struct sec_stream0_attr_control_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t attrlocked : 1; // Stream attributes locked
            uint32_t reserved0 : 31;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_stream0_attr_control_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_attrlocked() const { uint32_t value = static_cast<uint32_t>(bits.attrlocked); return value;}
    CONSTEXPR void set_attrlocked(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.attrlocked = static_cast<uint32_t>(value); }
#endif
};


//
// sec_stream0_memattr_r - Stream 0 - Memory Attributes
//
struct sec_stream0_memattr_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t memattr : 4; // Memory attributes
            uint32_t reserved0 : 28;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_stream0_memattr_r(uint32_t init=0) : word(init) {}
    CONSTEXPR memory_attributes_t get_memattr() const { memory_attributes_t value = static_cast<memory_attributes_t>(bits.memattr); return value;}
    CONSTEXPR void set_memattr(memory_attributes_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.memattr = static_cast<uint32_t>(value); }
#endif
};


//
// sec_stream0_address_extend_r - Stream 0 - Extended address bits per stream
//
struct sec_stream0_address_extend_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t reserved0 : 9;
            uint32_t addrextend : 20; // Address extension bits [48:29]
            uint32_t reserved1 : 3;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_stream0_address_extend_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_addrextend() const { uint32_t value = static_cast<uint32_t>(bits.addrextend); return value;}
    CONSTEXPR void set_addrextend(uint32_t value) { assert(static_cast<uint32_t>(value) < 1048576u); bits.addrextend = static_cast<uint32_t>(value); }
#endif
};


//
// sec_stream1_stream_security_r - Stream 1 - Security State
//
struct sec_stream1_stream_security_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusecsid : 1; // MMU stream security state
            uint32_t protns : 1; // AXI stream security state
            uint32_t reserved0 : 30;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_stream1_stream_security_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmusecsid() const { uint32_t value = static_cast<uint32_t>(bits.mmusecsid); return value;}
    CONSTEXPR void set_mmusecsid(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmusecsid = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_protns() const { uint32_t value = static_cast<uint32_t>(bits.protns); return value;}
    CONSTEXPR void set_protns(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.protns = static_cast<uint32_t>(value); }
#endif
};


//
// sec_stream1_nsaid_r - Stream 1 - Non-secure Access Identifier
//
struct sec_stream1_nsaid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t nsaid : 4; // Non-Secure Address Identifier
            uint32_t reserved0 : 28;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_stream1_nsaid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_nsaid() const { uint32_t value = static_cast<uint32_t>(bits.nsaid); return value;}
    CONSTEXPR void set_nsaid(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.nsaid = static_cast<uint32_t>(value); }
#endif
};


//
// sec_stream1_mmusid_r - Stream 1 - MMU Stream Identifier
//
struct sec_stream1_mmusid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusid : 32; // MMU Stream ID (actual width is implementation defined)
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_stream1_mmusid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmusid() const { uint32_t value = static_cast<uint32_t>(bits.mmusid); return value;}
    CONSTEXPR void set_mmusid(uint32_t value) { bits.mmusid = static_cast<uint32_t>(value); }
#endif
};


//
// sec_stream1_mmussid_r - Stream 1 - MMU Sub-stream Stream Identifier
//
struct sec_stream1_mmussid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmussid : 20; // MMU Sub-Stream ID (actual width is implementation defined)
            uint32_t reserved0 : 11;
            uint32_t mmussidv : 1; // MMUSSID valid bit
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_stream1_mmussid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmussid() const { uint32_t value = static_cast<uint32_t>(bits.mmussid); return value;}
    CONSTEXPR void set_mmussid(uint32_t value) { assert(static_cast<uint32_t>(value) < 1048576u); bits.mmussid = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mmussidv() const { uint32_t value = static_cast<uint32_t>(bits.mmussidv); return value;}
    CONSTEXPR void set_mmussidv(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmussidv = static_cast<uint32_t>(value); }
#endif
};


//
// sec_stream1_attr_control_r - Stream 1 - Attribute Control
//
struct sec_stream1_attr_control_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t attrlocked : 1; // Stream attributes locked
            uint32_t reserved0 : 31;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_stream1_attr_control_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_attrlocked() const { uint32_t value = static_cast<uint32_t>(bits.attrlocked); return value;}
    CONSTEXPR void set_attrlocked(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.attrlocked = static_cast<uint32_t>(value); }
#endif
};


//
// sec_stream1_memattr_r - Stream 1 - Memory Attributes
//
struct sec_stream1_memattr_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t memattr : 4; // Memory attributes
            uint32_t reserved0 : 28;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_stream1_memattr_r(uint32_t init=0) : word(init) {}
    CONSTEXPR memory_attributes_t get_memattr() const { memory_attributes_t value = static_cast<memory_attributes_t>(bits.memattr); return value;}
    CONSTEXPR void set_memattr(memory_attributes_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.memattr = static_cast<uint32_t>(value); }
#endif
};


//
// sec_stream1_address_extend_r - Stream 1 - Extended address bits per stream
//
struct sec_stream1_address_extend_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t reserved0 : 9;
            uint32_t addrextend : 20; // Address extension bits [48:29]
            uint32_t reserved1 : 3;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_stream1_address_extend_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_addrextend() const { uint32_t value = static_cast<uint32_t>(bits.addrextend); return value;}
    CONSTEXPR void set_addrextend(uint32_t value) { assert(static_cast<uint32_t>(value) < 1048576u); bits.addrextend = static_cast<uint32_t>(value); }
#endif
};


//
// sec_stream2_stream_security_r - Stream 2 - Security State
//
struct sec_stream2_stream_security_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusecsid : 1; // MMU stream security state
            uint32_t protns : 1; // AXI stream security state
            uint32_t reserved0 : 30;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_stream2_stream_security_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmusecsid() const { uint32_t value = static_cast<uint32_t>(bits.mmusecsid); return value;}
    CONSTEXPR void set_mmusecsid(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmusecsid = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_protns() const { uint32_t value = static_cast<uint32_t>(bits.protns); return value;}
    CONSTEXPR void set_protns(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.protns = static_cast<uint32_t>(value); }
#endif
};


//
// sec_stream2_nsaid_r - Stream 2 - Non-secure Access Identifier
//
struct sec_stream2_nsaid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t nsaid : 4; // Non-Secure Address Identifier
            uint32_t reserved0 : 28;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_stream2_nsaid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_nsaid() const { uint32_t value = static_cast<uint32_t>(bits.nsaid); return value;}
    CONSTEXPR void set_nsaid(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.nsaid = static_cast<uint32_t>(value); }
#endif
};


//
// sec_stream2_mmusid_r - Stream 2 - MMU Stream Identifier
//
struct sec_stream2_mmusid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusid : 32; // MMU Stream ID (actual width is implementation defined)
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_stream2_mmusid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmusid() const { uint32_t value = static_cast<uint32_t>(bits.mmusid); return value;}
    CONSTEXPR void set_mmusid(uint32_t value) { bits.mmusid = static_cast<uint32_t>(value); }
#endif
};


//
// sec_stream2_mmussid_r - Stream 2 - MMU Sub-stream Stream Identifier
//
struct sec_stream2_mmussid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmussid : 20; // MMU Sub-Stream ID (actual width is implementation defined)
            uint32_t reserved0 : 11;
            uint32_t mmussidv : 1; // MMUSSID valid bit
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_stream2_mmussid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmussid() const { uint32_t value = static_cast<uint32_t>(bits.mmussid); return value;}
    CONSTEXPR void set_mmussid(uint32_t value) { assert(static_cast<uint32_t>(value) < 1048576u); bits.mmussid = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mmussidv() const { uint32_t value = static_cast<uint32_t>(bits.mmussidv); return value;}
    CONSTEXPR void set_mmussidv(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmussidv = static_cast<uint32_t>(value); }
#endif
};


//
// sec_stream2_attr_control_r - Stream 2 - Attribute Control
//
struct sec_stream2_attr_control_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t attrlocked : 1; // Stream attributes locked
            uint32_t reserved0 : 31;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_stream2_attr_control_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_attrlocked() const { uint32_t value = static_cast<uint32_t>(bits.attrlocked); return value;}
    CONSTEXPR void set_attrlocked(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.attrlocked = static_cast<uint32_t>(value); }
#endif
};


//
// sec_stream2_memattr_r - Stream 2 - Memory Attributes
//
struct sec_stream2_memattr_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t memattr : 4; // Memory attributes
            uint32_t reserved0 : 28;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_stream2_memattr_r(uint32_t init=0) : word(init) {}
    CONSTEXPR memory_attributes_t get_memattr() const { memory_attributes_t value = static_cast<memory_attributes_t>(bits.memattr); return value;}
    CONSTEXPR void set_memattr(memory_attributes_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.memattr = static_cast<uint32_t>(value); }
#endif
};


//
// sec_stream2_address_extend_r - Stream 2 - Extended address bits per stream
//
struct sec_stream2_address_extend_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t reserved0 : 9;
            uint32_t addrextend : 20; // Address extension bits [48:29]
            uint32_t reserved1 : 3;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_stream2_address_extend_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_addrextend() const { uint32_t value = static_cast<uint32_t>(bits.addrextend); return value;}
    CONSTEXPR void set_addrextend(uint32_t value) { assert(static_cast<uint32_t>(value) < 1048576u); bits.addrextend = static_cast<uint32_t>(value); }
#endif
};


//
// sec_stream3_stream_security_r - Stream 3 - Security State
//
struct sec_stream3_stream_security_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusecsid : 1; // MMU stream security state
            uint32_t protns : 1; // AXI stream security state
            uint32_t reserved0 : 30;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_stream3_stream_security_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmusecsid() const { uint32_t value = static_cast<uint32_t>(bits.mmusecsid); return value;}
    CONSTEXPR void set_mmusecsid(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmusecsid = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_protns() const { uint32_t value = static_cast<uint32_t>(bits.protns); return value;}
    CONSTEXPR void set_protns(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.protns = static_cast<uint32_t>(value); }
#endif
};


//
// sec_stream3_nsaid_r - Stream 3 - Non-secure Access Identifier
//
struct sec_stream3_nsaid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t nsaid : 4; // Non-Secure Address Identifier
            uint32_t reserved0 : 28;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_stream3_nsaid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_nsaid() const { uint32_t value = static_cast<uint32_t>(bits.nsaid); return value;}
    CONSTEXPR void set_nsaid(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.nsaid = static_cast<uint32_t>(value); }
#endif
};


//
// sec_stream3_mmusid_r - Stream 3 - MMU Stream Identifier
//
struct sec_stream3_mmusid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusid : 32; // MMU Stream ID (actual width is implementation defined)
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_stream3_mmusid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmusid() const { uint32_t value = static_cast<uint32_t>(bits.mmusid); return value;}
    CONSTEXPR void set_mmusid(uint32_t value) { bits.mmusid = static_cast<uint32_t>(value); }
#endif
};


//
// sec_stream3_mmussid_r - Stream 3 - MMU Sub-stream Stream Identifier
//
struct sec_stream3_mmussid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmussid : 20; // MMU Sub-Stream ID (actual width is implementation defined)
            uint32_t reserved0 : 11;
            uint32_t mmussidv : 1; // MMUSSID valid bit
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_stream3_mmussid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmussid() const { uint32_t value = static_cast<uint32_t>(bits.mmussid); return value;}
    CONSTEXPR void set_mmussid(uint32_t value) { assert(static_cast<uint32_t>(value) < 1048576u); bits.mmussid = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mmussidv() const { uint32_t value = static_cast<uint32_t>(bits.mmussidv); return value;}
    CONSTEXPR void set_mmussidv(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmussidv = static_cast<uint32_t>(value); }
#endif
};


//
// sec_stream3_attr_control_r - Stream 3 - Attribute Control
//
struct sec_stream3_attr_control_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t attrlocked : 1; // Stream attributes locked
            uint32_t reserved0 : 31;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_stream3_attr_control_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_attrlocked() const { uint32_t value = static_cast<uint32_t>(bits.attrlocked); return value;}
    CONSTEXPR void set_attrlocked(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.attrlocked = static_cast<uint32_t>(value); }
#endif
};


//
// sec_stream3_memattr_r - Stream 3 - Memory Attributes
//
struct sec_stream3_memattr_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t memattr : 4; // Memory attributes
            uint32_t reserved0 : 28;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_stream3_memattr_r(uint32_t init=0) : word(init) {}
    CONSTEXPR memory_attributes_t get_memattr() const { memory_attributes_t value = static_cast<memory_attributes_t>(bits.memattr); return value;}
    CONSTEXPR void set_memattr(memory_attributes_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.memattr = static_cast<uint32_t>(value); }
#endif
};


//
// sec_stream4_stream_security_r - Stream 4 - Security State
//
struct sec_stream4_stream_security_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusecsid : 1; // MMU stream security state
            uint32_t protns : 1; // AXI stream security state
            uint32_t reserved0 : 30;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_stream4_stream_security_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmusecsid() const { uint32_t value = static_cast<uint32_t>(bits.mmusecsid); return value;}
    CONSTEXPR void set_mmusecsid(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmusecsid = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_protns() const { uint32_t value = static_cast<uint32_t>(bits.protns); return value;}
    CONSTEXPR void set_protns(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.protns = static_cast<uint32_t>(value); }
#endif
};


//
// sec_stream4_nsaid_r - Stream 4 - Non-secure Access Identifier
//
struct sec_stream4_nsaid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t nsaid : 4; // Non-Secure Address Identifier
            uint32_t reserved0 : 28;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_stream4_nsaid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_nsaid() const { uint32_t value = static_cast<uint32_t>(bits.nsaid); return value;}
    CONSTEXPR void set_nsaid(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.nsaid = static_cast<uint32_t>(value); }
#endif
};


//
// sec_stream4_mmusid_r - Stream 4 - MMU Stream Identifier
//
struct sec_stream4_mmusid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusid : 32; // MMU Stream ID (actual width is implementation defined)
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_stream4_mmusid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmusid() const { uint32_t value = static_cast<uint32_t>(bits.mmusid); return value;}
    CONSTEXPR void set_mmusid(uint32_t value) { bits.mmusid = static_cast<uint32_t>(value); }
#endif
};


//
// sec_stream4_mmussid_r - Stream 4 - MMU Sub-stream Stream Identifier
//
struct sec_stream4_mmussid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmussid : 20; // MMU Sub-Stream ID (actual width is implementation defined)
            uint32_t reserved0 : 11;
            uint32_t mmussidv : 1; // MMUSSID valid bit
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_stream4_mmussid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmussid() const { uint32_t value = static_cast<uint32_t>(bits.mmussid); return value;}
    CONSTEXPR void set_mmussid(uint32_t value) { assert(static_cast<uint32_t>(value) < 1048576u); bits.mmussid = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mmussidv() const { uint32_t value = static_cast<uint32_t>(bits.mmussidv); return value;}
    CONSTEXPR void set_mmussidv(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmussidv = static_cast<uint32_t>(value); }
#endif
};


//
// sec_stream4_attr_control_r - Stream 4 - Attribute Control
//
struct sec_stream4_attr_control_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t attrlocked : 1; // Stream attributes locked
            uint32_t reserved0 : 31;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_stream4_attr_control_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_attrlocked() const { uint32_t value = static_cast<uint32_t>(bits.attrlocked); return value;}
    CONSTEXPR void set_attrlocked(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.attrlocked = static_cast<uint32_t>(value); }
#endif
};


//
// sec_stream4_memattr_r - Stream 4 - Memory Attributes
//
struct sec_stream4_memattr_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t memattr : 4; // Memory attributes
            uint32_t reserved0 : 28;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_stream4_memattr_r(uint32_t init=0) : word(init) {}
    CONSTEXPR memory_attributes_t get_memattr() const { memory_attributes_t value = static_cast<memory_attributes_t>(bits.memattr); return value;}
    CONSTEXPR void set_memattr(memory_attributes_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.memattr = static_cast<uint32_t>(value); }
#endif
};


//
// sec_stream5_stream_security_r - Stream 5 - Security State
//
struct sec_stream5_stream_security_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusecsid : 1; // MMU stream security state
            uint32_t protns : 1; // AXI stream security state
            uint32_t reserved0 : 30;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_stream5_stream_security_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmusecsid() const { uint32_t value = static_cast<uint32_t>(bits.mmusecsid); return value;}
    CONSTEXPR void set_mmusecsid(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmusecsid = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_protns() const { uint32_t value = static_cast<uint32_t>(bits.protns); return value;}
    CONSTEXPR void set_protns(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.protns = static_cast<uint32_t>(value); }
#endif
};


//
// sec_stream5_nsaid_r - Stream 5 - Non-secure Access Identifier
//
struct sec_stream5_nsaid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t nsaid : 4; // Non-Secure Address Identifier
            uint32_t reserved0 : 28;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_stream5_nsaid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_nsaid() const { uint32_t value = static_cast<uint32_t>(bits.nsaid); return value;}
    CONSTEXPR void set_nsaid(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.nsaid = static_cast<uint32_t>(value); }
#endif
};


//
// sec_stream5_mmusid_r - Stream 5 - MMU Stream Identifier
//
struct sec_stream5_mmusid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusid : 32; // MMU Stream ID (actual width is implementation defined)
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_stream5_mmusid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmusid() const { uint32_t value = static_cast<uint32_t>(bits.mmusid); return value;}
    CONSTEXPR void set_mmusid(uint32_t value) { bits.mmusid = static_cast<uint32_t>(value); }
#endif
};


//
// sec_stream5_mmussid_r - Stream 5 - MMU Sub-stream Stream Identifier
//
struct sec_stream5_mmussid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmussid : 20; // MMU Sub-Stream ID (actual width is implementation defined)
            uint32_t reserved0 : 11;
            uint32_t mmussidv : 1; // MMUSSID valid bit
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_stream5_mmussid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmussid() const { uint32_t value = static_cast<uint32_t>(bits.mmussid); return value;}
    CONSTEXPR void set_mmussid(uint32_t value) { assert(static_cast<uint32_t>(value) < 1048576u); bits.mmussid = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mmussidv() const { uint32_t value = static_cast<uint32_t>(bits.mmussidv); return value;}
    CONSTEXPR void set_mmussidv(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmussidv = static_cast<uint32_t>(value); }
#endif
};


//
// sec_stream5_attr_control_r - Stream 5 - Attribute Control
//
struct sec_stream5_attr_control_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t attrlocked : 1; // Stream attributes locked
            uint32_t reserved0 : 31;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_stream5_attr_control_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_attrlocked() const { uint32_t value = static_cast<uint32_t>(bits.attrlocked); return value;}
    CONSTEXPR void set_attrlocked(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.attrlocked = static_cast<uint32_t>(value); }
#endif
};


//
// sec_stream5_memattr_r - Stream 5 - Memory Attributes
//
struct sec_stream5_memattr_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t memattr : 4; // Memory attributes
            uint32_t reserved0 : 28;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_stream5_memattr_r(uint32_t init=0) : word(init) {}
    CONSTEXPR memory_attributes_t get_memattr() const { memory_attributes_t value = static_cast<memory_attributes_t>(bits.memattr); return value;}
    CONSTEXPR void set_memattr(memory_attributes_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.memattr = static_cast<uint32_t>(value); }
#endif
};


//
// sec_stream6_stream_security_r - Stream 6 - Security State
//
struct sec_stream6_stream_security_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusecsid : 1; // MMU stream security state
            uint32_t protns : 1; // AXI stream security state
            uint32_t reserved0 : 30;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_stream6_stream_security_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmusecsid() const { uint32_t value = static_cast<uint32_t>(bits.mmusecsid); return value;}
    CONSTEXPR void set_mmusecsid(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmusecsid = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_protns() const { uint32_t value = static_cast<uint32_t>(bits.protns); return value;}
    CONSTEXPR void set_protns(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.protns = static_cast<uint32_t>(value); }
#endif
};


//
// sec_stream6_nsaid_r - Stream 6 - Non-secure Access Identifier
//
struct sec_stream6_nsaid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t nsaid : 4; // Non-Secure Address Identifier
            uint32_t reserved0 : 28;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_stream6_nsaid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_nsaid() const { uint32_t value = static_cast<uint32_t>(bits.nsaid); return value;}
    CONSTEXPR void set_nsaid(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.nsaid = static_cast<uint32_t>(value); }
#endif
};


//
// sec_stream6_mmusid_r - Stream 6 - MMU Stream Identifier
//
struct sec_stream6_mmusid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusid : 32; // MMU Stream ID (actual width is implementation defined)
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_stream6_mmusid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmusid() const { uint32_t value = static_cast<uint32_t>(bits.mmusid); return value;}
    CONSTEXPR void set_mmusid(uint32_t value) { bits.mmusid = static_cast<uint32_t>(value); }
#endif
};


//
// sec_stream6_mmussid_r - Stream 6 - MMU Sub-stream Stream Identifier
//
struct sec_stream6_mmussid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmussid : 20; // MMU Sub-Stream ID (actual width is implementation defined)
            uint32_t reserved0 : 11;
            uint32_t mmussidv : 1; // MMUSSID valid bit
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_stream6_mmussid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmussid() const { uint32_t value = static_cast<uint32_t>(bits.mmussid); return value;}
    CONSTEXPR void set_mmussid(uint32_t value) { assert(static_cast<uint32_t>(value) < 1048576u); bits.mmussid = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mmussidv() const { uint32_t value = static_cast<uint32_t>(bits.mmussidv); return value;}
    CONSTEXPR void set_mmussidv(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmussidv = static_cast<uint32_t>(value); }
#endif
};


//
// sec_stream6_attr_control_r - Stream 6 - Attribute Control
//
struct sec_stream6_attr_control_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t attrlocked : 1; // Stream attributes locked
            uint32_t reserved0 : 31;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_stream6_attr_control_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_attrlocked() const { uint32_t value = static_cast<uint32_t>(bits.attrlocked); return value;}
    CONSTEXPR void set_attrlocked(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.attrlocked = static_cast<uint32_t>(value); }
#endif
};


//
// sec_stream6_memattr_r - Stream 6 - Memory Attributes
//
struct sec_stream6_memattr_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t memattr : 4; // Memory attributes
            uint32_t reserved0 : 28;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_stream6_memattr_r(uint32_t init=0) : word(init) {}
    CONSTEXPR memory_attributes_t get_memattr() const { memory_attributes_t value = static_cast<memory_attributes_t>(bits.memattr); return value;}
    CONSTEXPR void set_memattr(memory_attributes_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.memattr = static_cast<uint32_t>(value); }
#endif
};


//
// sec_stream7_stream_security_r - Stream 7 - Security State
//
struct sec_stream7_stream_security_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusecsid : 1; // MMU stream security state
            uint32_t protns : 1; // AXI stream security state
            uint32_t reserved0 : 30;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_stream7_stream_security_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmusecsid() const { uint32_t value = static_cast<uint32_t>(bits.mmusecsid); return value;}
    CONSTEXPR void set_mmusecsid(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmusecsid = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_protns() const { uint32_t value = static_cast<uint32_t>(bits.protns); return value;}
    CONSTEXPR void set_protns(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.protns = static_cast<uint32_t>(value); }
#endif
};


//
// sec_stream7_nsaid_r - Stream 7 - Non-secure Access Identifier
//
struct sec_stream7_nsaid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t nsaid : 4; // Non-Secure Address Identifier
            uint32_t reserved0 : 28;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_stream7_nsaid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_nsaid() const { uint32_t value = static_cast<uint32_t>(bits.nsaid); return value;}
    CONSTEXPR void set_nsaid(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.nsaid = static_cast<uint32_t>(value); }
#endif
};


//
// sec_stream7_mmusid_r - Stream 7 - MMU Stream Identifier
//
struct sec_stream7_mmusid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusid : 32; // MMU Stream ID (actual width is implementation defined)
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_stream7_mmusid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmusid() const { uint32_t value = static_cast<uint32_t>(bits.mmusid); return value;}
    CONSTEXPR void set_mmusid(uint32_t value) { bits.mmusid = static_cast<uint32_t>(value); }
#endif
};


//
// sec_stream7_mmussid_r - Stream 7 - MMU Sub-stream Stream Identifier
//
struct sec_stream7_mmussid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmussid : 20; // MMU Sub-Stream ID (actual width is implementation defined)
            uint32_t reserved0 : 11;
            uint32_t mmussidv : 1; // MMUSSID valid bit
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_stream7_mmussid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmussid() const { uint32_t value = static_cast<uint32_t>(bits.mmussid); return value;}
    CONSTEXPR void set_mmussid(uint32_t value) { assert(static_cast<uint32_t>(value) < 1048576u); bits.mmussid = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mmussidv() const { uint32_t value = static_cast<uint32_t>(bits.mmussidv); return value;}
    CONSTEXPR void set_mmussidv(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmussidv = static_cast<uint32_t>(value); }
#endif
};


//
// sec_stream7_attr_control_r - Stream 7 - Attribute Control
//
struct sec_stream7_attr_control_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t attrlocked : 1; // Stream attributes locked
            uint32_t reserved0 : 31;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_stream7_attr_control_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_attrlocked() const { uint32_t value = static_cast<uint32_t>(bits.attrlocked); return value;}
    CONSTEXPR void set_attrlocked(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.attrlocked = static_cast<uint32_t>(value); }
#endif
};


//
// sec_stream7_memattr_r - Stream 7 - Memory Attributes
//
struct sec_stream7_memattr_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t memattr : 4; // Memory attributes
            uint32_t reserved0 : 28;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_stream7_memattr_r(uint32_t init=0) : word(init) {}
    CONSTEXPR memory_attributes_t get_memattr() const { memory_attributes_t value = static_cast<memory_attributes_t>(bits.memattr); return value;}
    CONSTEXPR void set_memattr(memory_attributes_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.memattr = static_cast<uint32_t>(value); }
#endif
};


//
// sec_stream8_stream_security_r - Stream 8 - Security State
//
struct sec_stream8_stream_security_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusecsid : 1; // MMU stream security state
            uint32_t protns : 1; // AXI stream security state
            uint32_t reserved0 : 30;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_stream8_stream_security_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmusecsid() const { uint32_t value = static_cast<uint32_t>(bits.mmusecsid); return value;}
    CONSTEXPR void set_mmusecsid(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmusecsid = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_protns() const { uint32_t value = static_cast<uint32_t>(bits.protns); return value;}
    CONSTEXPR void set_protns(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.protns = static_cast<uint32_t>(value); }
#endif
};


//
// sec_stream8_nsaid_r - Stream 8 - Non-secure Access Identifier
//
struct sec_stream8_nsaid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t nsaid : 4; // Non-Secure Address Identifier
            uint32_t reserved0 : 28;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_stream8_nsaid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_nsaid() const { uint32_t value = static_cast<uint32_t>(bits.nsaid); return value;}
    CONSTEXPR void set_nsaid(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.nsaid = static_cast<uint32_t>(value); }
#endif
};


//
// sec_stream8_mmusid_r - Stream 8 - MMU Stream Identifier
//
struct sec_stream8_mmusid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusid : 32; // MMU Stream ID (actual width is implementation defined)
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_stream8_mmusid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmusid() const { uint32_t value = static_cast<uint32_t>(bits.mmusid); return value;}
    CONSTEXPR void set_mmusid(uint32_t value) { bits.mmusid = static_cast<uint32_t>(value); }
#endif
};


//
// sec_stream8_mmussid_r - Stream 8 - MMU Sub-stream Stream Identifier
//
struct sec_stream8_mmussid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmussid : 20; // MMU Sub-Stream ID (actual width is implementation defined)
            uint32_t reserved0 : 11;
            uint32_t mmussidv : 1; // MMUSSID valid bit
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_stream8_mmussid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmussid() const { uint32_t value = static_cast<uint32_t>(bits.mmussid); return value;}
    CONSTEXPR void set_mmussid(uint32_t value) { assert(static_cast<uint32_t>(value) < 1048576u); bits.mmussid = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mmussidv() const { uint32_t value = static_cast<uint32_t>(bits.mmussidv); return value;}
    CONSTEXPR void set_mmussidv(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mmussidv = static_cast<uint32_t>(value); }
#endif
};


//
// sec_stream8_attr_control_r - Stream 8 - Attribute Control
//
struct sec_stream8_attr_control_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t attrlocked : 1; // Stream attributes locked
            uint32_t reserved0 : 31;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_stream8_attr_control_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_attrlocked() const { uint32_t value = static_cast<uint32_t>(bits.attrlocked); return value;}
    CONSTEXPR void set_attrlocked(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.attrlocked = static_cast<uint32_t>(value); }
#endif
};


//
// sec_stream8_memattr_r - Stream 8 - Memory Attributes
//
struct sec_stream8_memattr_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t memattr : 4; // Memory attributes
            uint32_t reserved0 : 28;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_stream8_memattr_r(uint32_t init=0) : word(init) {}
    CONSTEXPR memory_attributes_t get_memattr() const { memory_attributes_t value = static_cast<memory_attributes_t>(bits.memattr); return value;}
    CONSTEXPR void set_memattr(memory_attributes_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.memattr = static_cast<uint32_t>(value); }
#endif
};


//
// sec_npu_id_r - NPU ID register
//
struct sec_npu_id_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t version_status : 4; // Status of the NPU release
            uint32_t version_minor : 4; // Minor release version number
            uint32_t version_major : 4; // Major release version number
            uint32_t product_major : 4; // Product identifier
            uint32_t arch_rev : 8; // Architecture patch revision
            uint32_t arch_minor : 4; // Architecture minor revision
            uint32_t arch_major : 4; // Architecture major revision
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_npu_id_r(uint32_t init=0) : word(init) {}
    CONSTEXPR npu_version_status_t get_version_status() const { npu_version_status_t value = static_cast<npu_version_status_t>(bits.version_status); return value;}
    CONSTEXPR void set_version_status(npu_version_status_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.version_status = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_version_minor() const { uint32_t value = static_cast<uint32_t>(bits.version_minor); return value;}
    CONSTEXPR void set_version_minor(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.version_minor = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_version_major() const { uint32_t value = static_cast<uint32_t>(bits.version_major); return value;}
    CONSTEXPR void set_version_major(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.version_major = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_product_major() const { uint32_t value = static_cast<uint32_t>(bits.product_major); return value;}
    CONSTEXPR void set_product_major(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.product_major = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_arch_rev() const { uint32_t value = static_cast<uint32_t>(bits.arch_rev); return value;}
    CONSTEXPR void set_arch_rev(uint32_t value) { assert(static_cast<uint32_t>(value) < 256u); bits.arch_rev = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_arch_minor() const { uint32_t value = static_cast<uint32_t>(bits.arch_minor); return value;}
    CONSTEXPR void set_arch_minor(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.arch_minor = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_arch_major() const { uint32_t value = static_cast<uint32_t>(bits.arch_major); return value;}
    CONSTEXPR void set_arch_major(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.arch_major = static_cast<uint32_t>(value); }
#endif
};


//
// sec_unit_count_r - Units present count
//
struct sec_unit_count_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t quad_count : 8; // Number of quads
            uint32_t engines_per_quad : 8; // Number of engines per quad
            uint32_t dfc_emc_per_engine : 4; // Number of memory controllers per engine
            uint32_t reserved0 : 12;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_unit_count_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_quad_count() const { uint32_t value = static_cast<uint32_t>(bits.quad_count); return value;}
    CONSTEXPR void set_quad_count(uint32_t value) { assert(static_cast<uint32_t>(value) < 256u); bits.quad_count = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_engines_per_quad() const { uint32_t value = static_cast<uint32_t>(bits.engines_per_quad); return value;}
    CONSTEXPR void set_engines_per_quad(uint32_t value) { assert(static_cast<uint32_t>(value) < 256u); bits.engines_per_quad = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_dfc_emc_per_engine() const { uint32_t value = static_cast<uint32_t>(bits.dfc_emc_per_engine); return value;}
    CONSTEXPR void set_dfc_emc_per_engine(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.dfc_emc_per_engine = static_cast<uint32_t>(value); }
#endif
};


//
// sec_mce_features_r - MCE features
//
struct sec_mce_features_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t ifm_generated_per_engine : 4; // IFMs sent to broadcast network per engine
            uint32_t reserved0 : 4;
            uint32_t ofm_generated_per_engine : 4; // OFMs generated per Engine
            uint32_t mce_num_macs : 8; // Number of MAC units per MCE
            uint32_t mce_num_acc : 8; // Number of accumulators per MAC unit
            uint32_t winograd_support : 1; // Winograd funcationality present
            uint32_t tsu_16bit_sequence_support : 1; // TSU support for automatically sequencing 16 bit IFM and weights
            uint32_t ofm_scaling_16bit_support : 1; // Hardware support for scaling results from 16-bit operations
            uint32_t reserved1 : 1;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_mce_features_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_ifm_generated_per_engine() const { uint32_t value = static_cast<uint32_t>(bits.ifm_generated_per_engine); return value;}
    CONSTEXPR void set_ifm_generated_per_engine(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.ifm_generated_per_engine = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ofm_generated_per_engine() const { uint32_t value = static_cast<uint32_t>(bits.ofm_generated_per_engine); return value;}
    CONSTEXPR void set_ofm_generated_per_engine(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.ofm_generated_per_engine = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mce_num_macs() const { uint32_t value = static_cast<uint32_t>(bits.mce_num_macs); return value;}
    CONSTEXPR void set_mce_num_macs(uint32_t value) { assert(static_cast<uint32_t>(value) < 256u); bits.mce_num_macs = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mce_num_acc() const { uint32_t value = static_cast<uint32_t>(bits.mce_num_acc); return value;}
    CONSTEXPR void set_mce_num_acc(uint32_t value) { assert(static_cast<uint32_t>(value) < 256u); bits.mce_num_acc = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_winograd_support() const { uint32_t value = static_cast<uint32_t>(bits.winograd_support); return value;}
    CONSTEXPR void set_winograd_support(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.winograd_support = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_tsu_16bit_sequence_support() const { uint32_t value = static_cast<uint32_t>(bits.tsu_16bit_sequence_support); return value;}
    CONSTEXPR void set_tsu_16bit_sequence_support(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.tsu_16bit_sequence_support = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ofm_scaling_16bit_support() const { uint32_t value = static_cast<uint32_t>(bits.ofm_scaling_16bit_support); return value;}
    CONSTEXPR void set_ofm_scaling_16bit_support(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ofm_scaling_16bit_support = static_cast<uint32_t>(value); }
#endif
};


//
// sec_dfc_features_r - DFC features
//
struct sec_dfc_features_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t dfc_mem_size_per_emc : 16; // DFC memory size per EMC
            uint32_t bank_count : 6; // Number of banks in DFC memory
            uint32_t activation_compression : 4; // Version of activation compression supported
            uint32_t reserved0 : 6;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_dfc_features_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_dfc_mem_size_per_emc() const { uint32_t value = static_cast<uint32_t>(bits.dfc_mem_size_per_emc); return (value << 12);}
    CONSTEXPR void set_dfc_mem_size_per_emc(uint32_t value) { assert(static_cast<uint32_t>((value >> 12)) < 65536u); bits.dfc_mem_size_per_emc = static_cast<uint32_t>((value >> 12)); }
    CONSTEXPR uint32_t get_bank_count() const { uint32_t value = static_cast<uint32_t>(bits.bank_count); return value;}
    CONSTEXPR void set_bank_count(uint32_t value) { assert(static_cast<uint32_t>(value) < 64u); bits.bank_count = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_activation_compression() const { uint32_t value = static_cast<uint32_t>(bits.activation_compression); return value;}
    CONSTEXPR void set_activation_compression(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.activation_compression = static_cast<uint32_t>(value); }
#endif
};


//
// sec_ple_features_r - PLE features
//
struct sec_ple_features_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t ple_input_mem_size : 8; // PLE input memory size
            uint32_t ple_output_mem_size : 8; // PLE output memory size
            uint32_t ple_vrf_mem_size : 8; // PLE vector register file memory size
            uint32_t ple_mem_size : 8; // PLE base memory size
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_ple_features_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_ple_input_mem_size() const { uint32_t value = static_cast<uint32_t>(bits.ple_input_mem_size); return (value << 8);}
    CONSTEXPR void set_ple_input_mem_size(uint32_t value) { assert(static_cast<uint32_t>((value >> 8)) < 256u); bits.ple_input_mem_size = static_cast<uint32_t>((value >> 8)); }
    CONSTEXPR uint32_t get_ple_output_mem_size() const { uint32_t value = static_cast<uint32_t>(bits.ple_output_mem_size); return (value << 8);}
    CONSTEXPR void set_ple_output_mem_size(uint32_t value) { assert(static_cast<uint32_t>((value >> 8)) < 256u); bits.ple_output_mem_size = static_cast<uint32_t>((value >> 8)); }
    CONSTEXPR uint32_t get_ple_vrf_mem_size() const { uint32_t value = static_cast<uint32_t>(bits.ple_vrf_mem_size); return (value << 4);}
    CONSTEXPR void set_ple_vrf_mem_size(uint32_t value) { assert(static_cast<uint32_t>((value >> 4)) < 256u); bits.ple_vrf_mem_size = static_cast<uint32_t>((value >> 4)); }
    CONSTEXPR uint32_t get_ple_mem_size() const { uint32_t value = static_cast<uint32_t>(bits.ple_mem_size); return (value << 8);}
    CONSTEXPR void set_ple_mem_size(uint32_t value) { assert(static_cast<uint32_t>((value >> 8)) < 256u); bits.ple_mem_size = static_cast<uint32_t>((value >> 8)); }
#endif
};


//
// sec_wd_features_r - Weight Decoder features
//
struct sec_wd_features_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t buffer_size : 8; // Weight decoder buffer size
            uint32_t max_dim : 8; // Weight decoder max dimension
            uint32_t compression_version : 4; // Version of weight compression implemented
            uint32_t reserved0 : 12;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_wd_features_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_buffer_size() const { uint32_t value = static_cast<uint32_t>(bits.buffer_size); return value;}
    CONSTEXPR void set_buffer_size(uint32_t value) { assert(static_cast<uint32_t>(value) < 256u); bits.buffer_size = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_max_dim() const { uint32_t value = static_cast<uint32_t>(bits.max_dim); return value;}
    CONSTEXPR void set_max_dim(uint32_t value) { assert(static_cast<uint32_t>(value) < 256u); bits.max_dim = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_compression_version() const { uint32_t value = static_cast<uint32_t>(bits.compression_version); return value;}
    CONSTEXPR void set_compression_version(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.compression_version = static_cast<uint32_t>(value); }
#endif
};


//
// sec_vector_engine_features_r - PLE VE features
//
struct sec_vector_engine_features_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t vector_engine_version : 4; // Version of the vector engine implemented
            uint32_t ple_lanes : 2; // Number of lanes in the PLE
            uint32_t reserved0 : 26;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_vector_engine_features_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_vector_engine_version() const { uint32_t value = static_cast<uint32_t>(bits.vector_engine_version); return value;}
    CONSTEXPR void set_vector_engine_version(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.vector_engine_version = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ple_lanes() const { uint32_t value = static_cast<uint32_t>(bits.ple_lanes); return (value + 1);}
    CONSTEXPR void set_ple_lanes(uint32_t value) { assert(static_cast<uint32_t>((value - 1)) < 4u); bits.ple_lanes = static_cast<uint32_t>((value - 1)); }
#endif
};


//
// sec_ecoid_r - Encoding describing ECOs implemented
//
struct sec_ecoid_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t ecoid : 12; // Field for describing ECOs implemented
            uint32_t reserved0 : 20;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_ecoid_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_ecoid() const { uint32_t value = static_cast<uint32_t>(bits.ecoid); return value;}
    CONSTEXPR void set_ecoid(uint32_t value) { assert(static_cast<uint32_t>(value) < 4096u); bits.ecoid = static_cast<uint32_t>(value); }
#endif
};


//
// sec_streamid_width_r - Configured StreamID widths
//
struct sec_streamid_width_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t mmusid_w : 5; // Configured width of StreamID (AxMMUSID)
            uint32_t reserved0 : 3;
            uint32_t mmussid_w : 5; // Configured width of SubstreamID (AxMMUSSID)
            uint32_t reserved1 : 19;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR sec_streamid_width_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_mmusid_w() const { uint32_t value = static_cast<uint32_t>(bits.mmusid_w); return (value + 1);}
    CONSTEXPR void set_mmusid_w(uint32_t value) { assert(static_cast<uint32_t>((value - 1)) < 32u); bits.mmusid_w = static_cast<uint32_t>((value - 1)); }
    CONSTEXPR uint32_t get_mmussid_w() const { uint32_t value = static_cast<uint32_t>(bits.mmussid_w); return (value + 1);}
    CONSTEXPR void set_mmussid_w(uint32_t value) { assert(static_cast<uint32_t>((value - 1)) < 32u); bits.mmussid_w = static_cast<uint32_t>((value - 1)); }
#endif
};


//
// stripe_bank_status_r - Stripe current register bank status
//
struct stripe_bank_status_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t bank_busy : 1; // Current bank's registers are occupied.  Goes to 1 when START is issued, returns when there is a register bank available for writing.  Writing bank registers while BANK_BUSY=1 results in an error.  Writes to this bit have no effect
            uint32_t current_bank : 1; // Specifies which bank is currently being read/written (if forced, it is the bank that would be read/written if reads/writes were not forced)
            uint32_t bank0_status : 2; // Bank 0 status
            uint32_t bank1_status : 2; // Bank 1 status
            uint32_t reserved0 : 26;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR stripe_bank_status_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_bank_busy() const { uint32_t value = static_cast<uint32_t>(bits.bank_busy); return value;}
    CONSTEXPR void set_bank_busy(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.bank_busy = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_current_bank() const { uint32_t value = static_cast<uint32_t>(bits.current_bank); return value;}
    CONSTEXPR void set_current_bank(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.current_bank = static_cast<uint32_t>(value); }
    CONSTEXPR bank_status_t get_bank0_status() const { bank_status_t value = static_cast<bank_status_t>(bits.bank0_status); return value;}
    CONSTEXPR void set_bank0_status(bank_status_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.bank0_status = static_cast<uint32_t>(value); }
    CONSTEXPR bank_status_t get_bank1_status() const { bank_status_t value = static_cast<bank_status_t>(bits.bank1_status); return value;}
    CONSTEXPR void set_bank1_status(bank_status_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.bank1_status = static_cast<uint32_t>(value); }
#endif
};


//
// block_bank_status_r - Block current register bank status
//
struct block_bank_status_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t bank_busy : 1; // Current bank's registers are occupied.  Goes to 1 when BLOCK_BANK_CONTROL.START is issued, returns when there is a register bank available for writing.  Writing block registers while BANK_BUSY=1 results in an error.  Writes to this bit have no effect
            uint32_t current_bank : 2; // Specifies which bank is currently being read/written (if forced, it is the bank that would be read/written if reads/writes were not forced)
            uint32_t bank0_status : 2; // Bank 0 status
            uint32_t bank1_status : 2; // Bank 1 status
            uint32_t bank2_status : 2; // Bank 2 status
            uint32_t bank3_status : 2; // Bank 3 status
            uint32_t reserved0 : 21;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR block_bank_status_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_bank_busy() const { uint32_t value = static_cast<uint32_t>(bits.bank_busy); return value;}
    CONSTEXPR void set_bank_busy(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.bank_busy = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_current_bank() const { uint32_t value = static_cast<uint32_t>(bits.current_bank); return value;}
    CONSTEXPR void set_current_bank(uint32_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.current_bank = static_cast<uint32_t>(value); }
    CONSTEXPR bank_status_t get_bank0_status() const { bank_status_t value = static_cast<bank_status_t>(bits.bank0_status); return value;}
    CONSTEXPR void set_bank0_status(bank_status_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.bank0_status = static_cast<uint32_t>(value); }
    CONSTEXPR bank_status_t get_bank1_status() const { bank_status_t value = static_cast<bank_status_t>(bits.bank1_status); return value;}
    CONSTEXPR void set_bank1_status(bank_status_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.bank1_status = static_cast<uint32_t>(value); }
    CONSTEXPR bank_status_t get_bank2_status() const { bank_status_t value = static_cast<bank_status_t>(bits.bank2_status); return value;}
    CONSTEXPR void set_bank2_status(bank_status_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.bank2_status = static_cast<uint32_t>(value); }
    CONSTEXPR bank_status_t get_bank3_status() const { bank_status_t value = static_cast<bank_status_t>(bits.bank3_status); return value;}
    CONSTEXPR void set_bank3_status(bank_status_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.bank3_status = static_cast<uint32_t>(value); }
#endif
};


//
// tsu_control_r - TSU controls
//
struct tsu_control_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t tsu_block_issue_dis : 1; // Disable the TSU programing of dynamic block registers and initiating block execution in the CEs
            uint32_t reserved0 : 31;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR tsu_control_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_tsu_block_issue_dis() const { uint32_t value = static_cast<uint32_t>(bits.tsu_block_issue_dis); return value;}
    CONSTEXPR void set_tsu_block_issue_dis(uint32_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.tsu_block_issue_dis = static_cast<uint32_t>(value); }
#endif
};


//
// tsu_event_r - TSU event register
//
struct tsu_event_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t ple_buffer_freed : 1; // MCEIF buffer has been freed (collated from all enabled PLEs)
            uint32_t reserved0 : 1;
            uint32_t ple_layer_done : 1; // All enabled PLEs completed a layer
            uint32_t ple_stripe_done : 1; // All enabled PLEs completed a stripe
            uint32_t ple_block_done : 1; // All enabled PLEs completed a block
            uint32_t udma_or_clear_done : 1; // A PLE uDMA instruction or SRAM_CLEAR operation has completed
            uint32_t reserved1 : 1;
            uint32_t dma_done : 1; // A DMA command has completed
            uint32_t reserved2 : 1;
            uint32_t mce_stripe_done : 1; // All enabled MCEs completed a stripe
            uint32_t mce_block_done : 1; // All enabled MCEs completed a block
            uint32_t reserved3 : 21;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR tsu_event_r(uint32_t init=0) : word(init) {}
    CONSTEXPR event_t get_ple_buffer_freed() const { event_t value = static_cast<event_t>(bits.ple_buffer_freed); return value;}
    CONSTEXPR void set_ple_buffer_freed(event_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ple_buffer_freed = static_cast<uint32_t>(value); }
    CONSTEXPR event_t get_ple_layer_done() const { event_t value = static_cast<event_t>(bits.ple_layer_done); return value;}
    CONSTEXPR void set_ple_layer_done(event_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ple_layer_done = static_cast<uint32_t>(value); }
    CONSTEXPR event_t get_ple_stripe_done() const { event_t value = static_cast<event_t>(bits.ple_stripe_done); return value;}
    CONSTEXPR void set_ple_stripe_done(event_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ple_stripe_done = static_cast<uint32_t>(value); }
    CONSTEXPR event_t get_ple_block_done() const { event_t value = static_cast<event_t>(bits.ple_block_done); return value;}
    CONSTEXPR void set_ple_block_done(event_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ple_block_done = static_cast<uint32_t>(value); }
    CONSTEXPR event_t get_udma_or_clear_done() const { event_t value = static_cast<event_t>(bits.udma_or_clear_done); return value;}
    CONSTEXPR void set_udma_or_clear_done(event_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.udma_or_clear_done = static_cast<uint32_t>(value); }
    CONSTEXPR event_t get_dma_done() const { event_t value = static_cast<event_t>(bits.dma_done); return value;}
    CONSTEXPR void set_dma_done(event_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.dma_done = static_cast<uint32_t>(value); }
    CONSTEXPR event_t get_mce_stripe_done() const { event_t value = static_cast<event_t>(bits.mce_stripe_done); return value;}
    CONSTEXPR void set_mce_stripe_done(event_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mce_stripe_done = static_cast<uint32_t>(value); }
    CONSTEXPR event_t get_mce_block_done() const { event_t value = static_cast<event_t>(bits.mce_block_done); return value;}
    CONSTEXPR void set_mce_block_done(event_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mce_block_done = static_cast<uint32_t>(value); }
#endif
};


//
// tsu_event_msk_r - Mask TSU events to NCU MCU
//
struct tsu_event_msk_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t ple_buffer_freed_mask : 1; // Mask for MCEIF buffer freed event
            uint32_t reserved0 : 1;
            uint32_t ple_layer_done_mask : 1; // Mask for PLE layer done event
            uint32_t ple_stripe_done_mask : 1; // Mask for PLE stripe done event
            uint32_t ple_block_done_mask : 1; // Mask for PLE block done event
            uint32_t udma_or_clear_done_mask : 1; // Mask for PLE uDMA or (SRAM) clear done event
            uint32_t reserved1 : 1;
            uint32_t dma_done_mask : 1; // Mask for DMA command done event
            uint32_t reserved2 : 1;
            uint32_t mce_stripe_done_mask : 1; // Mask for MCE stripe done event
            uint32_t mce_block_done_mask : 1; // Mask for MCE block done event
            uint32_t reserved3 : 21;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR tsu_event_msk_r(uint32_t init=0) : word(init) {}
    CONSTEXPR event_mask_t get_ple_buffer_freed_mask() const { event_mask_t value = static_cast<event_mask_t>(bits.ple_buffer_freed_mask); return value;}
    CONSTEXPR void set_ple_buffer_freed_mask(event_mask_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ple_buffer_freed_mask = static_cast<uint32_t>(value); }
    CONSTEXPR event_mask_t get_ple_layer_done_mask() const { event_mask_t value = static_cast<event_mask_t>(bits.ple_layer_done_mask); return value;}
    CONSTEXPR void set_ple_layer_done_mask(event_mask_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ple_layer_done_mask = static_cast<uint32_t>(value); }
    CONSTEXPR event_mask_t get_ple_stripe_done_mask() const { event_mask_t value = static_cast<event_mask_t>(bits.ple_stripe_done_mask); return value;}
    CONSTEXPR void set_ple_stripe_done_mask(event_mask_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ple_stripe_done_mask = static_cast<uint32_t>(value); }
    CONSTEXPR event_mask_t get_ple_block_done_mask() const { event_mask_t value = static_cast<event_mask_t>(bits.ple_block_done_mask); return value;}
    CONSTEXPR void set_ple_block_done_mask(event_mask_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.ple_block_done_mask = static_cast<uint32_t>(value); }
    CONSTEXPR event_mask_t get_udma_or_clear_done_mask() const { event_mask_t value = static_cast<event_mask_t>(bits.udma_or_clear_done_mask); return value;}
    CONSTEXPR void set_udma_or_clear_done_mask(event_mask_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.udma_or_clear_done_mask = static_cast<uint32_t>(value); }
    CONSTEXPR event_mask_t get_dma_done_mask() const { event_mask_t value = static_cast<event_mask_t>(bits.dma_done_mask); return value;}
    CONSTEXPR void set_dma_done_mask(event_mask_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.dma_done_mask = static_cast<uint32_t>(value); }
    CONSTEXPR event_mask_t get_mce_stripe_done_mask() const { event_mask_t value = static_cast<event_mask_t>(bits.mce_stripe_done_mask); return value;}
    CONSTEXPR void set_mce_stripe_done_mask(event_mask_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mce_stripe_done_mask = static_cast<uint32_t>(value); }
    CONSTEXPR event_mask_t get_mce_block_done_mask() const { event_mask_t value = static_cast<event_mask_t>(bits.mce_block_done_mask); return value;}
    CONSTEXPR void set_mce_block_done_mask(event_mask_t value) { assert(static_cast<uint32_t>(value) < 2u); bits.mce_block_done_mask = static_cast<uint32_t>(value); }
#endif
};


//
// tsu_debug_counters_engine0_r - Debug counters for PLE events sent to the TSU
//
struct tsu_debug_counters_engine0_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t ple_block_done_event_count : 5; // Number of PLE block done events for this engine received by the TSU
            uint32_t reserved0 : 2;
            uint32_t ple_layer_done_event_count : 2; // Number of PLE layer done events for this engine received by the TSU
            uint32_t ple_mcu_txev_event_count : 2; // Number of MCU TXEV events for this engine received by the TSU
            uint32_t ple_buffer_freed_count : 5; // Number of buffer freed events for this engine received by the TSU
            uint32_t mce_block_done_event_count : 4; // Number of MCE block done events for this engine received by the TSU
            uint32_t ple_stripe_done_event_count : 5; // Number of PLE stripe done events for this engine received by the TSU
            uint32_t mce_stripe_done_event_count : 5; // Number of MCE stripe done events for this engine received by the TSU
            uint32_t reserved1 : 2;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR tsu_debug_counters_engine0_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_ple_block_done_event_count() const { uint32_t value = static_cast<uint32_t>(bits.ple_block_done_event_count); return value;}
    CONSTEXPR void set_ple_block_done_event_count(uint32_t value) { assert(static_cast<uint32_t>(value) < 32u); bits.ple_block_done_event_count = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ple_layer_done_event_count() const { uint32_t value = static_cast<uint32_t>(bits.ple_layer_done_event_count); return value;}
    CONSTEXPR void set_ple_layer_done_event_count(uint32_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.ple_layer_done_event_count = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ple_mcu_txev_event_count() const { uint32_t value = static_cast<uint32_t>(bits.ple_mcu_txev_event_count); return value;}
    CONSTEXPR void set_ple_mcu_txev_event_count(uint32_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.ple_mcu_txev_event_count = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ple_buffer_freed_count() const { uint32_t value = static_cast<uint32_t>(bits.ple_buffer_freed_count); return value;}
    CONSTEXPR void set_ple_buffer_freed_count(uint32_t value) { assert(static_cast<uint32_t>(value) < 32u); bits.ple_buffer_freed_count = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mce_block_done_event_count() const { uint32_t value = static_cast<uint32_t>(bits.mce_block_done_event_count); return value;}
    CONSTEXPR void set_mce_block_done_event_count(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.mce_block_done_event_count = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ple_stripe_done_event_count() const { uint32_t value = static_cast<uint32_t>(bits.ple_stripe_done_event_count); return value;}
    CONSTEXPR void set_ple_stripe_done_event_count(uint32_t value) { assert(static_cast<uint32_t>(value) < 32u); bits.ple_stripe_done_event_count = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mce_stripe_done_event_count() const { uint32_t value = static_cast<uint32_t>(bits.mce_stripe_done_event_count); return value;}
    CONSTEXPR void set_mce_stripe_done_event_count(uint32_t value) { assert(static_cast<uint32_t>(value) < 32u); bits.mce_stripe_done_event_count = static_cast<uint32_t>(value); }
#endif
};


//
// tsu_debug_counters_engine1_r - Debug counters for PLE events sent to the TSU
//
struct tsu_debug_counters_engine1_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t ple_block_done_event_count : 5; // Number of PLE block done events for this engine received by the TSU
            uint32_t reserved0 : 2;
            uint32_t ple_layer_done_event_count : 2; // Number of PLE layer done events for this engine received by the TSU
            uint32_t ple_mcu_txev_event_count : 2; // Number of MCU TXEV events for this engine received by the TSU
            uint32_t ple_buffer_freed_count : 5; // Number of buffer freed events for this engine received by the TSU
            uint32_t mce_block_done_event_count : 4; // Number of MCE block done events for this engine received by the TSU
            uint32_t ple_stripe_done_event_count : 5; // Number of PLE stripe done events for this engine received by the TSU
            uint32_t mce_stripe_done_event_count : 5; // Number of MCE stripe done events for this engine received by the TSU
            uint32_t reserved1 : 2;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR tsu_debug_counters_engine1_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_ple_block_done_event_count() const { uint32_t value = static_cast<uint32_t>(bits.ple_block_done_event_count); return value;}
    CONSTEXPR void set_ple_block_done_event_count(uint32_t value) { assert(static_cast<uint32_t>(value) < 32u); bits.ple_block_done_event_count = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ple_layer_done_event_count() const { uint32_t value = static_cast<uint32_t>(bits.ple_layer_done_event_count); return value;}
    CONSTEXPR void set_ple_layer_done_event_count(uint32_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.ple_layer_done_event_count = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ple_mcu_txev_event_count() const { uint32_t value = static_cast<uint32_t>(bits.ple_mcu_txev_event_count); return value;}
    CONSTEXPR void set_ple_mcu_txev_event_count(uint32_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.ple_mcu_txev_event_count = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ple_buffer_freed_count() const { uint32_t value = static_cast<uint32_t>(bits.ple_buffer_freed_count); return value;}
    CONSTEXPR void set_ple_buffer_freed_count(uint32_t value) { assert(static_cast<uint32_t>(value) < 32u); bits.ple_buffer_freed_count = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mce_block_done_event_count() const { uint32_t value = static_cast<uint32_t>(bits.mce_block_done_event_count); return value;}
    CONSTEXPR void set_mce_block_done_event_count(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.mce_block_done_event_count = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ple_stripe_done_event_count() const { uint32_t value = static_cast<uint32_t>(bits.ple_stripe_done_event_count); return value;}
    CONSTEXPR void set_ple_stripe_done_event_count(uint32_t value) { assert(static_cast<uint32_t>(value) < 32u); bits.ple_stripe_done_event_count = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mce_stripe_done_event_count() const { uint32_t value = static_cast<uint32_t>(bits.mce_stripe_done_event_count); return value;}
    CONSTEXPR void set_mce_stripe_done_event_count(uint32_t value) { assert(static_cast<uint32_t>(value) < 32u); bits.mce_stripe_done_event_count = static_cast<uint32_t>(value); }
#endif
};


//
// tsu_debug_counters_engine2_r - Debug counters for PLE events sent to the TSU
//
struct tsu_debug_counters_engine2_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t ple_block_done_event_count : 5; // Number of PLE block done events for this engine received by the TSU
            uint32_t reserved0 : 2;
            uint32_t ple_layer_done_event_count : 2; // Number of PLE layer done events for this engine received by the TSU
            uint32_t ple_mcu_txev_event_count : 2; // Number of MCU TXEV events for this engine received by the TSU
            uint32_t ple_buffer_freed_count : 5; // Number of buffer freed events for this engine received by the TSU
            uint32_t mce_block_done_event_count : 4; // Number of MCE block done events for this engine received by the TSU
            uint32_t ple_stripe_done_event_count : 5; // Number of PLE stripe done events for this engine received by the TSU
            uint32_t mce_stripe_done_event_count : 5; // Number of MCE stripe done events for this engine received by the TSU
            uint32_t reserved1 : 2;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR tsu_debug_counters_engine2_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_ple_block_done_event_count() const { uint32_t value = static_cast<uint32_t>(bits.ple_block_done_event_count); return value;}
    CONSTEXPR void set_ple_block_done_event_count(uint32_t value) { assert(static_cast<uint32_t>(value) < 32u); bits.ple_block_done_event_count = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ple_layer_done_event_count() const { uint32_t value = static_cast<uint32_t>(bits.ple_layer_done_event_count); return value;}
    CONSTEXPR void set_ple_layer_done_event_count(uint32_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.ple_layer_done_event_count = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ple_mcu_txev_event_count() const { uint32_t value = static_cast<uint32_t>(bits.ple_mcu_txev_event_count); return value;}
    CONSTEXPR void set_ple_mcu_txev_event_count(uint32_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.ple_mcu_txev_event_count = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ple_buffer_freed_count() const { uint32_t value = static_cast<uint32_t>(bits.ple_buffer_freed_count); return value;}
    CONSTEXPR void set_ple_buffer_freed_count(uint32_t value) { assert(static_cast<uint32_t>(value) < 32u); bits.ple_buffer_freed_count = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mce_block_done_event_count() const { uint32_t value = static_cast<uint32_t>(bits.mce_block_done_event_count); return value;}
    CONSTEXPR void set_mce_block_done_event_count(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.mce_block_done_event_count = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ple_stripe_done_event_count() const { uint32_t value = static_cast<uint32_t>(bits.ple_stripe_done_event_count); return value;}
    CONSTEXPR void set_ple_stripe_done_event_count(uint32_t value) { assert(static_cast<uint32_t>(value) < 32u); bits.ple_stripe_done_event_count = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mce_stripe_done_event_count() const { uint32_t value = static_cast<uint32_t>(bits.mce_stripe_done_event_count); return value;}
    CONSTEXPR void set_mce_stripe_done_event_count(uint32_t value) { assert(static_cast<uint32_t>(value) < 32u); bits.mce_stripe_done_event_count = static_cast<uint32_t>(value); }
#endif
};


//
// tsu_debug_counters_engine3_r - Debug counters for PLE events sent to the TSU
//
struct tsu_debug_counters_engine3_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t ple_block_done_event_count : 5; // Number of PLE block done events for this engine received by the TSU
            uint32_t reserved0 : 2;
            uint32_t ple_layer_done_event_count : 2; // Number of PLE layer done events for this engine received by the TSU
            uint32_t ple_mcu_txev_event_count : 2; // Number of MCU TXEV events for this engine received by the TSU
            uint32_t ple_buffer_freed_count : 5; // Number of buffer freed events for this engine received by the TSU
            uint32_t mce_block_done_event_count : 4; // Number of MCE block done events for this engine received by the TSU
            uint32_t ple_stripe_done_event_count : 5; // Number of PLE stripe done events for this engine received by the TSU
            uint32_t mce_stripe_done_event_count : 5; // Number of MCE stripe done events for this engine received by the TSU
            uint32_t reserved1 : 2;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR tsu_debug_counters_engine3_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_ple_block_done_event_count() const { uint32_t value = static_cast<uint32_t>(bits.ple_block_done_event_count); return value;}
    CONSTEXPR void set_ple_block_done_event_count(uint32_t value) { assert(static_cast<uint32_t>(value) < 32u); bits.ple_block_done_event_count = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ple_layer_done_event_count() const { uint32_t value = static_cast<uint32_t>(bits.ple_layer_done_event_count); return value;}
    CONSTEXPR void set_ple_layer_done_event_count(uint32_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.ple_layer_done_event_count = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ple_mcu_txev_event_count() const { uint32_t value = static_cast<uint32_t>(bits.ple_mcu_txev_event_count); return value;}
    CONSTEXPR void set_ple_mcu_txev_event_count(uint32_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.ple_mcu_txev_event_count = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ple_buffer_freed_count() const { uint32_t value = static_cast<uint32_t>(bits.ple_buffer_freed_count); return value;}
    CONSTEXPR void set_ple_buffer_freed_count(uint32_t value) { assert(static_cast<uint32_t>(value) < 32u); bits.ple_buffer_freed_count = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mce_block_done_event_count() const { uint32_t value = static_cast<uint32_t>(bits.mce_block_done_event_count); return value;}
    CONSTEXPR void set_mce_block_done_event_count(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.mce_block_done_event_count = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ple_stripe_done_event_count() const { uint32_t value = static_cast<uint32_t>(bits.ple_stripe_done_event_count); return value;}
    CONSTEXPR void set_ple_stripe_done_event_count(uint32_t value) { assert(static_cast<uint32_t>(value) < 32u); bits.ple_stripe_done_event_count = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mce_stripe_done_event_count() const { uint32_t value = static_cast<uint32_t>(bits.mce_stripe_done_event_count); return value;}
    CONSTEXPR void set_mce_stripe_done_event_count(uint32_t value) { assert(static_cast<uint32_t>(value) < 32u); bits.mce_stripe_done_event_count = static_cast<uint32_t>(value); }
#endif
};


//
// tsu_debug_counters_engine4_r - Debug counters for PLE events sent to the TSU
//
struct tsu_debug_counters_engine4_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t ple_block_done_event_count : 5; // Number of PLE block done events for this engine received by the TSU
            uint32_t reserved0 : 2;
            uint32_t ple_layer_done_event_count : 2; // Number of PLE layer done events for this engine received by the TSU
            uint32_t ple_mcu_txev_event_count : 2; // Number of MCU TXEV events for this engine received by the TSU
            uint32_t ple_buffer_freed_count : 5; // Number of buffer freed events for this engine received by the TSU
            uint32_t mce_block_done_event_count : 4; // Number of MCE block done events for this engine received by the TSU
            uint32_t ple_stripe_done_event_count : 5; // Number of PLE stripe done events for this engine received by the TSU
            uint32_t mce_stripe_done_event_count : 5; // Number of MCE stripe done events for this engine received by the TSU
            uint32_t reserved1 : 2;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR tsu_debug_counters_engine4_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_ple_block_done_event_count() const { uint32_t value = static_cast<uint32_t>(bits.ple_block_done_event_count); return value;}
    CONSTEXPR void set_ple_block_done_event_count(uint32_t value) { assert(static_cast<uint32_t>(value) < 32u); bits.ple_block_done_event_count = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ple_layer_done_event_count() const { uint32_t value = static_cast<uint32_t>(bits.ple_layer_done_event_count); return value;}
    CONSTEXPR void set_ple_layer_done_event_count(uint32_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.ple_layer_done_event_count = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ple_mcu_txev_event_count() const { uint32_t value = static_cast<uint32_t>(bits.ple_mcu_txev_event_count); return value;}
    CONSTEXPR void set_ple_mcu_txev_event_count(uint32_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.ple_mcu_txev_event_count = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ple_buffer_freed_count() const { uint32_t value = static_cast<uint32_t>(bits.ple_buffer_freed_count); return value;}
    CONSTEXPR void set_ple_buffer_freed_count(uint32_t value) { assert(static_cast<uint32_t>(value) < 32u); bits.ple_buffer_freed_count = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mce_block_done_event_count() const { uint32_t value = static_cast<uint32_t>(bits.mce_block_done_event_count); return value;}
    CONSTEXPR void set_mce_block_done_event_count(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.mce_block_done_event_count = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ple_stripe_done_event_count() const { uint32_t value = static_cast<uint32_t>(bits.ple_stripe_done_event_count); return value;}
    CONSTEXPR void set_ple_stripe_done_event_count(uint32_t value) { assert(static_cast<uint32_t>(value) < 32u); bits.ple_stripe_done_event_count = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mce_stripe_done_event_count() const { uint32_t value = static_cast<uint32_t>(bits.mce_stripe_done_event_count); return value;}
    CONSTEXPR void set_mce_stripe_done_event_count(uint32_t value) { assert(static_cast<uint32_t>(value) < 32u); bits.mce_stripe_done_event_count = static_cast<uint32_t>(value); }
#endif
};


//
// tsu_debug_counters_engine5_r - Debug counters for PLE events sent to the TSU
//
struct tsu_debug_counters_engine5_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t ple_block_done_event_count : 5; // Number of PLE block done events for this engine received by the TSU
            uint32_t reserved0 : 2;
            uint32_t ple_layer_done_event_count : 2; // Number of PLE layer done events for this engine received by the TSU
            uint32_t ple_mcu_txev_event_count : 2; // Number of MCU TXEV events for this engine received by the TSU
            uint32_t ple_buffer_freed_count : 5; // Number of buffer freed events for this engine received by the TSU
            uint32_t mce_block_done_event_count : 4; // Number of MCE block done events for this engine received by the TSU
            uint32_t ple_stripe_done_event_count : 5; // Number of PLE stripe done events for this engine received by the TSU
            uint32_t mce_stripe_done_event_count : 5; // Number of MCE stripe done events for this engine received by the TSU
            uint32_t reserved1 : 2;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR tsu_debug_counters_engine5_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_ple_block_done_event_count() const { uint32_t value = static_cast<uint32_t>(bits.ple_block_done_event_count); return value;}
    CONSTEXPR void set_ple_block_done_event_count(uint32_t value) { assert(static_cast<uint32_t>(value) < 32u); bits.ple_block_done_event_count = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ple_layer_done_event_count() const { uint32_t value = static_cast<uint32_t>(bits.ple_layer_done_event_count); return value;}
    CONSTEXPR void set_ple_layer_done_event_count(uint32_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.ple_layer_done_event_count = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ple_mcu_txev_event_count() const { uint32_t value = static_cast<uint32_t>(bits.ple_mcu_txev_event_count); return value;}
    CONSTEXPR void set_ple_mcu_txev_event_count(uint32_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.ple_mcu_txev_event_count = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ple_buffer_freed_count() const { uint32_t value = static_cast<uint32_t>(bits.ple_buffer_freed_count); return value;}
    CONSTEXPR void set_ple_buffer_freed_count(uint32_t value) { assert(static_cast<uint32_t>(value) < 32u); bits.ple_buffer_freed_count = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mce_block_done_event_count() const { uint32_t value = static_cast<uint32_t>(bits.mce_block_done_event_count); return value;}
    CONSTEXPR void set_mce_block_done_event_count(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.mce_block_done_event_count = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ple_stripe_done_event_count() const { uint32_t value = static_cast<uint32_t>(bits.ple_stripe_done_event_count); return value;}
    CONSTEXPR void set_ple_stripe_done_event_count(uint32_t value) { assert(static_cast<uint32_t>(value) < 32u); bits.ple_stripe_done_event_count = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mce_stripe_done_event_count() const { uint32_t value = static_cast<uint32_t>(bits.mce_stripe_done_event_count); return value;}
    CONSTEXPR void set_mce_stripe_done_event_count(uint32_t value) { assert(static_cast<uint32_t>(value) < 32u); bits.mce_stripe_done_event_count = static_cast<uint32_t>(value); }
#endif
};


//
// tsu_debug_counters_engine6_r - Debug counters for PLE events sent to the TSU
//
struct tsu_debug_counters_engine6_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t ple_block_done_event_count : 5; // Number of PLE block done events for this engine received by the TSU
            uint32_t reserved0 : 2;
            uint32_t ple_layer_done_event_count : 2; // Number of PLE layer done events for this engine received by the TSU
            uint32_t ple_mcu_txev_event_count : 2; // Number of MCU TXEV events for this engine received by the TSU
            uint32_t ple_buffer_freed_count : 5; // Number of buffer freed events for this engine received by the TSU
            uint32_t mce_block_done_event_count : 4; // Number of MCE block done events for this engine received by the TSU
            uint32_t ple_stripe_done_event_count : 5; // Number of PLE stripe done events for this engine received by the TSU
            uint32_t mce_stripe_done_event_count : 5; // Number of MCE stripe done events for this engine received by the TSU
            uint32_t reserved1 : 2;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR tsu_debug_counters_engine6_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_ple_block_done_event_count() const { uint32_t value = static_cast<uint32_t>(bits.ple_block_done_event_count); return value;}
    CONSTEXPR void set_ple_block_done_event_count(uint32_t value) { assert(static_cast<uint32_t>(value) < 32u); bits.ple_block_done_event_count = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ple_layer_done_event_count() const { uint32_t value = static_cast<uint32_t>(bits.ple_layer_done_event_count); return value;}
    CONSTEXPR void set_ple_layer_done_event_count(uint32_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.ple_layer_done_event_count = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ple_mcu_txev_event_count() const { uint32_t value = static_cast<uint32_t>(bits.ple_mcu_txev_event_count); return value;}
    CONSTEXPR void set_ple_mcu_txev_event_count(uint32_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.ple_mcu_txev_event_count = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ple_buffer_freed_count() const { uint32_t value = static_cast<uint32_t>(bits.ple_buffer_freed_count); return value;}
    CONSTEXPR void set_ple_buffer_freed_count(uint32_t value) { assert(static_cast<uint32_t>(value) < 32u); bits.ple_buffer_freed_count = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mce_block_done_event_count() const { uint32_t value = static_cast<uint32_t>(bits.mce_block_done_event_count); return value;}
    CONSTEXPR void set_mce_block_done_event_count(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.mce_block_done_event_count = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ple_stripe_done_event_count() const { uint32_t value = static_cast<uint32_t>(bits.ple_stripe_done_event_count); return value;}
    CONSTEXPR void set_ple_stripe_done_event_count(uint32_t value) { assert(static_cast<uint32_t>(value) < 32u); bits.ple_stripe_done_event_count = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mce_stripe_done_event_count() const { uint32_t value = static_cast<uint32_t>(bits.mce_stripe_done_event_count); return value;}
    CONSTEXPR void set_mce_stripe_done_event_count(uint32_t value) { assert(static_cast<uint32_t>(value) < 32u); bits.mce_stripe_done_event_count = static_cast<uint32_t>(value); }
#endif
};


//
// tsu_debug_counters_engine7_r - Debug counters for PLE events sent to the TSU
//
struct tsu_debug_counters_engine7_r
{
    union
    {
        uint32_t word;
        struct
        {
            uint32_t ple_block_done_event_count : 5; // Number of PLE block done events for this engine received by the TSU
            uint32_t reserved0 : 2;
            uint32_t ple_layer_done_event_count : 2; // Number of PLE layer done events for this engine received by the TSU
            uint32_t ple_mcu_txev_event_count : 2; // Number of MCU TXEV events for this engine received by the TSU
            uint32_t ple_buffer_freed_count : 5; // Number of buffer freed events for this engine received by the TSU
            uint32_t mce_block_done_event_count : 4; // Number of MCE block done events for this engine received by the TSU
            uint32_t ple_stripe_done_event_count : 5; // Number of PLE stripe done events for this engine received by the TSU
            uint32_t mce_stripe_done_event_count : 5; // Number of MCE stripe done events for this engine received by the TSU
            uint32_t reserved1 : 2;
        } bits;
    };
#ifdef __cplusplus
    CONSTEXPR tsu_debug_counters_engine7_r(uint32_t init=0) : word(init) {}
    CONSTEXPR uint32_t get_ple_block_done_event_count() const { uint32_t value = static_cast<uint32_t>(bits.ple_block_done_event_count); return value;}
    CONSTEXPR void set_ple_block_done_event_count(uint32_t value) { assert(static_cast<uint32_t>(value) < 32u); bits.ple_block_done_event_count = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ple_layer_done_event_count() const { uint32_t value = static_cast<uint32_t>(bits.ple_layer_done_event_count); return value;}
    CONSTEXPR void set_ple_layer_done_event_count(uint32_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.ple_layer_done_event_count = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ple_mcu_txev_event_count() const { uint32_t value = static_cast<uint32_t>(bits.ple_mcu_txev_event_count); return value;}
    CONSTEXPR void set_ple_mcu_txev_event_count(uint32_t value) { assert(static_cast<uint32_t>(value) < 4u); bits.ple_mcu_txev_event_count = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ple_buffer_freed_count() const { uint32_t value = static_cast<uint32_t>(bits.ple_buffer_freed_count); return value;}
    CONSTEXPR void set_ple_buffer_freed_count(uint32_t value) { assert(static_cast<uint32_t>(value) < 32u); bits.ple_buffer_freed_count = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mce_block_done_event_count() const { uint32_t value = static_cast<uint32_t>(bits.mce_block_done_event_count); return value;}
    CONSTEXPR void set_mce_block_done_event_count(uint32_t value) { assert(static_cast<uint32_t>(value) < 16u); bits.mce_block_done_event_count = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_ple_stripe_done_event_count() const { uint32_t value = static_cast<uint32_t>(bits.ple_stripe_done_event_count); return value;}
    CONSTEXPR void set_ple_stripe_done_event_count(uint32_t value) { assert(static_cast<uint32_t>(value) < 32u); bits.ple_stripe_done_event_count = static_cast<uint32_t>(value); }
    CONSTEXPR uint32_t get_mce_stripe_done_event_count() const { uint32_t value = static_cast<uint32_t>(bits.mce_stripe_done_event_count); return value;}
    CONSTEXPR void set_mce_stripe_done_event_count(uint32_t value) { assert(static_cast<uint32_t>(value) < 32u); bits.mce_stripe_done_event_count = static_cast<uint32_t>(value); }
#endif
};

