//
// Copyright Â© 2018-2023 Arm Limited.
// SPDX-License-Identifier: Apache-2.0
//

#include "GgfParser.hpp"

#include "GlobalParameters.hpp"
#include "SystemTestsUtils.hpp"

#include <ethosn_utils/Strings.hpp>

#include <algorithm>
#include <cassert>
#include <fstream>
#include <iostream>
#include <list>
#include <sstream>
#include <string>

#define METADATA(metadata) static const char* metadata = "#" #metadata

using namespace ethosn::support_library;

namespace ethosn
{
namespace system_tests
{

std::string g_DefaultConvolutionAlgorithm;

namespace
{
DataType StrToDataType(const std::string& str)
{
    if (str == "i8")
    {
        return DataType::S8;
    }
    else if (str == "u8")
    {
        return DataType::U8;
    }
    else
    {
        std::string errorMessage = "Error: Type '" + str + "' is not yet supported";
        throw std::invalid_argument(errorMessage);
    }
}

ResizeAlgorithm UIntToResizeAlgorithm(const uint32_t algo)
{
    switch (algo)
    {
        case (0U):
        {
            return ResizeAlgorithm::NEAREST_NEIGHBOUR;
        }
        case (2U):
        {
            return ResizeAlgorithm::BILINEAR;
        }
        default:
        {
            std::string errorMessage = "Error: Resize Algorithm '" + std::to_string(algo) + "' is not supported";
            throw std::invalid_argument(errorMessage);
        }
    }
}

ResizeMode UIntToResizeMode(const uint32_t mode)
{
    switch (mode)
    {
        case (0U):
        {
            return ResizeMode::DROP;
        }
        case (1U):
        {
            return ResizeMode::REPEAT;
        }
        default:
        {
            std::string errorMessage = "Error: Resize Mode '" + std::to_string(mode) + "' is not supported";
            throw std::invalid_argument(errorMessage);
        }
    }
}

METADATA(Convolution_Algorithm);
METADATA(EnableIntermediateCompression);
METADATA(AutoFrozen);
METADATA(InputMin);
METADATA(InputMax);
METADATA(InputStd);
METADATA(InputMean);
METADATA(Input_Zero_Percentage);
METADATA(Input_No_Entries);
METADATA(Global_OutputMin);
METADATA(Global_OutputMax);
METADATA(NPU_Input_Tensor_Format);
METADATA(Input_Precision);
METADATA(Weight_Precision);
METADATA(NPU_Output_Tensor_Format);
METADATA(Weight_Compression_Mask);
METADATA(Weight_Compression_Lut);
METADATA(Seed);
METADATA(Block_Config);
METADATA(DisableDistributionCheck);
METADATA(AutogeneratedGGFfile);
METADATA(EnablePerChannelQuantization);
METADATA(InputQuantizationZeroPoint);
METADATA(InputQuantizationScale);
METADATA(WeightQuantizationZeroPoint);
METADATA(WeightQuantizationScale);
METADATA(OutputQuantizationZeroPoint);
METADATA(OutputQuantizationScale);
}    // namespace

GgfParser::GgfParser(std::istream& ggfFile, LayerData& layerData)
    : m_LayerData(layerData)
    , m_GgfFile(ggfFile)
    , m_InputLayerNames()
    , m_OutputLayerNames()
{}

class GgfParsedLayer
{
public:
    GgfParsedLayer(const std::string& line, const char separator = ' ')
        : m_Properties()
    {
        std::stringstream layerStream(line);

        // Split the line into parts, separated by commas
        std::string mostRecentKey;
        while (!layerStream.eof())
        {
            std::string part;
            getline(layerStream, part, ',');
            part = ethosn::utils::Trim(part);

            // Most parts are of the form 'name value'.
            // Some names have separators(spaces) in them, so split on the *last* separator(space) in the part rather than the first.
            size_t idx = part.rfind(separator);
            if (idx != std::string::npos)
            {
                std::string name  = ethosn::utils::Trim(part.substr(0, idx));
                std::string value = ethosn::utils::Trim(part.substr(idx + 1));

                m_Properties[name] = std::vector<std::string>{ value };
                mostRecentKey      = name;
            }
            else
            {
                // If this part doesn't have a space in it then it is a further value to the previous key
                // (e.g. "shape 1, 32, 32, 16")
                if (mostRecentKey == "")
                {
                    // e.g. "conv, blarg" would be invalid
                    throw std::invalid_argument("First part of the line needs to have a key and a value");
                }
                m_Properties[mostRecentKey].push_back(part);
            }
        }
    }

    uint32_t GetUInt(const char* key)
    {
        auto it = m_Properties.find(key);
        if (it == m_Properties.end())
        {
            throw std::logic_error((std::string("Missing key: ") + key).c_str());
        }
        return static_cast<uint32_t>(std::stoul(it->second[0]));
    }

    uint32_t GetUInt(const char* key, uint32_t defaultValue)
    {
        auto it = m_Properties.find(key);
        if (it == m_Properties.end())
        {
            return defaultValue;
        }
        return static_cast<uint32_t>(std::stoul(it->second[0]));
    }

    std::vector<uint32_t> GetUIntArray(const char* key)
    {
        auto it = m_Properties.find(key);
        if (it == m_Properties.end())
        {
            throw std::logic_error((std::string("Missing key: ") + key).c_str());
        }
        const std::vector<std::string>& v = it->second;
        std::vector<uint32_t> result;
        std::transform(v.begin(), v.end(), std::back_inserter(result),
                       [](const std::string& s) { return static_cast<uint32_t>(std::stoul(s)); });
        return result;
    }

    int32_t GetInt(const char* key)
    {
        auto it = m_Properties.find(key);
        if (it == m_Properties.end())
        {
            throw std::logic_error((std::string("Missing key: ") + key).c_str());
        }
        return std::stoi(it->second[0]);
    }

    int32_t GetInt(const char* key, int32_t defaultValue)
    {
        auto it = m_Properties.find(key);
        if (it == m_Properties.end())
        {
            return defaultValue;
        }
        return std::stoi(it->second[0]);
    }

    float GetFloat(const char* key)
    {
        auto it = m_Properties.find(key);
        if (it == m_Properties.end())
        {
            throw std::logic_error((std::string("Missing key: ") + key).c_str());
        }
        return std::stof(it->second[0]);
    }

    float GetFloat(const char* key, float defaultValue)
    {
        auto it = m_Properties.find(key);
        if (it == m_Properties.end())
        {
            return defaultValue;
        }
        return std::stof(it->second[0]);
    }

    std::string GetStr(const char* key)
    {
        auto it = m_Properties.find(key);
        if (it == m_Properties.end())
        {
            throw std::logic_error((std::string("Missing key: ") + key).c_str());
        }
        return it->second[0];
    }

    WeightParams GetWeightParams()
    {
        float weightMin            = GetFloat("weight filler min", g_DefaultWeightMin);
        float weightMax            = GetFloat("weight filler max", g_DefaultWeightMax);
        float weightMean           = GetFloat("weight filler mean", g_DefaultWeightGaussianMean);
        float weightStd            = GetFloat("weight filler std", g_DefaultWeightGaussianStd);
        float weightZeroPercentage = GetFloat("weight filler zero_percentage", g_DefaultWeightZeroPercentage);
        int32_t weightNoEntries    = GetInt("weight filler no_entries", g_DefaultWeightNoEntries);
        bool isUserDefinedRange    = Exists("weight filler min") || Exists("weight filler max");

        return WeightParams{ weightMin,       weightMax,         weightMean, weightStd, weightZeroPercentage,
                             weightNoEntries, isUserDefinedRange };
    }

    OutputParams GetOutputParams()
    {
        float outputMin = GetFloat("output_min", g_UnsetFloat);
        float outputMax = GetFloat("output_max", g_UnsetFloat);
        return OutputParams{ outputMin, outputMax };
    }

    bool Exists(const char* key)
    {
        return m_Properties.find(key) != m_Properties.end();
    }

    /// Gets the values of the given key interpreted as a TensorShape.
    TensorShape GetTensorShape(const char* key)
    {
        auto it = m_Properties.find(key);
        if (it == m_Properties.end())
        {
            throw std::logic_error((std::string("Missing key: ") + key).c_str());
        }
        const std::vector<std::string>& v = it->second;
        return TensorShape{ static_cast<uint32_t>(std::stoul(v[0])), static_cast<uint32_t>(std::stoul(v[1])),
                            static_cast<uint32_t>(std::stoul(v[2])), static_cast<uint32_t>(std::stoul(v[3])) };
    }

private:
    std::map<std::string, std::vector<std::string>> m_Properties;
};

void GgfParser::OnMetadata(std::string& line)
{
    // Remove whitespace from line for robustness
    line.erase(std::remove_if(line.begin(), line.end(), isspace), line.end());

    GgfParsedLayer parsedLayer(line, ':');

    if (parsedLayer.Exists(Convolution_Algorithm))
    {
        std::string convAlgorithm = parsedLayer.GetStr(Convolution_Algorithm);
        g_Logger.Debug("GgfParser::OnMetadata: %s: %s", Convolution_Algorithm, convAlgorithm.c_str());
        ConvolutionAlgorithm algo = ParseConvolutionAlgorithm(convAlgorithm.c_str());
        m_LayerData.SetConvolutionAlgorithm(algo);
    }
    else if (parsedLayer.Exists(EnableIntermediateCompression))
    {
        const std::string value = parsedLayer.GetStr(EnableIntermediateCompression);
        if (value == "true")
        {
            m_LayerData.SetIntermediateCompression(true);
        }
        else if (value == "false")
        {
            m_LayerData.SetIntermediateCompression(false);
        }
        else
        {
            throw std::invalid_argument("#EnableIntermediateCompression be 'true' or 'false'");
        }
    }
    else if (parsedLayer.Exists(AutoFrozen))
    {
        g_Logger.Debug("GgfParser::OnMetadata: Warning: %s metadata was used but is not yet supported", AutoFrozen);
    }
    else if (parsedLayer.Exists(InputMin))
    {
        float inputMin = parsedLayer.GetFloat(InputMin);
        g_Logger.Debug("GgfParser::OnMetadata: %s: %f", InputMin, inputMin);
        m_LayerData.SetInputMin(inputMin);
    }
    else if (parsedLayer.Exists(InputMax))
    {
        float inputMax = parsedLayer.GetFloat(InputMax);
        g_Logger.Debug("GgfParser::OnMetadata: %s: %f", InputMax, inputMax);
        m_LayerData.SetInputMax(inputMax);
    }
    // Handle the ggf metadata tag for InputStd
    else if (parsedLayer.Exists(InputStd))
    {
        float inputStd = parsedLayer.GetFloat(InputStd);
        g_Logger.Debug("GgfParser::OnMetadata: %s: %f", InputStd, inputStd);
        m_LayerData.SetGaussianInputStd(inputStd);
    }
    // Handle the ggf metadata tag for InputMean
    else if (parsedLayer.Exists(InputMean))
    {
        float inputMean = parsedLayer.GetFloat(InputMean);
        g_Logger.Debug("GgfParser::OnMetadata: %s: %f", InputMean, inputMean);
        m_LayerData.SetGaussianInputMean(inputMean);
    }
    // Handle the ggf metadata tag for Input_Zero_Percentage
    else if (parsedLayer.Exists(Input_Zero_Percentage))
    {
        float inputZeroPercentage = parsedLayer.GetFloat(Input_Zero_Percentage);
        g_Logger.Debug("GgfParser::OnMetadata: %s: %f", Input_Zero_Percentage, inputZeroPercentage);
        m_LayerData.SetInputZeroPercentage(inputZeroPercentage);
    }
    // Handle the ggf metadata tag for Input_No_Entries
    else if (parsedLayer.Exists(Input_No_Entries))
    {
        int32_t inputNoEnties = parsedLayer.GetInt(Input_No_Entries);
        g_Logger.Debug("GgfParser::OnMetadata: %s: %d", Input_No_Entries, inputNoEnties);
        if (!IsValidNoEntries(inputNoEnties))
        {
            throw std::invalid_argument("#Input_No_Entries value must be between 2 and 255");
        }
        m_LayerData.SetInputNoEntries(inputNoEnties);
    }
    // Handle the ggf metadata tag for Global_OutputMin
    else if (parsedLayer.Exists(Global_OutputMin))
    {
        float globalOutputMin = parsedLayer.GetFloat(Global_OutputMin);
        g_Logger.Debug("GgfParser::OnMetadata: %s: %f", Global_OutputMin, globalOutputMin);
        m_LayerData.SetGlobalOutputMin(globalOutputMin);
        m_LayerData.SetUseGlobalOutputMinMax(true);
    }
    // Handle the ggf metadata tag for Global_OutputMax
    else if (parsedLayer.Exists(Global_OutputMax))
    {
        float globalOutputMax = parsedLayer.GetFloat(Global_OutputMax);
        g_Logger.Debug("GgfParser::OnMetadata: %s: %f", Global_OutputMax, globalOutputMax);
        m_LayerData.SetGlobalOutputMax(globalOutputMax);
        m_LayerData.SetUseGlobalOutputMinMax(true);
    }
    // Handle the ggf metadata tag for NPU_Input_Tensor_Format
    else if (parsedLayer.Exists(NPU_Input_Tensor_Format))
    {
        std::string format = parsedLayer.GetStr(NPU_Input_Tensor_Format);

        g_Logger.Debug("GgfParser::OnMetadata: %s: %s", NPU_Input_Tensor_Format, format.c_str());

        if (format == "NHWC")
        {
            m_LayerData.SetInputTensorFormat(DataFormat::NHWC);
        }
        else if (format != "NHWCB")
        {
            throw std::invalid_argument("#NPU_Input_Tensor_Formatst be NHWCB or NHWC");
        }
        // else using default NHWCB format
    }
    else if (parsedLayer.Exists(Input_Precision))
    {
        std::string inputDataType = parsedLayer.GetStr(Input_Precision);
        g_Logger.Debug("GgfParser::OnMetadata: %s %s", Input_Precision, inputDataType.c_str());
        m_LayerData.SetInputDataType(StrToDataType(inputDataType));
    }
    else if (parsedLayer.Exists(Weight_Precision))
    {
        std::string weightPrecision = parsedLayer.GetStr(Weight_Precision);
        g_Logger.Debug("GgfParser::OnMetadata: %s: %s", Weight_Precision, weightPrecision.c_str());
        m_LayerData.SetWeightDataType(StrToDataType(weightPrecision));
    }

    // Handle the ggf metadata tag for ETHOSN_Output_Tensor_Format
    else if (parsedLayer.Exists(NPU_Output_Tensor_Format))
    {
        std::string format = parsedLayer.GetStr(NPU_Output_Tensor_Format);

        g_Logger.Debug("GgfParser::OnMetadata: %s: %s", NPU_Output_Tensor_Format, format.c_str());

        if (format == "NHWC")
        {
            m_LayerData.SetOutputTensorFormat(DataFormat::NHWC);
        }
        else if (format != "NHWCB")
        {
            throw std::invalid_argument("#NPU_Output_Tensor_Format must be NHWCB or NHWC");
        }
        // else using default NHWCB format
    }
    else if (parsedLayer.Exists(Weight_Compression_Mask))
    {
        g_Logger.Debug("GgfParser::OnMetadata: Warning: %s metadata was used but is not yet supported",
                       Weight_Compression_Mask);
    }
    else if (parsedLayer.Exists(Weight_Compression_Lut))
    {
        g_Logger.Debug("GgfParser::OnMetadata: Warning: %s metadata was used but is not yet supported",
                       Weight_Compression_Lut);
    }

    // Handle the ggf metadata tag for Seed
    else if (parsedLayer.Exists(Seed))
    {
        uint32_t seed = parsedLayer.GetUInt(Seed);
        g_Logger.Debug("GgfParser::OnMetadata: %s: %u", Seed, seed);
        m_LayerData.SetSeed(seed);
        srand(seed);
    }

    else if (parsedLayer.Exists(Block_Config))
    {
        std::string blockConfigs = parsedLayer.GetStr(Block_Config);
        g_Logger.Debug("GgfParser::OnMetadata: %s: %s", Block_Config, blockConfigs.c_str());
        m_LayerData.SetBlockConfigs(blockConfigs);
    }

    else if (parsedLayer.Exists(DisableDistributionCheck))
    {
        std::string value = parsedLayer.GetStr(DisableDistributionCheck);

        if (value == "true")
        {
            m_LayerData.SetVerifyDistribution(false);
        }
    }

    else if (parsedLayer.Exists(EnablePerChannelQuantization))
    {
        std::string perChannelQuantValue = parsedLayer.GetStr(EnablePerChannelQuantization);

        if (perChannelQuantValue == "true")
        {
            if (m_LayerData.GetWeightDataType<ethosn::support_library::DataType>() !=
                ethosn::support_library::DataType::INT8_QUANTIZED)
            {
                throw std::invalid_argument("Error: per-channel quantization only allowed for signed weights");
            }
            m_LayerData.SetPerChannelQuantization(true);
        }
        else
        {
            m_LayerData.SetPerChannelQuantization(false);
        }
    }
    else if (parsedLayer.Exists(AutogeneratedGGFfile))
    {
        //nothing to do
    }
    else if (parsedLayer.Exists(InputQuantizationZeroPoint))
    {
        int zeroPoint = parsedLayer.GetInt(InputQuantizationZeroPoint);
        m_LayerData.SetInputQuantZeroPoint(zeroPoint);
        m_LayerData.SetUserInputQuantZeroPoint(true);
    }
    else if (parsedLayer.Exists(InputQuantizationScale))
    {
        float scale = parsedLayer.GetFloat(InputQuantizationScale);
        m_LayerData.SetInputQuantScale(scale);
        m_LayerData.SetUserInputQuantScale(true);
    }
    else if (parsedLayer.Exists(WeightQuantizationZeroPoint))
    {
        int zeroPoint = parsedLayer.GetInt(WeightQuantizationZeroPoint);
        m_LayerData.SetWeightQuantZeroPoint(zeroPoint);
        m_LayerData.SetUserWeightQuantZeroPoint(true);
    }
    else if (parsedLayer.Exists(WeightQuantizationScale))
    {
        float scale = parsedLayer.GetFloat(WeightQuantizationScale);
        m_LayerData.SetWeightQuantScale(scale);
        m_LayerData.SetUserWeightQuantScale(true);
    }
    else if (parsedLayer.Exists(OutputQuantizationZeroPoint))
    {
        int zeroPoint = parsedLayer.GetInt(OutputQuantizationZeroPoint);
        m_LayerData.SetOutputQuantZeroPoint(zeroPoint);
        m_LayerData.SetUserOutputQuantZeroPoint(true);
    }
    else if (parsedLayer.Exists(OutputQuantizationScale))
    {
        float scale = parsedLayer.GetFloat(OutputQuantizationScale);
        m_LayerData.SetOutputQuantScale(scale);
        m_LayerData.SetUserOutputQuantScale(true);
    }
    else
    {
        std::string errorMessage = "Error: Meta data line '" + line + "' is not recognised.";
        throw std::invalid_argument(errorMessage);
    }
}

void GgfParser::ParseNetwork(void)
{
    std::string line;
    uint32_t lineNumber = 0;
    // As we parse the graph we maintain a set of layer outputs that have nothing connected to them.
    // Once we have finished parsing the entire graph anything left in this set will be an output from the network.
    std::set<std::string> danglingOutputs;
    while (getline(m_GgfFile, line))
    {
        ++lineNumber;
        size_t firstNonWhitespaceIdx = line.find_first_not_of(" \t\r\n");
        size_t firstColonIdx         = line.find(":");
        if (firstNonWhitespaceIdx == std::string::npos)
        {
            // Blank line
            continue;
        }
        else if (utils::StartsWith(line.substr(firstNonWhitespaceIdx), "//"))
        {
            // Comment line
            continue;
        }
        else if (line[firstNonWhitespaceIdx] == '#' && firstColonIdx == std::string::npos)
        {
            // Comment line
            continue;
        }
        else if (line[firstNonWhitespaceIdx] == '#')
        {
            OnMetadata(line);
            continue;
        }

        std::string layerType = line.substr(0, line.find(" "));

        std::stringstream lineStream(line);

        GgfParsedLayer parsedLayer(line);
        std::string layerName = parsedLayer.GetStr("name");
        // Remember this layer as it may be an output of the network if nothing connects to it.
        // Don't do this for explicit output layers as an output layer cannot have an output connected to it!
        // Don't do this for relu, leakyrelu  or sigmoid layers because they will always be dangling
        // because referring to their input actually refers to them (a design choice of the ggf format).
        // Don't do this for split because it has multiple outputs and is handled specially in that case.
        const std::unordered_set<std::string> notDanglingOutputsLayers = { "output",  "relu",  "leakyrelu",
                                                                           "sigmoid", "split", "tanh" };
        if (notDanglingOutputsLayers.find(layerType) == notDanglingOutputsLayers.end())
        {
            danglingOutputs.insert(layerName);
        }

        if (layerType == "input")
        {
            TensorShape shape = parsedLayer.GetTensorShape("shape");

            g_Logger.Debug("GgfParser::AddInput: %s shape={%d,%d,%d,%d}", layerName.c_str(), shape[0], shape[1],
                           shape[2], shape[3]);

            AddInput(layerName, shape);
        }
        else if (layerType == "const")
        {
            TensorShape shape       = parsedLayer.GetTensorShape("shape");
            const float constantMin = parsedLayer.GetFloat("constant_min", g_DefaultConstantMin);
            const float constantMax = parsedLayer.GetFloat("constant_max", g_DefaultConstantMax);

            g_Logger.Debug("GgfParser::AddConstant: %s shape={%d,%d,%d,%d}", layerName.c_str(), shape[0], shape[1],
                           shape[2], shape[3]);

            AddConstant(layerName, shape, constantMin, constantMax);
        }
        else if ((layerType == "conv") || (layerType == "depthwise") || (layerType == "tconv"))
        {
            std::string inputName = parsedLayer.GetStr("bottom");
            danglingOutputs.erase(inputName);
            const bool depthwiseConv = (layerType == "depthwise");
            uint32_t kernelHeight    = 0;
            uint32_t kernelWidth     = 0;

            // We might receive the kernel size as "kernel size" when square or as "kernel h" or "kernel w".
            if (parsedLayer.Exists("kernel size"))
            {
                kernelHeight = parsedLayer.GetInt("kernel size");
                kernelWidth  = kernelHeight;
            }
            else
            {
                kernelHeight = parsedLayer.GetInt("kernel h");
                kernelWidth  = parsedLayer.GetInt("kernel w");
            }

            uint32_t strideHeight = 0;
            uint32_t strideWidth  = 0;

            if (parsedLayer.Exists("stride"))
            {
                strideHeight = parsedLayer.GetInt("stride");
                strideWidth  = strideHeight;
            }
            else
            {
                strideHeight = parsedLayer.GetInt("stride h");
                strideWidth  = parsedLayer.GetInt("stride w");
            }

            PaddingInfo padInfo;
            padInfo.alg = PaddingAlgorithm::SAME;

            if (parsedLayer.Exists("pad top"))
            {
                // User need to specify all the values of padding ie padTop, padBottom, padLeft and padRight
                padInfo.info.padTop    = parsedLayer.GetInt("pad top");
                padInfo.info.padBottom = parsedLayer.GetInt("pad bottom");
                padInfo.info.padLeft   = parsedLayer.GetInt("pad left");
                padInfo.info.padRight  = parsedLayer.GetInt("pad right");

                padInfo.alg = PaddingAlgorithm::EXPLICIT;
            }

            // If user did not specify explicit padding, then the paddingtype needs to be determined
            if (padInfo.alg != PaddingAlgorithm::EXPLICIT)
            {
                // 0 means VALID, 1 means SAME. Default to SAME
                padInfo.alg = (parsedLayer.GetInt("pad", 1) == 0) ? PaddingAlgorithm::VALID : PaddingAlgorithm::SAME;
            }

            bool biasEnable = parsedLayer.GetInt("bias_enable", 0) != 0;

            WeightParams weightParams = parsedLayer.GetWeightParams();
            OutputParams outputParams = parsedLayer.GetOutputParams();

            if (!IsValidNoEntries(weightParams.weightFillerNoEntries))
            {
                throw std::invalid_argument("GgfParser::ParseNetwork If specified, weight filler no_entries value "
                                            "must be between 2 and 255");
            }

            if (depthwiseConv)
            {
                uint32_t channelMultiplier = parsedLayer.GetInt("channel multiplier");
                g_Logger.Debug("GgfParser::AddDepthwiseConvolution %s kernelWidth=%u kernelHeight=%u strideWidth=%u "
                               "strideHeight=%u "
                               "channelMultiplier=%u bias=%d userDefined=%u weightFillerMin=%f weightFillerMax=%f "
                               "weightFillerMean=%f, weightFillerStd=%f "
                               "weightFillerZeroPercentage=%f weightFillerNoEntries=%d\n",
                               layerName.c_str(), kernelWidth, kernelHeight, strideWidth, strideHeight,
                               channelMultiplier, biasEnable, weightParams.isUserDefined, weightParams.weightFillerMin,
                               weightParams.weightFillerMax, weightParams.weightFillerMean,
                               weightParams.weightFillerStd, weightParams.weightFillerZeroPercentage,
                               weightParams.weightFillerNoEntries);

                AddDepthwiseConvolution(layerName, inputName, kernelWidth, kernelHeight, strideWidth, strideHeight,
                                        channelMultiplier, biasEnable, weightParams, outputParams, padInfo);
            }
            else
            {
                const char* fnName = "AddConvolution";
                auto fn            = &GgfParser::AddConvolution;

                if (layerType == "tconv")
                {
                    fnName = "AddTransposeConvolution";
                    fn     = &GgfParser::AddTransposeConvolution;
                }

                uint32_t numOutput = parsedLayer.GetInt("num output");
                g_Logger.Debug("GgfParser::%s %s kernelWidth=%u kernelHeight=%u strideWidth=%u strideHeight=%u "
                               "numOutput=%u bias=%d userDefined=%u weightFillerMin=%f weightFillerMax=%f "
                               "weightFillerMean=%f weightFillerStd=%f "
                               "weightFillerZeroPercentage=%f weightFillerNoEntries=%d",
                               fnName, layerName.c_str(), kernelWidth, kernelHeight, strideWidth, strideHeight,
                               numOutput, biasEnable, weightParams.isUserDefined, weightParams.weightFillerMin,
                               weightParams.weightFillerMax, weightParams.weightFillerMean,
                               weightParams.weightFillerStd, weightParams.weightFillerZeroPercentage,
                               weightParams.weightFillerNoEntries);

                (this->*fn)(layerName, inputName, kernelWidth, kernelHeight, strideWidth, strideHeight, numOutput,
                            biasEnable, weightParams, outputParams, padInfo);
            }

            // If weightFillerZeroPercentage was provided anywhere, disable the 'verify distribution' checker
            if (m_LayerData.GetVerifyDistribution() && parsedLayer.Exists("weight filler zero_percentage"))
            {
                m_LayerData.SetVerifyDistribution(false);
            }
        }
        else if (layerType == "fc")
        {
            std::string inputName = parsedLayer.GetStr("bottom");
            danglingOutputs.erase(inputName);
            uint32_t numOutput = parsedLayer.GetInt("num output");

            WeightParams weightParams = parsedLayer.GetWeightParams();
            OutputParams outputParams = parsedLayer.GetOutputParams();

            if (!IsValidNoEntries(weightParams.weightFillerNoEntries))
            {
                throw std::invalid_argument("GgfParser::ParseNetwork If specified, weight filler no_entries value "
                                            "must be between 2 and 255");
            }
            g_Logger.Debug("GgfParser::AddFullyConnected %s "
                           "userDefined=%u weightFillerMin=%f weightFillerMax=%f "
                           "weightFillerMean=%f weightFillerStd=%f "
                           "weightFillerZeroPercentage=%f weightFillerNoEntries=%d\n",
                           layerName.c_str(), weightParams.isUserDefined, weightParams.weightFillerMin,
                           weightParams.weightFillerMax, weightParams.weightFillerMean, weightParams.weightFillerStd,
                           weightParams.weightFillerZeroPercentage, weightParams.weightFillerNoEntries);

            AddFullyConnected(layerName, inputName, numOutput, weightParams, outputParams);

            // If weightFillerZeroPercentage was provided anywhere, disable the 'verify distribution' checker
            if (m_LayerData.GetVerifyDistribution() && parsedLayer.Exists("weight filler zero_percentage"))
            {
                m_LayerData.SetVerifyDistribution(false);
            }
        }
        else if (layerType == "relu")
        {
            std::string inputName = parsedLayer.GetStr("bottom");
            // Note we *don't* remove the input from danglingLayers because the relu effectively "merges"
            // with its input to become one layer and so we still haven't 'used' the output of this layer
            // until something else attaches to it.
            g_Logger.Debug("GgfParser::AddRelu %s", layerName.c_str());
            AddRelu(layerName, inputName);
        }
        else if (layerType == "leakyrelu")
        {
            std::string inputName = parsedLayer.GetStr("bottom");
            float alpha           = 0.01f;

            if (parsedLayer.Exists("alpha"))
            {
                alpha = parsedLayer.GetFloat("alpha");
            }
            // Note we *don't* remove the input from danglingLayers because the leakyrelu effectively "merges"
            // with its input to become one layer and so we still haven't 'used' the output of this layer
            // until something else attaches to it.
            g_Logger.Debug("GgfParser::AddLeakyRelu %s", layerName.c_str());
            AddLeakyRelu(layerName, inputName, alpha);
        }
        else if (layerType == "requantize")
        {
            std::string inputName = parsedLayer.GetStr("bottom");
            danglingOutputs.erase(inputName);
            int32_t zeroPoint;
            float scale;

            if (parsedLayer.Exists("zeroPoint"))
            {
                zeroPoint = parsedLayer.GetInt("zeroPoint");
            }
            else
            {
                throw std::invalid_argument("Error: unable to parse zeroPoint parameter in requantize layer.");
            }

            if (parsedLayer.Exists("scale"))
            {
                scale = parsedLayer.GetFloat("scale");
            }
            else
            {
                throw std::invalid_argument("Error: unable to parse scale parameter in requantize layer.");
            }

            RequantizeInfo requantizeInfo{ QuantizationInfo(zeroPoint, scale) };
            g_Logger.Debug("GgfParser::AddRequantize %s", layerName.c_str());
            AddRequantize(layerName, inputName, requantizeInfo);
        }
        else if (layerType == "sigmoid")
        {
            std::string inputName = parsedLayer.GetStr("bottom");
            // Note we *don't* remove the input from danglingLayers because the sigmoid effectively "merges"
            // with its input to become one layer and so we still haven't 'used' the output of this layer
            // until something else attaches to it.
            g_Logger.Debug("GgfParser::AddSigmoid %s", layerName.c_str());
            AddSigmoid(layerName, inputName);
        }
        else if (layerType == "tanh")
        {
            std::string inputName = parsedLayer.GetStr("bottom");
            // Note we *don't* remove the input from danglingLayers because the tanh effectively "merges"
            // with its input to become one layer and so we still haven't 'used' the output of this layer
            // until something else attaches to it.
            g_Logger.Debug("GgfParser::AddTanh %s", layerName.c_str());
            AddTanh(layerName, inputName);
        }
        else if (layerType == "mean")
        {
            std::string inputName = parsedLayer.GetStr("bottom");

            danglingOutputs.erase(inputName);

            // 1 - keep_dims is set to true
            // 0 - keep_dims is set to false
            bool keep_dims = (parsedLayer.GetUInt("keep_dims") == 1U);

            std::stringstream dimstr(parsedLayer.GetStr("dimension"));
            std::string part;
            std::vector<std::uint32_t> dims;

            while (std::getline(dimstr, part, '_'))
            {
                dims.push_back(static_cast<uint32_t>(std::stoul(part)));
            }

            if (dims.empty())
            {
                dims.push_back(parsedLayer.GetUInt("dimension"));
            }

            if (!keep_dims)
            {
                throw std::invalid_argument("\"keep_dims 0\" is not supported");
            }

            if (!((dims == std::vector<std::uint32_t>{ 2, 3 }) || (dims == std::vector<std::uint32_t>{ 3, 2 })))
            {
                throw std::invalid_argument("only \"dimension 2_3\" is supported");
            }
            AddMeanXy(layerName, inputName);
        }
        else if (layerType == "pooling")
        {
            std::string inputName = parsedLayer.GetStr("bottom");
            danglingOutputs.erase(inputName);
            uint32_t kernelWidth              = 0;
            uint32_t kernelHeight             = 0;
            PoolingType poolingType           = PoolingType::MAX;
            PaddingAlgorithm paddingAlgorithm = PaddingAlgorithm::SAME;

            // We might receive the kernel size as "kernel size" when square or as "kernel h" or "kernel w".
            if (parsedLayer.Exists("kernel size"))
            {
                kernelHeight = parsedLayer.GetInt("kernel size");
                kernelWidth  = kernelHeight;
            }
            else
            {
                kernelHeight = parsedLayer.GetInt("kernel h");
                kernelWidth  = parsedLayer.GetInt("kernel w");
            }

            uint32_t strideWidth  = 0;
            uint32_t strideHeight = 0;

            if (parsedLayer.Exists("stride"))
            {
                strideHeight = parsedLayer.GetInt("stride");
                strideWidth  = strideHeight;
            }
            else
            {
                strideHeight = parsedLayer.GetInt("stride h");
                strideWidth  = parsedLayer.GetInt("stride w");
            }
            // 0 means VALID, 1 means SAME. Default to SAME
            if (parsedLayer.Exists("pad"))
            {
                paddingAlgorithm = parsedLayer.GetInt("pad") ? PaddingAlgorithm::SAME : PaddingAlgorithm::VALID;
            }

            if (parsedLayer.GetStr("pool") == "avg")
            {
                poolingType = PoolingType::AVG;
            }

            Padding padding;
            PoolingInfo poolInfo{ kernelWidth, kernelHeight, strideWidth, strideHeight, padding, poolingType };

            g_Logger.Debug("GgfParser::AddPooling %s poolType=%s", layerName.c_str(),
                           parsedLayer.GetStr("pool").c_str());
            AddPooling(layerName, inputName, poolInfo, paddingAlgorithm);
        }
        else if (layerType == "concat")
        {
            // Split the "bottom" into a list of input layers which are separated by a '_'
            std::stringstream bottom(parsedLayer.GetStr("bottom"));

            std::vector<std::string> inputNames;
            std::string part;
            while (std::getline(bottom, part, '_'))
            {
                inputNames.push_back(part);
            }

            uint32_t axis = parsedLayer.GetInt("axis");

            g_Logger.Debug("GgfParser::AddConcatenation %s axis=%u", layerName.c_str(), axis);

            size_t numInputs = inputNames.size();

            g_Logger.Debug("GgfParser::Inputs to concatenation:");
            for (uint32_t i = 0; i < numInputs; ++i)
            {
                g_Logger.Debug("%s", inputNames[i].c_str());
                danglingOutputs.erase(inputNames[i]);
            }
            AddConcatenation(layerName, inputNames, axis);
        }
        else if (layerType == "split")
        {
            std::string inputName = parsedLayer.GetStr("bottom");
            danglingOutputs.erase(inputName);
            uint32_t axis               = parsedLayer.GetInt("axis");
            std::vector<uint32_t> sizes = parsedLayer.GetUIntArray("sizes");
            // Mark each output as dangling, until it gets used by another layer.
            for (uint32_t i = 0; i < sizes.size(); ++i)
            {
                danglingOutputs.insert(layerName + "_" + std::to_string(i));
            }
            AddSplit(layerName, inputName, axis, sizes);
        }
        else if (layerType == "add")
        {
            // identify names of layers whose output is to be added.
            std::string bottom          = parsedLayer.GetStr("bottom");
            size_t pos                  = bottom.find_first_of('_');
            std::string firstInputName  = bottom.substr(0, pos);
            std::string secondInputName = bottom.substr(pos + 1);
            danglingOutputs.erase(firstInputName);
            danglingOutputs.erase(secondInputName);

            g_Logger.Debug("GgfParser::AddAddition %s firstInputName=%s secondInputName=%s", layerName.c_str(),
                           firstInputName.c_str(), secondInputName.c_str());
            AddAddition(layerName, firstInputName, secondInputName);
        }
        else if (layerType == "mul")
        {
            // identify names of layers whose output is to be multiplied.
            std::string bottom          = parsedLayer.GetStr("bottom");
            size_t pos                  = bottom.find_first_of('_');
            std::string firstInputName  = bottom.substr(0, pos);
            std::string secondInputName = bottom.substr(pos + 1);
            danglingOutputs.erase(firstInputName);
            danglingOutputs.erase(secondInputName);

            g_Logger.Debug("GgfParser::AddMultiplication %s firstInputName=%s secondInputName=%s", layerName.c_str(),
                           firstInputName.c_str(), secondInputName.c_str());
            AddMultiplication(layerName, firstInputName, secondInputName);
        }
        else if (layerType == "reshape")
        {
            std::string inputName = parsedLayer.GetStr("bottom");
            danglingOutputs.erase(inputName);
            TensorShape shape = parsedLayer.GetTensorShape("shape");
            g_Logger.Debug("GgfParser::AddReshape: %s shape={%d,%d,%d,%d}", layerName.c_str(), shape[0], shape[1],
                           shape[2], shape[3]);
            AddReshape(layerName, inputName, shape);
        }
        else if (layerType == "depthtospace")
        {
            std::string inputName = parsedLayer.GetStr("bottom");
            danglingOutputs.erase(inputName);
            uint32_t blockSize = parsedLayer.GetUInt("block_size");
            AddDepthToSpace(layerName, inputName, blockSize);
        }
        else if (layerType == "spacetodepth")
        {
            std::string inputName = parsedLayer.GetStr("bottom");
            danglingOutputs.erase(inputName);
            uint32_t blockSize = parsedLayer.GetUInt("block_size");
            AddSpaceToDepth(layerName, inputName, blockSize);
        }
        else if (layerType == "output")
        {
            std::string inputName = parsedLayer.GetStr("bottom");
            danglingOutputs.erase(inputName);
            g_Logger.Debug("GgfParser::AddOutput: %s", layerName.c_str());
            AddOutput(layerName, inputName);
        }
        else if (layerType == "transpose")
        {
            std::string inputName = parsedLayer.GetStr("bottom");
            danglingOutputs.erase(inputName);
            TensorShape permutation = parsedLayer.GetTensorShape("permutation");
            g_Logger.Debug("GgfParser:AddTranspose %s permutation(%d, %d, %d, %d)", layerName.c_str(), permutation[0],
                           permutation[1], permutation[2], permutation[3]);
            AddTranspose(layerName, inputName, permutation);
        }
        else if (layerType == "upsample")
        {
            std::string inputName = parsedLayer.GetStr("bottom");
            danglingOutputs.erase(inputName);
            ResizeParams resizeParams;

            resizeParams.m_Algo = UIntToResizeAlgorithm(parsedLayer.GetUInt("scale_algo"));

            if (parsedLayer.Exists("new height"))
            {
                resizeParams.m_Height.m_Size = parsedLayer.GetInt("new height");
            }
            else if (parsedLayer.Exists("upsample scale height ratio"))
            {
                resizeParams.m_Height.m_Ratio = parsedLayer.GetFloat("upsample scale height ratio");
            }

            if (parsedLayer.Exists("new width"))
            {
                resizeParams.m_Width.m_Size = parsedLayer.GetInt("new width");
            }
            else if (parsedLayer.Exists("upsample scale width ratio"))
            {
                resizeParams.m_Width.m_Ratio = parsedLayer.GetFloat("upsample scale width ratio");
            }

            if (parsedLayer.Exists("upsample mode height"))
            {
                resizeParams.m_Height.m_Mode = UIntToResizeMode(parsedLayer.GetInt("upsample mode height"));
            }

            if (parsedLayer.Exists("upsample mode width"))
            {
                resizeParams.m_Width.m_Mode = UIntToResizeMode(parsedLayer.GetInt("upsample mode width"));
            }

            g_Logger.Debug("GgfParser:AddResize %s", layerName.c_str());
            // Using resize and not upsample as per Arm NN/TfLite  name conventions.
            AddResize(layerName, inputName, resizeParams);
        }
        else if (layerType == "padding")
        {
            std::string inputName = parsedLayer.GetStr("bottom");
            danglingOutputs.erase(inputName);
            PaddingInfo padInfo;
            padInfo.alg = PaddingAlgorithm::EXPLICIT;

            // User need to specify all the values of padding ie padTop, padBottom, padLeft and padRight
            padInfo.info.padTop    = parsedLayer.GetInt("pad_top");
            padInfo.info.padBottom = parsedLayer.GetInt("pad_bottom");
            padInfo.info.padLeft   = parsedLayer.GetInt("pad_left");
            padInfo.info.padRight  = parsedLayer.GetInt("pad_right");

            AddStandalonePadding(layerName, inputName, padInfo);
        }
        else
        {
            std::string error = "Error: Unable to parse line in ggf file: " + std::to_string(lineNumber) + "\n" + line;
            throw std::invalid_argument(error);
        }
    }

    if (m_LayerData.GetUserInputQuantScale() ^ m_LayerData.GetUserInputQuantZeroPoint())
    {
        throw std::invalid_argument("User defined input quantization: must set both zeroPoint and scale");
    }

    if (m_LayerData.GetUserWeightQuantScale() ^ m_LayerData.GetUserWeightQuantZeroPoint())
    {
        throw std::invalid_argument("User defined Weight quantization: must set both zeroPoint and scale");
    }

    if (m_LayerData.GetUserOutputQuantScale() ^ m_LayerData.GetUserOutputQuantZeroPoint())
    {
        throw std::invalid_argument("User defined Output quantization: must set both zeroPoint and scale");
    }

    // Add implicit outputs connected to any 'dangling' outputs
    for (std::string danglingOutputName : danglingOutputs)
    {
        std::string outputName = "output_" + danglingOutputName;
        AddOutput(outputName, danglingOutputName);
    }
}

void GgfParser::AddInput(const std::string& name, ethosn::support_library::TensorShape shape)
{
    m_InputLayerNames.push_back(name);
    m_InputLayerShapes.push_back(shape);
}

void GgfParser::AddOutput(const std::string& name, const std::string&)
{
    m_OutputLayerNames.push_back(name);
}

bool GgfParser::IsValidNoEntries(const int32_t noEntries)
{
    return noEntries == -1 || (noEntries < 256 && noEntries >= 2);
}

}    // namespace system_tests
}    // namespace ethosn
